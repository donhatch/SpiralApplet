<!DOCTYPE html>
<html>
<head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>Figures for The Spiral Moment Lemma: There's No Single-Exit Lagoon</title>
    <style type="text/css">
        body {font-size:large;}
    </style>

    <script
        src="http://code.jquery.com/jquery-1.7.1.min.js">
    </script>
    <script>
	// make $ not be an alias for jQuery
        // since I think that's ridiculous...
        jQuery.noConflict();
    </script>


    <script>

        //
        // complex arithmetic, 
        // with complex numbers represented as [x,y]
        //
        var times = function(z0,z1) {
            return [z0[0]*z1[0]-z0[1]*z1[1],
                    z0[0]*z1[1]+z0[1]*z1[0]];
        };
        var plus = function(z0,z1) {
            return [z0[0]+z1[0],z0[1]+z1[1]];
        };
        var minus = function(z0,z1) {
            return [z0[0]-z1[0],z0[1]-z1[1]];
        };
        var inverse = function(z) {
            return scaled(conj(z),1/length2(z));
        };
        var dividedby = function(z0,z1) {
            return times(z0,inverse(z1));
        };
        var conj = function(z) {
            return [z[0],-z[1]];
        };
        // z00:z01 :: z10 : ?
        // answer is z01*z10/z00.
        var analogy = function(z00,z01,z10) {
            return dividedby(times(z01,z10),z00);
        };
        var cross = function(a,b) {
            return a[0]*b[1] - a[1]*b[0];
        };
        var dot = function(a,b) {
            return a[0]*b[0] + a[1]*b[1];
        };
        var length2 = function(z) {
            return dot(z,z);
        };
        var length = function(z) {
            return Math.sqrt(length2(z));
        };
        var normalized = function(z) {
            var l = length(z);
            return [z[0]/l, z[1]/l];
        };
        var perpDot = function(z) {
            return [-z[1], z[0]];
        };
        var scaled = function(z,s) {
            return [z[0]*s, z[1]*s];
        };


        var makeThePaths = function(x1,y1, x2,y2, nNeighbors)
        {
            {
                var len2 = Math.sqrt(x2*x2+y2*y2);
                x2 /= len2;
                y2 /= len2;
                x1 /= len2;
                y1 /= len2;
                len2 = undefined;
            }

            var d0 = [x1,y1]
            var d1 = [x2,y2]
            var p0 = [cross(d0,d1),dot(d0,d1)]
            var p1 = [0,1]
            var p2 = analogy(p0,p1,p1)
            var qLength = length(minus(p1,p0)); // make quill same length as primal edge, seems to look fairly decent
            var q0 = plus(p1,scaled(normalized([y2-y1,x1-x2]),qLength));


            var dudleyMainPath = "M 0 0 L "+d0[0]+" "+d0[1]+" L "+d1[0]+" "+d1[1]+" L 0 0";

            // scratch
            var z;
            var Z;
            var temp;

            var dudleyNeighborsPath = "";
            {
                z = d0;
                Z = d1;
                for (var iNeighbor = 0; iNeighbor < nNeighbors; ++iNeighbor)
                {
                    temp = analogy(z,Z,Z);
                    z = Z;
                    Z = temp;
                    dudleyNeighborsPath += " M "+z[0]+" "+z[1]+" L "+Z[0]+" "+Z[1]+" L 0 0"
                }
                z = d0;
                Z = d1;
                for (var iNeighbor = 0; iNeighbor < nNeighbors; ++iNeighbor)
                {
                    temp = analogy(Z,z,z);
                    Z = z;
                    z = temp;
                    dudleyNeighborsPath += " M "+Z[0]+" "+Z[1]+" L "+z[0]+" "+z[1]+" L 0 0"
                }
            }


            var priscillaMainPath = "M "+p0[0]+" "+p0[1]+" L "+p1[0]+" "+p1[1]+" L "+p2[0]+" "+p2[1]+" M "+p1[0]+" "+p1[1]+" L "+q0[0]+" "+q0[1];
            var priscillaNeighborsPath = "";
            if (1)
            {
                z = p1;
                Z = p2;
                for (var iNeighbor = 0; iNeighbor < nNeighbors; ++iNeighbor)
                {
                    temp = analogy(z,Z,Z);
                    z = Z;
                    Z = temp;
                    q = analogy(p1,q0,z);
                    priscillaNeighborsPath += " M "+Z[0]+" "+Z[1]+" L "+z[0]+" "+z[1]+" L "+q[0]+" "+q[1]
                }
                z = p0;
                Z = p1;
                for (var iNeighbor = 0; iNeighbor < nNeighbors; ++iNeighbor)
                {
                    temp = analogy(Z,z,z);
                    Z = z;
                    z = temp;
                    q = analogy(p1,q0,Z);
                    priscillaNeighborsPath += " M "+q[0]+" "+q[1]+" L "+Z[0]+" "+Z[1]+" L "+z[0]+" "+z[1]
                }
            }


            if (priscillaNeighborsPath == "")
            {
                priscillaNeighborsPath = "M 0 0";
            }
            if (dudleyNeighborsPath == "")
            {
                dudleyNeighborsPath = "M 0 0";
            }

            return [dudleyMainPath,dudleyNeighborsPath,
                    priscillaMainPath,priscillaNeighborsPath,
                    d0,d1];
        } // makeThePaths

        var doIt = function(x1,y1,x2,y2,nNeighbors) {
            console.log("    in doIt");

            var dudleyMainPath = jQuery('#dudleyMainPath');
            var dudleyNeighborsPath = jQuery('#dudleyNeighborsPath');
            var priscillaMainPath = jQuery('#priscillaMainPath');
            var priscillaNeighborsPath = jQuery('#priscillaNeighborsPath');
            var d0transform = jQuery('#d0transform');
            var d0transform1 = jQuery('#d0transform1');
            var d1transform = jQuery('#d1transform');
            console.log("        dudleyMainPath = ",dudleyMainPath);
            console.log("        dudleyMainPath.attr('d') = ",dudleyMainPath.attr('d'));


            var paths = makeThePaths(x1,y1,x2,y2, nNeighbors);


            dudleyMainPath.attr('d', paths[0]);
            dudleyNeighborsPath.attr('d', paths[1]);
            priscillaMainPath.attr('d', paths[2]);
            priscillaNeighborsPath.attr('d', paths[3]);
            var d0 = paths[4];
            var d1 = paths[5];
            d0transform.attr('transform', 'translate('+d0[0]+','+d0[1]+')');
            d1transform.attr('transform', 'translate('+d1[0]+','+d1[1]+')');
            console.log("    out doIt");
        };

        jQuery(document).ready(function() {
            console.log("in jquery document-ready function!");

            var global_x1 = 6;
            var global_y1 = 2;
            var global_x2 = 8;
            var global_y2 = 6;
            var global_nNeighbors = 10;
            doIt(global_x1, global_y1, global_x2, global_y2, global_nNeighbors);

            // using MathJax.Hub.Queue(["Typeset",MathJax.Hub]).

            console.log("out jquery document-ready function!");
        }); // jquery document ready function
    </script>
</head>
<body>

<p>

<svg id="theFigure" xmlns="http://www.w3.org/2000/svg"
     version="1.1"
     height="500"
     width="500"
     >
    <!-- 1 unit = 20 pixels -->
    <g id="theGraphic"
       transform="translate(250,400) scale(1,-1) scale(200)">
       
        <path
            id="dudleyMainPath"
            vector-effect="non-scaling-stroke"
            style="stroke: blue; stroke-width: 3.0; fill: none; stroke-miterlimit:1.414"
            d=" M 1 0 L 0 1 L -1 0 L 0 -1 L 1 0 "
        />
        <path
            id="dudleyNeighborsPath"
            vector-effect="non-scaling-stroke"
            style="stroke: blue; stroke-width: 1.0; fill: none; stroke-opacity:.2"
            d=" M 1 0 L 0 1 L -1 0 L 0 -1 L 1 0 "
        />
        <path
            id="priscillaMainPath"
            vector-effect="non-scaling-stroke"
            style="stroke: red; stroke-width: 1.0; fill: none; stroke-opacity:.2"
            d=" M 1 0 L 0 1 L -1 0 L 0 -1 L 1 0 "
        />
        <path
            id="priscillaNeighborsPath"
            vector-effect="non-scaling-stroke"
            style="stroke: red; stroke-width: 1.0; fill: none; stroke-opacity:.2"
            d=" M 1 0 L 0 1 L -1 0 L 0 -1 L 1 0 "
        />
        <circle
            cx="0" cy="1" r=".025"
            style="stroke: none; fill: red;"
        />
            
        <!-- final local scale must undo effect of global scale! otherwise we get wrong sized text -->
        <g transform="translate(0,0)   scale(.005) scale(1,-1)  translate(-5,15)"> <text>0</text> </g>
        <g transform="translate(0,1)   scale(.005) scale(1,-1)  translate(10,-10)"> <text>p</text> </g>

        <g id="d0transform" transform="translate(0,0)"><g transform="   scale(.005) scale(1,-1)  translate(5,10)">
            <text id="d0text" style="text-decoration:underline">d</text>
        </g> </g>

        <g id="d1transform" transform="translate(0,0)" style="font-size:13.5pt"><g transform="   scale(.005) scale(1,-1)  translate(10,5)">
            <text id="d0text" style="text-decoration:overline">d</text>
        </g> </g>
    </g>
</svg>
</body>
</html>



