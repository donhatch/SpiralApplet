<!DOCTYPE html>
<html>
<head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>Figures for The Spiral Moment Lemma: There's No Single-Exit Lagoon</title>
    <style type="text/css">
        body {font-size:large;}
    </style>

    <script
        src="http://code.jquery.com/jquery-1.7.1.min.js">
    </script>
    <script>
	// make $ not be an alias for jQuery
        // since I think that's ridiculous...
        jQuery.noConflict();
    </script>


    <script>

        //
        // complex arithmetic, 
        // with complex numbers represented as [x,y]
        //
        var times = function(z0,z1) {
            if (typeof(z1) === "number") // XXX surely there's a non-string-based way?
            {
                z1 = [z1,0];
            }
            if (typeof(z0) === "number") // XXX surely there's a non-string-based way?
            {
                z0 = [z0,0];
            }
            return [z0[0]*z1[0]-z0[1]*z1[1],
                    z0[0]*z1[1]+z0[1]*z1[0]];
        };
        var plus = function(z0,z1) {
            return [z0[0]+z1[0],z0[1]+z1[1]];
        };
        var minus = function(z0,z1) {
            return [z0[0]-z1[0],z0[1]-z1[1]];
        };
        var inverse = function(z) {
            return scaled(conj(z),1/length2(z));
        };
        var dividedby = function(z0,z1) {
            return times(z0,inverse(z1));
        };
        var conj = function(z) {
            return [z[0],-z[1]];
        };
        // z00:z01 :: z10 : ?
        // answer is z01*z10/z00.
        var analogy = function(z00,z01,z10) {
            return dividedby(times(z01,z10),z00);
        };
        var cross = function(a,b) {
            return a[0]*b[1] - a[1]*b[0];
        };
        var dot = function(a,b) {
            return a[0]*b[0] + a[1]*b[1];
        };
        var length2 = function(z) {
            return dot(z,z);
        };
        var length = function(z) {
            return Math.sqrt(length2(z));
        };
        var dist2 = function(z0,z1) {
            return length2(minus(z1,z0));
        };
        var dist = function(z0,z1) {
            return Math.sqrt(dist2(z0,z1));
        };
        var normalized = function(z) {
            var l = length(z);
            return [z[0]/l, z[1]/l];
        };
        var perpDot = function(z) {
            return [-z[1], z[0]];
        };
        var scaled = function(z,s) {
            return [z[0]*s, z[1]*s];
        };


        // XXX TODO: d0 not currently used
        var makeThePaths = function(d0,d1,d2, nNeighbors)
        {
            var p0 = [cross(d1,d2),dot(d1,d2)]
            var p1 = [0,1]
            var p2 = analogy(p0,p1,p1)
            var qLength = length(minus(p1,p0)); // make quill same length as primal edge, seems to look fairly decent
            var q0 = plus(p1,normalized(perpDot(minus(d1,d2)),qLength));


            var dudleyMainPath = "M 0 0 L "+d1[0]+" "+d1[1]+" L "+d2[0]+" "+d2[1]+" L 0 0";

            // scratch
            var z;
            var Z;
            var temp;

            var dudleyNeighborsPath = "";
            {
                z = d1;
                Z = d2;
                for (var iNeighbor = 0; iNeighbor < nNeighbors; ++iNeighbor)
                {
                    temp = analogy(z,Z,Z);
                    z = Z;
                    Z = temp;
                    dudleyNeighborsPath += " M "+z[0]+" "+z[1]+" L "+Z[0]+" "+Z[1]+" L 0 0"
                }
                z = d1;
                Z = d2;
                for (var iNeighbor = 0; iNeighbor < nNeighbors; ++iNeighbor)
                {
                    temp = analogy(Z,z,z);
                    Z = z;
                    z = temp;
                    dudleyNeighborsPath += " M "+Z[0]+" "+Z[1]+" L "+z[0]+" "+z[1]+" L 0 0"
                }
            }


            var priscillaMainPath = "M "+p0[0]+" "+p0[1]+" L "+p1[0]+" "+p1[1]+" L "+p2[0]+" "+p2[1]+" M "+p1[0]+" "+p1[1]+" L "+q0[0]+" "+q0[1];
            var priscillaNeighborsPath = "";
            if (1)
            {
                z = p1;
                Z = p2;
                for (var iNeighbor = 0; iNeighbor < nNeighbors; ++iNeighbor)
                {
                    temp = analogy(z,Z,Z);
                    z = Z;
                    Z = temp;
                    q = analogy(p1,q0,z);
                    priscillaNeighborsPath += " M "+Z[0]+" "+Z[1]+" L "+z[0]+" "+z[1]+" L "+q[0]+" "+q[1]
                }
                z = p0;
                Z = p1;
                for (var iNeighbor = 0; iNeighbor < nNeighbors; ++iNeighbor)
                {
                    temp = analogy(Z,z,z);
                    Z = z;
                    z = temp;
                    q = analogy(p1,q0,Z);
                    priscillaNeighborsPath += " M "+q[0]+" "+q[1]+" L "+Z[0]+" "+Z[1]+" L "+z[0]+" "+z[1]
                }
            }


            if (priscillaNeighborsPath == "")
            {
                priscillaNeighborsPath = "M 0 0";
            }
            if (dudleyNeighborsPath == "")
            {
                dudleyNeighborsPath = "M 0 0";
            }

            return [dudleyMainPath,dudleyNeighborsPath,
                    priscillaMainPath,priscillaNeighborsPath,
                    d1,d2];
        } // makeThePaths

        var doIt = function(d0,d1,d2,nNeighbors) {
            console.log("    in doIt");

            var paths = makeThePaths(d0,d1,d2, nNeighbors);


            global_dudleyMainPath.attr('d', paths[0]);
            global_dudleyNeighborsPath.attr('d', paths[1]);
            global_priscillaMainPath.attr('d', paths[2]);
            global_priscillaNeighborsPath.attr('d', paths[3]);
            var d0 = paths[4];
            var d1 = paths[5];
            global_d0transform.attr('transform', 'translate('+d0[0]+','+d0[1]+')');
            global_d1transform.attr('transform', 'translate('+d1[0]+','+d1[1]+')');
            console.log("    out doIt");
        };

        jQuery(document).ready(function() {
            console.log("in jquery document-ready function!");

            // jQuery(s), throwing an error if the result
            // has length other than 1.
            var jQueryExpectingOneThing = function(s) {
                var answer = jQuery(s);
                if (answer.length != 1)
                {
                    // XXX TODO: get this back onto the page somehow
                    throw("ERROR: got "+answer.length+" results from jQuery('"+s+"'), expected 1")
                }
                return answer;
            };

            // global constants (just a cache)
            global_dudleyMainPath = jQueryExpectingOneThing('#dudleyMainPath');
            global_dudleyNeighborsPath = jQueryExpectingOneThing('#dudleyNeighborsPath');
            global_priscillaMainPath = jQueryExpectingOneThing('#priscillaMainPath');
            global_priscillaNeighborsPath = jQueryExpectingOneThing('#priscillaNeighborsPath');
            global_d0transform = jQueryExpectingOneThing('#d0transform');
            global_d1transform = jQueryExpectingOneThing('#d1transform');

            global_d0 = [0,0];
            global_d1 = [6,2];
            global_d2 = [8,6];
            global_nNeighbors = 10;
            {
                var rescale = 1./dist(global_d0, global_d2);
                global_d2 = plus(global_d0,times(minus(global_d2,global_d0), rescale));
                global_d1 = plus(global_d0,times(minus(global_d1,global_d0), rescale));
                rescale = undefined;
            }


            // do it the first time
            doIt(global_d0, global_d1, global_d2, global_nNeighbors);

            var localToScreenMatrix = [
                [200.,      undefined, undefined],
                [undefined, -200.,      undefined],
                [250.+9,    400.+19,   undefined],
            ];
            var localToScreen = function(xLocal,yLocal) {
                return [xLocal*localToScreenMatrix[0][0]
                       +localToScreenMatrix[2][0],
                       +yLocal*localToScreenMatrix[1][1]
                       +localToScreenMatrix[2][1]];
            };
            var screenToLocal = function(xScreen,yScreen) {
                return [(xScreen-localToScreenMatrix[2][0])/localToScreenMatrix[0][0],
                        (yScreen-localToScreenMatrix[2][1])/localToScreenMatrix[1][1]];
            };

            // install press/drag/release handlers
            var theFigure = jQueryExpectingOneThing('#theFigure');
            var dragging = false;
            theFigure.mousedown(function(e) {
                console.log("mouse down: ",e);
                dragging = true;

                global_d1 = screenToLocal(e.clientX,e.clientY);

                doIt(global_d0, global_d1, global_d2, global_nNeighbors);
            });
            theFigure.mouseup(function(e) {
                console.log("mouse up: ",e);
                dragging = false;
            });
            theFigure.mousemove(function(e) {
                //console.log("mouse move: buttons="+e.buttons+" button="+e.button);
                //console.log("    dragging = "+dragging);
                if (dragging)
                {
                    global_d1 = screenToLocal(e.clientX,e.clientY);
                    doIt(global_d0, global_d1, global_d2, global_nNeighbors);
                }
            });

            console.log("out jquery document-ready function!");
        }); // jquery document ready function
    </script>
</head>
<body>

<p>

<svg id="theFigure" xmlns="http://www.w3.org/2000/svg"
     version="1.1"
     height="500"
     width="500"
     >
    <!-- 1 unit = 20 pixels -->
    <g id="theGraphic"
       transform="translate(250,400) scale(1,-1) scale(200)">
       
        <path
            id="dudleyMainPath"
            vector-effect="non-scaling-stroke"
            style="stroke: blue; stroke-width: 3.0; fill: none; stroke-miterlimit:1.414"
            d=" M 1 0 L 0 1 L -1 0 L 0 -1 L 1 0 "
        />
        <path
            id="dudleyNeighborsPath"
            vector-effect="non-scaling-stroke"
            style="stroke: blue; stroke-width: 1.0; fill: none; stroke-opacity:.2"
            d=" M 1 0 L 0 1 L -1 0 L 0 -1 L 1 0 "
        />
        <path
            id="priscillaMainPath"
            vector-effect="non-scaling-stroke"
            style="stroke: red; stroke-width: 1.0; fill: none; stroke-opacity:.2"
            d=" M 1 0 L 0 1 L -1 0 L 0 -1 L 1 0 "
        />
        <path
            id="priscillaNeighborsPath"
            vector-effect="non-scaling-stroke"
            style="stroke: red; stroke-width: 1.0; fill: none; stroke-opacity:.2"
            d=" M 1 0 L 0 1 L -1 0 L 0 -1 L 1 0 "
        />
        <circle
            cx="0" cy="1" r=".025"
            style="stroke: none; fill: red;"
        />
            
        <!-- final local scale must undo effect of global scale! otherwise we get wrong sized text -->
        <g transform="translate(0,0)   scale(.005) scale(1,-1)  translate(-5,15)"> <text>0</text> </g>
        <g transform="translate(0,1)   scale(.005) scale(1,-1)  translate(10,-10)"> <text>p</text> </g>

        <g id="d0transform" transform="translate(0,0)"><g transform="   scale(.005) scale(1,-1)  translate(5,10)">
            <text id="d0text" style="text-decoration:underline">d</text>
        </g> </g>

        <g id="d1transform" transform="translate(0,0)" style="font-size:13.5pt"><g transform="   scale(.005) scale(1,-1)  translate(10,5)">
            <text id="d0text" style="text-decoration:overline">d</text>
        </g> </g>
    </g>
</svg>
</body>
</html>



