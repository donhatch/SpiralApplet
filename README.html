<!DOCTYPE html>
<html>
<head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<!-- initial template from http://docs.mathjax.org/en/latest/start.html -->

<!--
    Notes:
        \; for thick space
        \: for medium space
        \, for thin space
        \! for negative thin space

    Can't seem to adjust print font size by user :-(
    so messing with it in the style sheet here.
    Font sizes:
        xx-small
        x-small
        small
        medium
        large
        x-large
        xx-large

    TODO: my specified default zoom trigger not working?
    TODO: areaTri?
    TODO: it would be awesome if it were possible to start typesetting
          at a particular place in the page, right after the anchor 
          we started loading the page at
    TODO: figure out how to validate?
    TODO: can't seem to get asciimath to work?  oh wait! it's working, from the web page http://cdn.mathjax.org/mathjax/2.1-latest/test/sample-asciimath.html .  EEK, works over the web but not locally?? hmm.  wonder if I need to put something locally? or enable something?  weird
    TODO: make some inline SVG images!
                http://www.w3schools.com/html/html5_svg.asp
    TODO: css validator is giving me errors on the styles inside the svg sections, wtf?
        ERROR: Property stroke doesn't exist : blue
        ERROR: Property stroke-width doesn't exist : 2.0
        ERROR: Property fill doesn't exist : none
    TODO: main validator:
        ERROR: Attribute vector-effect not allowed on element path at this point.
        oh no! and if I try to change version from 1.1 to 1.2 it says:
            Unsupported SVG version specified. This validator only supports SVG 1.1. The recommended way to suppress this warning is to remove the version attribute altogether.
    TODO: can I preprocess the preprocessed stuff so that _x and ^x mean \underline{x} and \overline{x}?
        
        
-->
    <title>There's No Single-Exit Lagoon</title>
    <style type="text/css">
        p.breakhere {page-break-before:always;}
        .asciiprevis {display:none;}

        /*
            ARGH! anything media-specific causes corrupt output of math when printing!
            need to figure out why!
        */

            body {font-size:x-large;}

        /*
        * increase default font size.  Im getting old.
        * (user can do this using ctrl-{+,-,0}
        @media screen {
            body {font-size:xx-small;}
        }
         increase the font size even more when printing--
         for some reason it comes out really tiny otherwise.
         I havent figured out any way to tell chrome to do that otherwise.
        @media print {
            body {font-size:x-large;}
        }
        */

        /*
         ARGH! anything media-specific causes corrupt output, it seems.
         so, make a global setting of the setting I want for print.

         XXX wait a minute, somethings fucked...
         are comments not working like I expected?
         the font-size directive works when above this comment, but not below it??
         the following works when
        */
    </style>

    <script type="text/javascript">
        /*
        To make the source of the proofs
        more readable and maintainable,
        the following preprocessing is done
        on all latex math (anything inside $...$'s or $$..$$'s)
        before feeding it to mathjax's tex processor.
        (In fact, rather than trying to detect where the $'s begin and end,
        we just do this on the whole darn document,
        hopefully excluding this explanation)
        1.
            Any of the following:
                _  ^  ^_  _^
            followed by any thing of the following:
                tp tm td
                rp rm rd
                xp xm xd
                yp ym yd
            get transformed into the respective one of
                \underline{thing}
                \overline{thing}
                \underline{\overline{thing}}
                \overline{\underline{thing}}
            (the latter two are effectively the same).
            (The _ and ^ go before the object rather than after,
            to avoid complication in parsing, for example, rd^2)
        2.
            The following:
                tp tm td
                rp rm rd
                xp xm xd
                yp ym yd
            get turned into, respectively:
                {\theta_p} {\theta_m} {\theta_d}
                {r_p} {r_m} {r_d}
                {x_p} {x_m} {x_d}
                {y_p} {y_m} {y_d}

        How to do this?
        Well, the following says there's a way to register a function
        as a preprocessor:
            https://groups.google.com/forum/?fromgroups=#!topic/mathjax-users/lWmbG9FClJs
        It says there's currently no way to get my preprocessor
        to run before the others, however mml2jax is the only extension
        that currently loads a preprocessor so it should be safe
        (DANGER-- might this change?)
        Davide also suggests making it a config file
        and loading it before original combined config file.

        */
    </script>

    <script type="text/x-mathjax-config">
        MathJax.Hub.Config({
            tex2jax: {
                // make '$' delimit inline math
                inlineMath: [['$','$'], ['\\(','\\)']],
                // make \$ give a real dollar sign, even in non-math mode
                processEscapes: true,
            },

            TeX: {
                Macros: {
                    underoverline: ["\\underline{\\overline{#1}}",1],
                    overunderline: ["\\overline{\\underline{#1}}",1],
                    _: ["\\underline{#1}",1],
                    /* aww hell, it works with _ but not with ^ */
                    /* ^: ["\\overline{#1}",1], */
                },
            },
            asciimath2jax: {
                delimiters: [['`','`']],
            },
            menuSettings: {
                // make it so that hovering over an equation zooms it
                // (right click on an equation to see how to alter this
                // within a session)
                // XXX this isn't working?
                zoom: 'hover',
            },
            "HTML-CSS": {
                // oh hmm, it's complicated... see http://docs.mathjax.org/en/latest/options/HTML-CSS.html  .  not sure how to get a font I want.
                preferredFont: "STIX",
            },
        });


        // XXX YOU ARE HERE -- modify the following for my own nefarious needs
        MathJax.Hub.Register.PreProcessor(["PreProcess", {
          version: "2.1",
          config: {
            inlineMath: [              // The start/stop pairs for in-line math
        //    ['$','$'],               //  (comment out any you don't want, or add your own, but
              ['\\(','\\)']            //  be sure that you don't have an extra comma at the end)
            ],

            displayMath: [             // The start/stop pairs for display math
              ['$$','$$'],             //  (comment out any you don't want, or add your own, but
              ['\\[','\\]']            //  be sure that you don't have an extra comma at the end)
            ],

            balanceBraces: true,       // determines whether tex2jax requires braces to be
                                       // balanced within math delimiters (allows for nested
                                       // dollar signs).  Set to false to get pre-v2.0 compatibility.

            skipTags: ["script","noscript","style","textarea","pre","code"],
                                       // The names of the tags whose contents will not be
                                       // scanned for math delimiters

            ignoreClass: "tex2jax_ignore",    // the class name of elements whose contents should
                                              // NOT be processed by tex2jax.  Note that this
                                              // is a regular expression, so be sure to quote any
                                              // regexp special characters

            processClass: "tex2jax_process",  // the class name of elements whose contents SHOULD
                                              // be processed when they appear inside ones that
                                              // are ignored.  Note that this is a regular expression,
                                              // so be sure to quote any regexp special characters

            processEscapes: false,     // set to true to allow \$ to produce a dollar without
                                       //   starting in-line math mode

            processEnvironments: true, // set to true to process \begin{xxx}...\end{xxx} outside
                                       //   of math mode, false to prevent that

            processRefs: true,         // set to true to process \ref{...} outside of math mode


            preview: "TeX"             // set to "none" to not insert MathJax_Preview spans
                                       //   or set to an array specifying an HTML snippet
                                       //   to use the same preview for every equation.

          },
          
          doMyThing: function (element,depth) {
            //window.alert("in doMyThing(depth="+depth+": element="+element+" nodeValue="+element.nodeValue+" firstChild = "+element.firstChild+" nextSibling="+element.nextSibling+" className="+element.className+" tagName="+element.tagName);
            if (element.nodeValue != null)
            {
                element.nodeValue = element.nodeValue.replace(/\b([trxy]_?[dmp][_^][^2])/g,'\\color{red}{\\fbox{BAD0: $1}}')
                element.nodeValue = element.nodeValue.replace(/\b([trxy]_[dmp]\b)/g,'\\color{green}{\\fbox{BAD1: $1}}')
                element.nodeValue = element.nodeValue.replace(/(\\theta_)/g,'\\color{blue}{\\fbox{BAD2: $1}}')

                element.nodeValue = element.nodeValue.replace(/\^_([trxy][dmp])\b/g,'\\overline{\\underline{$1}}')
                element.nodeValue = element.nodeValue.replace(/_\^([trxy][dmp])\b/g,'\\underline{\\overline{$1}}')
                element.nodeValue = element.nodeValue.replace(/_([trxy][dmp])\b/g,'\\underline{$1}')
                element.nodeValue = element.nodeValue.replace(/\^([trxy][dmp])\b/g,'\\overline{$1}')

                element.nodeValue = element.nodeValue.replace(/\b(t)([dmp])\b/g,'{\\theta_$2}')
                element.nodeValue = element.nodeValue.replace(/\b([rxy])([dmp])\b/g,'{$1_$2}')
            }
            for (var child = element.firstChild; child != null; child = child.nextSibling)
            {
                this.doMyThing(child,depth+1);
            }
          },

          PreProcess: function (element) {
            if (!this.configured) {
              this.config = MathJax.Hub.CombineConfig("tex2jax",this.config);
              if (this.config.Augment) {MathJax.Hub.Insert(this,this.config.Augment)}
              if (typeof(this.config.previewTeX) !== "undefined" && !this.config.previewTeX)
                {this.config.preview = "none"} // backward compatibility for previewTeX parameter
              this.configured = true;
            }
            if (typeof(element) === "string") {element = document.getElementById(element)}
            if (!element) {element = document.body}

            this.doMyThing(element,0);

            if (this.createPatterns()) {this.scanElement(element,element.nextSibling)}
          },
          
          createPatterns: function () {
            var starts = [], parts = [], i, m, config = this.config;
            this.match = {};
            for (i = 0, m = config.inlineMath.length; i < m; i++) {
              starts.push(this.patternQuote(config.inlineMath[i][0]));
              this.match[config.inlineMath[i][0]] = {
                mode: "",
                end: config.inlineMath[i][1],
                pattern: this.endPattern(config.inlineMath[i][1])
              };
            }
            for (i = 0, m = config.displayMath.length; i < m; i++) {
              starts.push(this.patternQuote(config.displayMath[i][0]));
              this.match[config.displayMath[i][0]] = {
                mode: "; mode=display",
                end: config.displayMath[i][1],
                pattern: this.endPattern(config.displayMath[i][1])
              };
            }
            if (starts.length) {parts.push(starts.sort(this.sortLength).join("|"))}
            if (config.processEnvironments) {parts.push("\\\\begin\\{([^}]*)\\}")}
            if (config.processEscapes)      {parts.push("\\\\*\\\\\\\$")}
            if (config.processRefs)         {parts.push("\\\\(eq)?ref\\{[^}]*\\}")}
            this.start = new RegExp(parts.join("|"),"g");
            this.skipTags = new RegExp("^("+config.skipTags.join("|")+")$","i");
            this.ignoreClass = new RegExp("(^| )("+config.ignoreClass+")( |$)");
            this.processClass = new RegExp("(^| )("+config.processClass+")( |$)");
            return (parts.length > 0);
          },
          
          patternQuote: function (s) {return s.replace(/([\^$(){}+*?\-|\[\]\:\\])/g,'\\$1')},
          
          endPattern: function (end) {
            return new RegExp(this.patternQuote(end)+"|\\\\.|[{}]","g");
          },
          
          sortLength: function (a,b) {
            if (a.length !== b.length) {return b.length - a.length}
            return (a == b ? 0 : (a < b ? -1 : 1));
          },
          
          scanElement: function (element,stop,ignore) {
            var cname, tname, ignoreChild, process;
            while (element && element != stop) {
              if (element.nodeName.toLowerCase() === '#text') {
                if (!ignore) {element = this.scanText(element)}
              } else {

                cname = (typeof(element.className) === "undefined" ? "" : element.className);
                tname = (typeof(element.tagName)   === "undefined" ? "" : element.tagName);
                if (typeof(cname) !== "string") {cname = String(cname)} // jsxgraph uses non-string class names!
                process = this.processClass.exec(cname);
                if (element.firstChild && !cname.match(/(^| )MathJax/) &&
                     (process || !this.skipTags.exec(tname))) {
                  ignoreChild = (ignore || this.ignoreClass.exec(cname)) && !process;
                  this.scanElement(element.firstChild,stop,ignoreChild);
                }
              }
              if (element) {element = element.nextSibling}
            }
          },
          
          scanText: function (element) {

            if (element.nodeValue.replace(/\s+/,'') == '') {return element}
            var match, prev;
            this.search = {start: true};
            this.pattern = this.start;
            while (element) {
              this.pattern.lastIndex = 0;
              while (element && element.nodeName.toLowerCase() === '#text' &&
                    (match = this.pattern.exec(element.nodeValue))) {
                if (this.search.start) {element = this.startMatch(match,element)}
                                  else {element = this.endMatch(match,element)}
              }
              if (this.search.matched) {element = this.encloseMath(element)}
              if (element) {
                do {prev = element; element = element.nextSibling}
                  while (element && (element.nodeName.toLowerCase() === 'br' ||
                                     element.nodeName.toLowerCase() === '#comment'));
                if (!element || element.nodeName !== '#text')
                  {return (this.search.close ? this.prevEndMatch() : prev)}
              }
            }
            return element;
          },
          
          startMatch: function (match,element) {
            var delim = this.match[match[0]];
            if (delim != null) {                              // a start delimiter
              this.search = {
                end: delim.end, mode: delim.mode, pcount: 0,
                open: element, olen: match[0].length, opos: this.pattern.lastIndex - match[0].length
              };
              this.switchPattern(delim.pattern);
            } else if (match[0].substr(0,6) === "\\begin") {  // \begin{...}
              this.search = {
                end: "\\end{"+match[1]+"}", mode: "; mode=display", pcount: 0,
                open: element, olen: 0, opos: this.pattern.lastIndex - match[0].length,
                isBeginEnd: true
              };
              this.switchPattern(this.endPattern(this.search.end));
            } else if (match[0].substr(0,4) === "\\ref" || match[0].substr(0,6) === "\\eqref") {
              this.search = {
                mode: "", end: "", open: element, pcount: 0,
                olen: 0, opos: this.pattern.lastIndex - match[0].length
              }
              return this.endMatch([""],element);
            } else {                                         // escaped dollar signs
              // put $ in a span so it doesn't get processed again
              // split off backslashes so they don't get removed later
              var slashes = match[0].substr(0,match[0].length-1), n, span;
              if (slashes.length % 2 === 0) {span = [slashes.replace(/\\\\/g,"\\")]; n = 1}
                else {span = [slashes.substr(1).replace(/\\\\/g,"\\"),"$"]; n = 0}
              span = MathJax.HTML.Element("span",null,span);
              var text = MathJax.HTML.TextNode(element.nodeValue.substr(0,match.index));
              element.nodeValue = element.nodeValue.substr(match.index + match[0].length - n);
              element.parentNode.insertBefore(span,element);
              element.parentNode.insertBefore(text,span);
              this.pattern.lastIndex = n;
            }
            return element;
          },
          
          endMatch: function (match,element) {
            var search = this.search;
            if (match[0] == search.end) {
              if (!search.close || search.pcount === 0) {
                search.close = element;
                search.cpos = this.pattern.lastIndex;
                search.clen = (search.isBeginEnd ? 0 : match[0].length);
              }
              if (search.pcount === 0) {
                search.matched = true;
                element = this.encloseMath(element);
                this.switchPattern(this.start);
              }
            }
            else if (match[0] === "{") {search.pcount++}
            else if (match[0] === "}" && search.pcount) {search.pcount--}
            return element;
          },
          prevEndMatch: function () {
            this.search.matched = true;
            var element = this.encloseMath(this.search.close);
            this.switchPattern(this.start);
            return element;
          },
          
          switchPattern: function (pattern) {
            pattern.lastIndex = this.pattern.lastIndex;
            this.pattern = pattern;
            this.search.start = (pattern === this.start);
          },
          
          encloseMath: function (element) {
            var search = this.search, close = search.close, CLOSE, math;
            if (search.cpos === close.length) {close = close.nextSibling}
               else {close = close.splitText(search.cpos)}
            if (!close) {CLOSE = close = MathJax.HTML.addText(search.close.parentNode,"")}
            search.close = close;
            math = (search.opos ? search.open.splitText(search.opos) : search.open);
            while (math.nextSibling && math.nextSibling !== close) {
              if (math.nextSibling.nodeValue !== null) {
                if (math.nextSibling.nodeName === "#comment") {
                  math.nodeValue += math.nextSibling.nodeValue.replace(/^\[CDATA\[((.|\n|\r)*)\]\]$/,"$1");
                } else {
                  math.nodeValue += math.nextSibling.nodeValue;
                }
              } else if (this.msieNewlineBug) {
                math.nodeValue += (math.nextSibling.nodeName.toLowerCase() === "br" ? "\n" : " ");
              } else {
                math.nodeValue += " ";
              }
              math.parentNode.removeChild(math.nextSibling);
            }
            var TeX = math.nodeValue.substr(search.olen,math.nodeValue.length-search.olen-search.clen);
            math.parentNode.removeChild(math);
            if (this.config.preview !== "none") {this.createPreview(search.mode,TeX)}
            math = this.createMathTag(search.mode,TeX);
            this.search = {}; this.pattern.lastIndex = 0;
            if (CLOSE) {CLOSE.parentNode.removeChild(CLOSE)}
            return math;
          },
          
          insertNode: function (node) {
            var search = this.search;
            search.close.parentNode.insertBefore(node,search.close);
          },
          
          createPreview: function (mode,tex) {
            var preview;
            if (this.config.preview === "TeX") {preview = [this.filterPreview(tex)]}
            else if (this.config.preview instanceof Array) {preview = this.config.preview}
            if (preview) {
              preview = MathJax.HTML.Element("span",{className:MathJax.Hub.config.preRemoveClass},preview);
              this.insertNode(preview);
            }
          },
          
          createMathTag: function (mode,tex) {
            var script = document.createElement("script");
            script.type = "math/tex" + mode;
            MathJax.HTML.setScript(script,tex);
            this.insertNode(script);
            return script;
          },
          
          filterPreview: function (tex) {return tex},
          
          msieNewlineBug: (MathJax.Hub.Browser.isMSIE && document.documentMode < 9)
          
        }]);




    </script>
    <!-- OH! there's an example of In-Line Configuration! I think that's what I want.  oh wait, I don't think it means what I think it means. -->
    <!-- note, the particular config used below allows
         both tex (using $...$)
         and asciimath (using `...`) on same page -->
    <script type="text/javascript"
      src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-MML-AM_HTMLorMML.js">
    </script>
    <!-- XXX can't figure out how to mix my extension with loading from the web, so loading locally for now -->
    <!--
    <script type="text/javascript"
      src="mathjax/mathjax-MathJax-v2.1-24a378e/MathJax.js?config=http://googlee.comm/,./myPreprocessingConfig.js,TeX-MML-AM_HTMLorMML.js">
    </script>
    -->
</head>
<body>
<hr> <!--============================================================-->
$a^b {a}^{b}$
$rp_$
$\underline{hey}$ $xp$ $yp$ $tp$ $_xp$ $_^xp$ $^xp$
... when `x \lt y^2` we have ...
... when $x \lt y^2$ we have ...
`(:
    (a,=,b),
    ( ,=, c)
:)`
will this work? $_x$
how bout this? $^x$
ok how about a simple little regex
that turns those into \underline and \overline?

$\underline{\overline{x}}$
$\underoverline{x}$
$\_x$
$\^x$
$a ^ b$

<pre>

</pre>


<hr> <!--============================================================-->
Visualizing an infinite spiral
to try to prove the every-lagoon-has-at-least-two-good-exits conjecture.
<p>
Priscilla and Dudley take a walk counterclockwise
all the way around the primal and dual perimeter respectively,
in such a way that whenever Priscilla is moving along an edge of the primal,
Dudley is stopped at the corresponding vertex of the dual,
and when Dudley is moving along an edge of the dual,
Priscilla is stopped at the corresponding vertex of the primal.
Exactly one of Priscilla and Dudley are moving at any particular time.
<p>
Denote Priscilla's and Dudley's positions,
in rectangular and polar coordinates,
by the following, all continuous functions of time $t$:
    $$rp,tp, xp, yp$$
    $$rd,td, xd, yd$$
<p>
    $$xp = rp \cos(tp)  yp = rp \sin(tp)$$
    $$xd = rd \cos(td)  yd = rd \sin(td)$$
<p>
Priscilla's and Dudley's paces are such that the one who's moving
always does so at unit rotation speed around the origin
while the other stays still.
So their positions are continuous piecewise differentiable functions of time,
with 
    $$(d tp + d td) / dt = 1 \;  \text{wherever both are differentiable.}$$
<p>
Since the combined rotational speed is 1 and the combined rotational distance is
$4 \pi$,
it will take
$4 \pi$
units of time for Priscilla and Dudley
to complete one revolution and arrive back at their starting configuration;
if we fix Priscilla's starting point
$ \langle xp,yp \rangle (t=0)$
in the interior (not endpoint) of some primal side, this forces Dudley
to start at the dual vertex
$ \langle xd,yd \rangle (t=0)$
corresponding to that initial primal edge,
and the entire walk is thus determined.
They will arrive back at
$ \langle xp,yp\rangle,\langle xd,yd\rangle $ at time
$t = 4 \pi$.
<p>
Priscilla and Dudley's walk is defined (modulo the choice of starting point)
no matter what the polygon.
Let's apply it to the case of interest: a polygon
with only one good lagoon exit.
(We'll end up with a contradiction,
showing that, in fact, no single-exit single-polygon lagoon exists.)
<p>
Since the primal polygon is bounded by straight lines,
points on the boundary at local maximum and local minimum distance
from the polygon's cc are isolated,
and they alternate, with exactly the same number of local maxima
as local minima.
Furthermore by assumption there's exactly one local maximum
(at some farthest vertex);
therefore there's exactly one local minumum
(somewhere along the nearest side, *not* at a vertex),
which is therefore the unique global minimum.
We'll work in a coordinate system such that the cc
is at the origin
$\langle 0,0 \rangle$,
and the nearest point on the perimeter
is one unit below it, at
$\langle 0,-1\rangle$.
For the dual (at unrelated scale),
place the central vertex at the origin.
Then the dual edge corresponding to the primal edge closest to the origin
in primal space starts at the origin in dual space
and lies along the
$-y$
axis;
choose a scale so that it ends at
$\langle 0,-1\rangle$.
Having chosen the position and scale of the dual,
the entire dual diagram (triangle complex) is thus determined.
It consists of
$n$
triangles, each having one vertex at the origin.
<p>
We'll number the primal features in CCW order:
primal edges have even indices and primal vertices have odd indices:
\begin{align}
            e_0 = & \text{the bottom horizontal edge passing through $\langle 0,-1 \rangle$} \\
            v_1 = & \text{right endpoint of $e_0$} \\
            e_2 = & \text{next edge CCW} \\
            v_3 = & \text{next vertex CCW} \\
                ... & \\
    e_{2 n - 2} = & \text{edge CW from e_0} \\
    v_{2 n - 1} = & \text{left endpoint of e_0} \\
\end{align}
<p>
Let
$m$
be the (odd) index of the vertex
that is the global maximum distance from the origin
of the entire primal polygon perimeter.
So
$vm$
is the only good exit,
and distance-from=origin is strictly increasing
from
$\langle 0,-1\rangle$
around CCW to vm,
and then strictly decreasing from vm
back around CCW to
$\langle 0,-1\rangle$.
<p>
Consider the directions of the "quill" emanating
from each vertex of this primal polygon.
Since
$vm$
is the only good exit,
every quill *except* the one at
$vm$
points more towards the origin than away from it
(more precisely, the quill
$i$'s direction's dot product with
$v_i$ is
$\lt 0$), so it can't point directly out from the origin,
it must lean
$\gt 90$
degrees from that, CW or CCW.
For
$v_i$
with
$i \lt m$,
distance from origin to perimeter is increasing,
so the quill at
$v_i$
can't lean CCW
(or it would point into the polygon's interior)
so it must lean at least
$90^{\circ}$
CW from straight out.
Similarly for
$v_i$
with
$i>m$,
the quill at
$v_i$
must lean at least
$90^{\circ}$
CCW from straight out.
<p>
There is no apparent contradiction in anything described so far;
some plausible examples are shown in Figures 1(a-e).
<p>
<pre class="asciiprevis">
Figure 1(a): 212
                       |  
                       *v5
                      / \
                     /   \
                    /e6 e4\
                   /       \
                v7*         *v3
                 / \e8   e2/ \
                    \  e0 /  
                   v9*---*v1
                      \ /
    On paper, I seemed to think the following was nice:
         .....|.....
         .....*.....
         ...........
         ...........
         ..../.\....
         ...........
         ...........
         ...*...*...
         ...........
         ../.*-*.\..
         ...........
         ...........
         .....X.....
    But the dual gets kind of extreme.
    Maybe the following is nicer (hexagon angles):
    In ShephardsPlayApplet:
         nVirtual=6
         1,1 1/1
         1,1 1/1
         and tweak the primal upwards on plane
         so that spiral becomes proper with respect to origin
         (maybe tweak by exactly half of dual edge)
    I'll enter it the simple way here,
    and then get ShephardsPlayApplet to spit out
    better coords.
</pre>
<p>
Figure 1(a): 2 exits tilted too far CW, 1 good exit, 2 exits tilted too far CCW
<svg xmlns="http://www.w3.org/2000/svg"
     version="1.1"
     height="360"
     >
    <!-- 1 unit = 20 pixels -->
    <g transform="translate(180,180) scale(30)">
        <!-- Q: how to scale the coords but not the stroke width??? -->
        <!-- A: supposedly non-scaling-stroke was introduced in SVG Tiny 1.2, not sure if that's what's being used or what -->
        <path
            id="fig1apath"
            vector-effect="non-scaling-stroke"
            style="stroke: blue; stroke-width: 2.0; fill: none"
            d="
                M 1 4
                L 2 2
                L 0 -4
                L -2 2
                L -1 4
                L 1 4

                M 1 4
                l -.5 1.5

                M 2 2
                l 1 2

                M 0 -4
                l 0 -2

                M -2 2
                l -1 2

                M -1 4
                l .5 1.5
            "
        />
        <!-- final local scale must undo effect of global scale! otherwise we get wrong sized text -->
        <g transform="translate(0,4)   scale(.033333) translate(-7.5,-5) "> <text>e0</text> </g>
        <g transform="translate(1,4)   scale(.033333) translate(5,5) "> <text>v1</text> </g>
        <g transform="translate(1.5,3)   scale(.033333) translate(-20,5) "> <text>e2</text> </g>
        <g transform="translate(2,2)  scale(.033333) translate(5,0) "> <text>v3</text> </g>
        <g transform="translate(1,-1)  scale(.033333) translate(-15,20) "> <text>e4</text> </g>
        <g transform="translate(0,-4)  scale(.033333) translate(5,0) "> <text>v5</text> </g>
        <g transform="translate(-1,-1)  scale(.033333) translate(0,20) "> <text>e6</text> </g>
        <g transform="translate(-2,2) scale(.033333) translate(-20,0) "> <text>v7</text> </g>
        <g transform="translate(-1.5,3) scale(.033333) translate(5,5) "> <text>e8</text> </g>
        <g transform="translate(-1,4)  scale(.033333) translate(-20,5) "> <text>v9</text> </g>
    </g>
</svg>

<pre class="asciiprevis">
Figure 1(b): 211
                    \
                     *v5
                     | \_
                     |   \e4
                     |     \_
                   e6|       *v3
                     |       | \
                     |       |  
                     |       |
                     |       |e2
                     |       |
                     |       |
                     |       |
                   v7*---+---*v1
                     |   e0  |
        (XXX Need to tweak it a bit from this to give quills slop)
        or maybe:
                    \
                     |
                     *v5
                     |\
                     | \
                     |  \
                     |   \e4
                     |    \
                     |     \
                     |      \
                   e6|       *v3
                     |       |  \
                     |       |e2
                     |       |
                   v7*---+---*v1
                     |   e0  |

        In ShephardsPlayApplet:
            nVirtual=5
                0,1 1/1
                1,1 1/1

            \
             *
              \
               \
              \ \
                 \
                  \
               \   \
                    \
                     \
                \     \
                       \
                        \
                 \       \
                          \
                           \
                  \         *


                   \       / \


                    \     /   \


                     *---*


                      \ /
</pre>
Figure 1(b): 2 exits tilted too far CW, 1 good exit, 1 exit tilted too far CW
<svg xmlns="http://www.w3.org/2000/svg"
     version="1.1"
     height="320"
     >
    <!-- 1 unit = 20 pixels -->
    <g transform="translate(160,160) scale(30)">
        <!-- Q: how to scale the coords but not the stroke width??? -->
        <!-- A: supposedly non-scaling-stroke was introduced in SVG Tiny 1.2, not sure if that's what's being used or what -->
        <path
            id="fig1bpath"
            vector-effect="non-scaling-stroke"
            style="stroke: blue; stroke-width: 2.0; fill: none"
            d="
                M 1 3.5
                L 2 .5
                L -2.5 -4
                L 0 3.5
                L 1 3.5

                M 1 3.5
                l -.25 1

                M 2 .5
                l 1 .5

                M -2.5 -4
                l -.75 -1

                M 0 3.5
                l .25 1
            "
        />
        <!-- final local scale must undo effect of global scale! otherwise we get wrong sized text -->
        <g transform="translate(.5,3.5)     scale(.033333) translate(-5,-5) "> <text>e0</text> </g>
        <g transform="translate(1,3.5)      scale(.033333) translate(5,5) "> <text>v1</text> </g>
        <g transform="translate(1.5,2)      scale(.033333) translate(-20,0) "> <text>e2</text> </g>
        <g transform="translate(2,.5)       scale(.033333) translate(0,-5) "> <text>v3</text> </g>
        <g transform="translate(0,-1.75)    scale(.033333) translate(0,0) "> <text>e4</text> </g>
        <g transform="translate(-2.5,-4)    scale(.033333) translate(2.5,-2.5) "> <text>v5</text> </g>
        <g transform="translate(-1.25,-.25) scale(.033333) translate(5,0) "> <text>e6</text> </g>
        <g transform="translate(0,3.5)      scale(.033333) translate(-20,5) "> <text>v7</text> </g>
        <!-- final local scale must undo effect of global scale! otherwise we get wrong sized text -->
    </g>
</svg>
<p>
Figure 1(c): 3 exits tilted too far CW, 1 good exit
<pre class="asciiprevis">
Figure 1(c): 310

                         __/
                      __/
                   __*v5
                __/   \
           e6__/       \
          __/           \
                         \e4
                          \
                           \
                            \
                             *v3
                             | \
            __/              |e2
         __/                 |
      v7*---- ... -------+---*v1
 ___/                    e0  |
/
        In ShephardsPlayApplet:
            nVirtual=5  (good for just primal... although primal/dual equalized at about 5.75 or so)
                0,1 1/1
                1,2 1/1
</pre>
<svg xmlns="http://www.w3.org/2000/svg"
     version="1.1"
     height="190"
     >
    <!-- 1 unit = 20 pixels -->
    <g transform="translate(250,95) scale(10)">
        <!-- Q: how to scale the coords but not the stroke width??? -->
        <!-- A: supposedly non-scaling-stroke was introduced in SVG Tiny 1.2, not sure if that's what's being used or what -->
        <path
            id="fig1cpath"
            vector-effect="non-scaling-stroke"
            style="stroke: blue; stroke-width: 2.0; fill: none"
            d="
                M 14 7.5
                L 15 4.5
                L 0 -7.5
                L -18.75 7.5
                L 14 7.5

                M 14 7.5
                l -.25 2

                M 15 4.5
                l 2 1

                M 0 -7.5
                l 1.5,-1.5

                M -18.75 7.5
                l -3 1.5
            "
        />
        <!-- final local scale must undo effect of global scale! otherwise we get wrong sized text -->
        <g transform="translate(-2,7.5)     scale(.1) translate(0,-5) "> <text>e0</text> </g>
        <g transform="translate(14,7.5)     scale(.1) translate(5,5) "> <text>v1</text> </g>
        <g transform="translate(14.5,6)     scale(.1) translate(-17.5,0) "> <text>e2</text> </g>
        <g transform="translate(15,4.5)     scale(.1) translate(0,-5) "> <text>v3</text> </g>
        <g transform="translate(7.5,-1.5)    scale(.1) translate(-20,10) "> <text>e4</text> </g>
        <g transform="translate(0,-7.5)     scale(.1) translate(-15,-5) "> <text>v5</text> </g>
        <g transform="translate(-9,0)       scale(.1) translate(15,-5) "> <text>e6</text> </g>
        <g transform="translate(-18.75,7.5) scale(.1) translate(-10,-5) "> <text>v7</text> </g>
        <!-- final local scale must undo effect of global scale! otherwise we get wrong sized text -->
    </g>
</svg>
<p>
    Figure 1(d): mild spiral
<p>
    Figure 1(e): steep spiral
<p>
These examples satisfy all the properties
of a single-exit single-polygon lagoon with the cc at the origin,
*except* that when we actually compute the cc,
we'll find it is not at the origin.
We now show that every attempt at a single-exit single-polygon lagoon
is doomed in this way--
that is, given any candidate primal polygon
and a point in its interior such that there is only one good exit
with respect to that point,
that point is *not* the cc of the lagoon.
<p>
So, assume we are given such a candidate primal polygon,
and a point in its interior such that there is only one good exit
with respect to that point.
Choose a coordinate system that places that point at the origin,
with the polygon rotated so that
$vm$
(the "apex")
has highest y coordinate,
and
$\text{slope}(e_{m-1}) = -\text{slope}(e_{m+1})$.
So
$v_{m-2}$
is to the lower-right of
$vm$
and
$v_{m+2}$
is to the lower-left of
$vm$.
$e_0$
will always be the single edge closest to the origin (though
it need not be horizontal any more).
Figure 2(a-e) shows the same polygons as Figure 1(a-e),
rotated in this way.
<p>
We will now show that, in this chosen coordinate system,
the cc's y coordinate is strictly positive,
and so the origin is not the cc.
<p>
Let
$l$
be the lowest-numbered (most CW) index such that
$v_{l+2}$'s
$x$
coord
is
$\leq$
that of
$v_l$'s
(i.e. such that
e_{l+1}
emerges north or northwest out of
$v_l$).
Let
$r$
be the highest-numbered (most CCW) index such that
$v_{r-1}$'s
$x$
coord is
$\ge$
that of
$v_r$'s.
<p>
Since
$e_{l+1}$
emerges north or northwest from
$v_l$
and the quill at
$v_l$
leans CW by more than
$90^{\circ}$
from outward,
it must be that
$v_l$
has positive
$y$
coord
(otherwise the angle formed by the quill and
$e_{l+1}$
would be greater than
$180^{\circ}$,
which is illegal).
Similarly
$v_r$
has positive
$y$
coord,
and similarly all vertices between them,
$v_{l+2}, ..., v_{r-2}$
have positive
$y$
coord as well.
<p>
The crux of this proof is to show that the cc of all the vertices
$v_1..v_r$
has positive
$y$
coord, or equivalently,
that their moment (cc times total curvature) has positive
$y$
coord.
<p>
Then by symmetric reasoning,
the cc (or equivalently the moment) of
$v_l..v{2n-1}$
also has positive
$y$
coord;
furthermore as previously mentioned, each of the vertices
$v_{l+2}..v_{r-2}$
has positive
$y$
coord as well, so:
\begin{align}
    \text{moment}(v_1..v_{2n-1}) = & \text{moment}(v_1..v_l) \\
                                 + & \text{moment}(v_{l+2}..v_{r-2}) \\
                                 + & \text{moment}(v_r..v_{2n-1})
\end{align}
being the sum of three quantities each with positive y coord,
has positive y coord as well, and we are done.
<p>
So, we just need to show that the moment
of the initial vertices
$v_1..v_l$
has positive
$y$
coord.
<p>
We let Priscilla and Dudley compute the moment
by doing their walk around the primal and dual.
Priscilla starts anywhere in the interior of edge
$e_0$
and ends anywhere in the interior of edge
$e_{l+1}$.
Dudley starts and ends at the respective dual vertices.
(XXX maybe call them $v'_0$ and $v'_{l+1}$? yes I think so)
<p>
We consider an "event"
to be a moment during the walk
in which one or more of the following happen:
<ul>
    <li> Priscilla stops moving and Dudley starts moving
         (the first event is of this type)
    <li> Dudley stops moving and Priscilla starts moving
    <li> Dudley crosses the $x$ axis,
         from negative to positive $y$ coordinate
         (this will be a separate event
         iff no dual vertex lies on the $x$ axis).
</ul>
<p>
The accumulated moment vector starts as zero;
at each event at which Dudley has been moving,
Dudley computes the area of the triangle formed by
his previous event position, his current position, and the origin,
and adds
    $$(\text{Dudley's triangle area})*(\text{Priscilla's position})$$
to the moment vector being accumulated.
<p>
We'll prove the desired result
(that the moment of
$v_1..v_l$
has positive
$y$
coord)
by inductively proving that a stronger statement holds
at each moment in Priscilla and Dudley's walk.
The desired result follows from the following Lemma's
statement (B) at the end of the walk.
XXX why? need to be more specific
<p>
Lemma:
During Priscilla and Dudley walk around the primal (from
$e_0$
to
$e_{l+1}$)
and dual
as described above, at all times strictly after the first event:
<!-- the unnecessary curly braces are simply from copying this section over
from the corresponding "\underline" section and removing the "\underline"s -->
\begin{alignat*}{3}
    & ({A}) \;\;  &  0                   &  &  & \lt {rm} \lt {rp} \, {rd}^2 \sin({tp}-{td}) \cos({tp}-{td}) / 2 \\
    & ({B}) \;\;  & {td} &  &  & \lt  {tm} \\
    & ({C}) \;\;  &                      &  &  & \leq {tp} \\
    & ({D}) \;\;  &                      &  &  & \lt {td}+\pi/2.
\end{alignat*}
<p>
Proof:
<p>
Note first of all the significance of the "after the first event"
in the Lemma statement.
This clause is necessary because,
up to and including the first event
(Priscilla stopping at
$v_1$
and Dudley starting moving),
$rm = |m| = 0$,
and so (A) doesn't hold
(and (B),(C) don't even make sense since
$tm$
isn't even defined).
<p>
(XXX this can be moved out of the lemma and proof, it can just be an observation earlier)
In any of Priscilla and Dudley's walks,
convexity of the primal polygon and the fact that it contains the origin
in its interior implies that, at all times,
Priscilla's position vector and her outward normal (right) vector
are strictly within
$90^{\circ}$
of each other.
In other words (since Priscilla's outward normal vector
is in the direction of Dudley's position vector, by definition)
    $$(1) \;\; td \lt tp \lt td+\pi/2,$$
so (D) is always satisfied during any walk on any primal polygon
containing the origin.  (XXX wait, that's not true! argh! need to adjust this... say a true statement, and I think the only reason $td \lt tp$ is that we're in this spiral situation)
We prove the other parts, (A),(B),(C) by induction on the number of events
(as defined earlier) encountered so far.
<p>
The base case will be the case when
the number of *previous* events encountered is
1.
(This includes all times strictly after the first event
up to and including the second event.)
That is, Priscilla has stopped moving at
$v_1$
(that was the first event)
and Dudley has been moving along the corresponding edge
$e'_1$
in the dual diagram.
At this time, the moment accumulated so far is
    $$(2) \;\;  m = (\text{Dudley's triangle area so far})*(\text{Priscilla's position})$$
which is a nonzero scalar times the nonzero vector
$p=v_1$,
so
$rm = |m| \gt 0$
(so the first part of (A) is satisfied, and
$tm$
is well-defined),
and
$tm = tp$.
Combining this with (1), we have:
    $$td \lt tm = tp \lt td+\pi/2$$
and so (B),(C),(D) are satisfied.
We still have to prove that the second part of (A) holds in the base case.
<p>
For this base case,
we temporarily rotate the entire picture
so that Priscilla's position
$p$
is on the
$+y$
axis,
and so Dudley is traveling upwards along the now-vertical dual edge
$e'_1$,
as shown in Figure 3.
Note that this temporary rotation of the picture
does not change the truth or falsity of (A) that we are trying to prove,
since all of the quantities
$rm$,
$rp$,
$rd$,
$tp-td$
are invariant under this rotation
(even though
$tp$
and
$td$
have changed-- specifically,
$tp$
is now
$\pi/2$).
(XXX Alternatively, could denote these rotated coords by carat'ing them)
<pre>
      Priscilla
       p=v_1*
            :       *v'_2
            :       |
            :     / |
            :       |e'_1
            :    /  |
            :       |  Dudley    ^
            :   /   *d=[xd,yd] |
            :      /|            |
            :  /  / | 
            :    /  |  
            : / /  _*v'_0
            :  / _/ :
            ://_/   :
            ://     :
           0*.......* [xd,0]

        Fig. 3: base case in temporarily rotated coord system
</pre>
We can get an upper bound on the area of Dudley's triangle so far,
as follows:
\begin{align}
    & \text{Dudley's triangle area so far} \\
    & \;\; = \text{area}(\triangle(0,v'_0,d)) \\
    & \;\; &lt; \text{area}(\triangle(0,\langle xd,0\rangle,d)) \;\; \text{since the former triangle is included in the latter, since v'_0 has y coord &gt; 0 (XXX prove this!)} \\
    & \;\; = xd yd / 2 \\
    & \;\; = (rd \cos(td)) (rd \sin(td)) / 2\\
    & \;\; = (rd \sin(\pi/2-td)) (rd \cos(\pi/2-td)) / 2\\
(3) & \;\; = rd^2 \sin(\pi/2-td) \cos(\pi/2-td) / 2
\end{align}
<p>
Recalling (2),
\begin{align}
     m &amp;= (\text{Dudley's triangle area so far})*(\text{Priscilla's position}) \\
       &amp;= (\text{Dudley's triangle area so far})*p
\end{align}
Taking magnitude of both sides,
\begin{align}
   rm &amp; = (\text{Dudley's triangle area so far}) * rp \\
       &amp; &lt; (rd^2 \sin(\pi/2-td) \cos(\pi/2-td) / 2 ) * rp  \;\; by (3) \\
       &amp; = rp rd^2 \sin(\pi/2-td) \cos(\pi/2-td) / 2 \\
       &amp; = rp rd^2 \sin(tp-td) \cos(tp-td) / 2
\end{align}
and so we've shown the second part of (A),
completing the proof of the base case.
<p>

For the inductive step,
we will show that, given two times
$\underline{t} \lt \overline{t}$
during the walk,
if only Priscilla moves or only Dudley moves during the that time interval,
and if the Lemma holds at $\underline{t}$, then it also holds at $\overline{t}$.
Since the walk leading to any desired target time
can be expressed as a finite number of steps of this form,
this will prove that the Lemma holds at all times.

Using underbars and overbars to denote the respective values
at times $\underline{t}$ and $\overline{t}$,
the inductive hypothesis is that the Lemma holds at $\underline{t}$:
\begin{alignat*}{3}
    & (\underline{A}) \;\;  &  0                   &  &  & \lt \underline{rm} \lt \underline{rp} \, \underline{rd}^2 \sin(\underline{tp}-\underline{td}) \cos(\underline{tp}-\underline{td}) / 2 \\
    & (\underline{B}) \;\;  & \underline{td} &  &  & \lt  \underline{tm} \\
    & (\underline{C}) \;\;  &                      &  &  & \leq \underline{tp} \\
    & (\underline{D}) \;\;  &                      &  &  & \lt \underline{td}+\pi/2.
\end{alignat*}
and, assuming that, we must prove that it holds at $\overline{t}$:
\begin{alignat*}{3}
    & (\overline{A}) \;\;  &  0                   &  &  & \lt \overline{rm} \lt \overline{rp} \, \overline{rd}^2 \sin(\overline{tp}-\overline{td}) \cos(\overline{tp}-\overline{td}) / 2 \\
    & (\overline{B}) \;\;  & \overline{td} &  &  & \lt  \overline{tm} \\
    & (\overline{C}) \;\;  &                      &  &  & \leq \overline{tp} \\
    & (\overline{D}) \;\;  &                      &  &  & \lt \overline{td}+\pi/2.
\end{alignat*}

and, assuming that, we must prove that it holds at $\overline{t}$:
    $$(\overline{A}) \;\;  0                   \lt \overline{rm} \lt \overline{rp} \, \overline{rd}^2 \sin(\overline{tp}-\overline{td}) \cos(\overline{tp}-\overline{td}) / 2 \\$$
\begin{alignat*}{7}
     \overline{td}&  &  & \lt             &  \overline{tm}  &  & \leq            &  \overline{tp}  &  & \lt             &  \overline{td}+\pi/2. \\
                        &  &  & (\overline{B})  &                       &  & (\overline{C})  &                       &  & (\overline{D})  & \\
\end{alignat*}

There are two cases.
<p>
Case 1: In the time from $\underline{t}$ to $\overline{t}$,
Priscilla has moved (in a straight line) and Dudley has stayed still.
<p>
This time we temporarily rotate the picture
so that Dudley's (stationary) position is on the
$+x$
axis,
and so Priscilla has travelled upwards along a now-vertical primal edge,
as shown in Figure 4.
As in the base case, this is simply a change of coordinate system
that does not change the truth or falsity of the Lemma at
$\underline{t}$
or
$\overline{t}$
(even though
$tp$
and
$td$
have changed-- specifically,
$\underline{td}$
and
$\overline{td}$
are now both
$0$).
<pre>
            (The following scale looked nice on paper:)
            ....*
            ....|
            ....|
            ....*
            .....
            .....
            *....
                    *$\overline{p}= \langle \overline{xp},\overline{yp} \rangle$
                    |
                  / |
                    | ^
                 /  | |
                    | | Priscilla walks from $\underline{p}$ to $\overline{p}$
                /   | | (perpendicular to Dudley's stationary position)
                    | |
               /    | 
                    |  
              /     *$\underline{p}=\langle \underline{xp},\underline{yp} \rangle$
                  /  
             /  /    
              /             Dudley
           0*----------------*$\underline{d}=\overline{d}$

        Fig. 4: Inductive step, Case 1: Priscilla has moved
</pre>
In this case we have the following relationships between the previous event's values
and the current values.
Dudley didn't move:
    $$(4) \;\; \overline{rd} = \underline{rd}$$
    $$(5) \;\; \overline{\thetad} = \underline{td} = 0$$
nor did the moment (since the moment only changes when Dudley moves):
    $$(6) \;\; \overline{rm} = \underline{rm}$$
    $$(7) \;\; \overline{tm} = \underline{tm}  \;\; \text{(assuming $\underline{tm}$ is well-defined-- which it is, by inductive hypothesis)}$$
Priscilla moved purely upwards, within the first quadrant: (XXX may need to make very clear why this is true! it follows from B and/or C but it's a bit of a train wreck at the moment :-( )
\begin{align}
             0 & \lt \underline{yp} \lt \overline{yp} \\
    (8) \;\; 0 & \lt \underline{xp} = \overline{xp}
\end{align}
so her angle increased, but stayed less than $\pi/2$:
    $$(9) \;\; 0 \lt \underline{tp} \lt \overline{tp} \lt \pi/2$$
   $$(10) \;\; 0 \lt \sin(\underline{tp}) \lt \sin(\overline{tp}) \lt 1  \;\; \text{(follows from (9) since $\sin$ is increasing in this range)}$$
   $$(11) \;\; 0 \lt \cos(\overline{tp}) \lt \cos(\underline{tp}) \lt 1  \;\; \text{(follows from (9) since $\cos$ is decreasing in this range)}$$
<p>
Proving ($\overline{B}$) is easy:
\begin{align}
    \overline{td} & = \underline{td}  \;\; \text{by (5)} \\
                        & \lt \underline{tm}  \;\; \text{by} (\underline{B}) \\
                        & = \overline{tm}  \;\; \text{by (7).}
\end{align}
Proving ($\overline{C}$) is easy:
\begin{align}
    \overline{tm} & = \underline{tm}  \;\; \text{by (7)} \\
                        & \leq \underline{tp}  \;\; \text{by} (\underline{C}) \\
                        & \lt \overline{tp}  \;\; \text{by (9)}
\end{align}
And (D) is always satisfied (recall it's not part of the induction). (XXX remove it from the inductive hypothesis and inductive step!)
<p>
We must prove ($\overline{A}$).
The first inequality of ($\overline{A}$) is easy:
\begin{align}
    \overline{rm} & = \underline{rm}  \;\; \text{by (6)} \\
                   & \gt 0  \;\; \text{by} (\underline{A})
\end{align}
<p>
Proceeding now to prove the second inequality of ($\overline{A}$):
\begin{align}
    \overline{rm} & = \underline{rm}  \;\; \text{by (6)} \\
                   & \lt \underline{rp} \, \underline{rd}^2 \sin(\underline{tp}-\underline{td}) \cos(\underline{tp}-\underline{td}) / 2  \;\; \text{by} (\underline{A}) \\
                   & = \underline{rp} \, \underline{rd}^2 \sin(\underline{tp}) \cos(\underline{tp}) / 2  \;\; \text{by (5)} \\
                   & = \underline{rp} \, \overline{rd}^2 \sin(\underline{tp}) \cos(\underline{tp}) / 2  \;\; \text{by (4)} \\
                   & = (\underline{rp} \cos(\underline{tp})) \overline{rd}^2 \sin(\underline{tp})/2   \;\; \text{(just rearranging terms)} \\

                   & = \underline{xp} \, \overline{rd}^2 \sin(\underline{tp})/2 \\
                   & = \overline{xp} \, \overline{rd}^2 \sin(\underline{tp})/2   \;\; \text{by (8)} \\
                   & = (\overline{rp} \cos(\overline{tp})) \overline{rd}^2 \sin(\underline{tp})/2 \\
                   & \lt (\overline{rp} \cos(tp)) \overline{rd}^2 \sin(\overline{tp})/2  \;\; \text{by (10), since all factors are positive (by (10) and (11))} \\
                   & = \overline{rp} \, \overline{rd}^2 \sin(\overline{tp}) \cos(\overline{tp}) / 2   \;\; \text{(just rearranging terms)} \\
                   & = \overline{rp} \, \overline{rd}^2 \sin(\overline{tp}-\overline{td}) \cos(\overline{tp}-\overline{td}) / 2  \;\; \text{by (5)}
\end{align}
and so the second inequality of ($\overline{A}$) is proved,
completing Case 1 of the inductive step.
<p>
Case 2: In the time from $\underline{t}$ to $\overline{t}$,
Dudley has moved (in a straight line) and Priscilla has stayed still.
<p>
As in the base case, we work in a rotated coordinate system
in which Priscilla's (stationary) position is on the +y axis,
so Dudley is traveling upwards along a now-vertical dual edge,
as shown in Figure 5.
<pre>
        Priscilla
            *p=[0,_^yp]
            :         _
            :       * d 
            :       |
            :     / |
            :       | ^
            :    /  | |
            :       | | Dudley walks from d_ to ^d^
            :   /   | | (parallel to Priscilla's stationary position)
            :       | |
            :  /    | 
            :       |  
            : /    _* d
            :    _/ : -
            :/ _/   :
            : /     :
           0*.......* [_^xd,0]

        Fig. 5: Inductive step, Case 2: Dudley has moved
</pre>
We denote quantities that are stationary at this step
by giving them both an underbar and overbar.
Priscilla is on the +y axis and didn't move:
\begin{align}
    (11.5)  _^rp = _^yp > 0 \\
            _^xp = 0 \\
    (12)    _^tp = = pi/2 \\
\end{align}
Dudley moved purely upwards, strictly within the first quadrant:
(XXX may need more clarification, just like previous case)
\begin{align}
    (13)    0 < _yd < ^yd \\
            0 < _xd = ^xd = _^xd \\
\end{align}
so his angle increased, but stayed less than pi/2:
\begin{align}
    (14)    0 < td_ < ^td < pi/2 \\
    (15)    0 < sin(_td) < sin(^td) < 1 (follows from (14) since sin is increasing in this range) \\
    (16)    0 < cos(^td) < cos(_td) < 1 (follows from (14) since cos is decreasing in this range) \\
\end{align}

The moment changed as follows:
\begin{align}
         ^m = m + (area of Dudley's triangle) * (Priscilla's position) \\
    (16.5)  = m + (1/2 * (^yd-_yd)*^d_x) * <0,_yp^> \\
\end{align}

Therefore by (12), the moment moved purely upwards as well;
furthermore (B_,C_,D_) say it started strictly inside the first quadrant
so it ended there as well;
so the first part of (A^) is immediately satisfied and:
\begin{align}
    (17)    0 < ym_ < ym^ \\
    (18)    0 < xm_ = xm^ = _^xm \\
    (19)    0 < tm_ < tm^ < pi/2 \\
    (20)    0 < sin(tm_) < sin(tm^) < 1 \\
    (21)    0 < cos(tm^) < cos(tm_) < 1 \\
\end{align}

(C^) follows triviallly:
\begin{align}
            tm^ < pi/2  by (18) \\
                 = tp   by (12) \\
\end{align}
The second part of (A^) is proved as follows:
(want to show rm^ < rp^ rd^ ^2 sin(tp^-td^)cos(tp^-td^)/2)
\begin{align}
    rm^ = |m^| = |m_ + (area of Dudley's triangle) * (Priscilla's position)| \\
               <= |m_| + (area of Dudley's triangle) * |_^p| \\
               = rm_ + (area of Dudley's triangle) * _^rp \\
               < _^rp _rd^2 sin(tp_-td_)cos(tp_-td_)/2 + (area of Dudley's triangle) * _^rp by (A_) \\
               = _^rp ((rd_ sin(tp_-td_))(rd_ cos(tp_-td_))/2 + (area of Dudley's triangle)) \\
               = _^rp (areaTri(0,<_^xd,0>,d_) + areaTri(0,d_,d^)) \\
               = _^rp (areaTri(0,<_^xd,d^))  since this tri is the disjoint union of the previous two tris \\
                  XXX should we be using x's and y's in here somewhere? \\
               = _^rp rd^2 cos(td^)sin(td^) / 2 \\
               = _^rp rd^2 sin(pi/2-td^)cos(pi/2-td^) / 2    since cos(t)=sin(pi/2-t) in general \\
               = _^rp rd^2 sin(_^tp-td^)cos(_^tp-td^) / 2  by (12) \\
\end{align}

Having shown (A^), we must finally prove (B^).

For this, we first derive an intermediate result
from the inductive hypothesis.
The "all terms positive" claims throughout the following
follow from (left side of) (A_), (B_),(C_),(D_).
\begin{align}
         xm_ = rm_ cos(tm_) \\
              = rm_ sin(pi/2 - tm_) \\
     
              = rm_ sin(tp_ - tm_) by (12) \\
              = rm_ sin((tp_-td_)-(tm_-td_)) \\
              = rm_ (sin(tp_-td_)cos(tm_-td_) - cos(tp_-td_)sin(tm_-td_)) by double-angle identity \\
              = rm_ sin(tp_-td_)cos(tm_-td_) - rm_ cos(tp_-td_)sin(tm_-td_) \\
              < rm_ sin(tp_-td_)cos(tm_-td_) - 0  since all terms positive \\
              < rm_ sin(tp_-td_) * 1  since cos(tm_-td_)<1 and all terms positive \\
              < (1/2 rp_ _rd^2 sin(tp_-td_)cos(tp_-td_)) sin(tp_-td_)  by (A_) \\
              = 1/2 rp_ cos(tp_-td_) (rd_ sin(tp_-td_))^2 \\
              < 1/2 rp_ (rd_ sin(tp_-td_))^2  since 0 < cos(tp_-td_) < 1 \\
     
              = 1/2 rp_ (rd_ sin(pi/2-td_))^2  by (12) \\
              = 1/2 rp_ (rd_ cos(td_))^2 \\
              = 1/2 rp_ _xd^2 \\
    (22) xm_ < 1/2 rp_ _xd^2. \\
\end{align}
(XXX could phrase that in terms "m x p < 1/2 (d x p)^2",
coordinate-free til the last second, if we wanted... maybe)

Now we proceed to prove (B^).
Since d^,m^,d_,m_ are all in the first quadrant,
our goal (B^) can be expressed as
    (B'^)  d^ X m^ > 0
and assumption (B_) can be expressed as
    (B'_)  d_ X m_ > 0
(where X denotes the scalar cross product
of two vectors in the plane, i.e.  
v0 X v1 = |v0| |v1| sin(angle(v0,v1))).

<span id="youarehere"></span>
So we just need to prove (B'^) and we're done.
\begin{align}
    d^ X m^ = <_^xd,yd^> X <_^xm,ym^> \\
            = _^xd ym^  -  yd^ _^xm \\
            = _^xd (ym_ + 1/2 (yd^-yd_) _^xd _^yp) - yd^ _^xm  by (16.5)  (XXX neaten that up) \\
            = _^xd (ym_ + 1/2 (yd^-yd_) _^xd _^yp) - (yd_ + (yd^-yd_)) _^xm \\
            = (_^xd ym_ - yd_ _^xm) + (yd^-yd_) (1/2 _^xd ^2 _^yp - _^xm)  (just rearranged terms) \\
            =          d_ X m_          + (yd^-yd_) (1/2 _^xd ^2 _^yp - _^xm) \\
            \gt             0             + (yd^-yd_) (1/2 _^xd ^2 _^yp - _^xm)  by (B_) \\
            = (yd^-yd_) (1/2 _^xd ^2 _^yp - _^xm) \\
            = (yd^-yd_) (1/2 _^xd ^2 _^rp - _^xm) by (11.5) \\

            \gt 0, by (13) and (22). \\
\end{align}
So (B'^) is proved, completing the induction
and the proof of the Lemma.

<p>

<hr> <!--============================================================-->
<p>
    <!-- XXX hey dammit, where's the icon for the html5 check? can't seem to get to it since it's using an experimental feature? -->


    <!-- it would be cool to make some javascript to do the following:
         if current url starts with "file", use "http://validator.w3.org/#validate_by_upload"
         if current url starts with "http", use "http://validator.w3.org/check?uri=referer"
                                                "http://jigsaw.w3.org/check/referer"
         and maybe even fill in the starting file if possible? -->

    <a href="http://validator.w3.org/unicorn/#validate-by-upload">
        <img style="border:0;width:88px;height:31px"
            src="http://jigsaw.w3.org/css-validator/images/vcss"
            alt="Valid!" />
    </a>
    <a href="http://validator.w3.org/#validate_by_upload">
        <img style="border:0;width:88px;height:31px"
            src="http://jigsaw.w3.org/css-validator/images/vcss"
            alt="Valid!" />
    </a>
    <a href="http://jigsaw.w3.org/css-validator/#validate_by_upload">
        <img style="border:0;width:88px;height:31px"
            src="http://jigsaw.w3.org/css-validator/images/vcss-blue"
            alt="Valid CSS!" />
    </a>
</p>
<hr> <!--============================================================-->


<pre>
Possible rewording?  Not sure.
It might make some things simpler, e.g. wouldn't 
have to worry about whether the angles are defined
Lemma:  Given a polygon as previously described,
for each odd i in {1,3,...l},
    XXX MAYBE, but different language
    (C) moment(v_1..v_i) dot (v_{i+2}-v_i) \gt 0
    (A) ||moment(v_1..v_i)|| \langle ||v_i|| {rd}^2 \sin(tp-td)     XXX how the fuck did rd get in here?
    (B) d^perpdot dot moment{v_1..v_i} \gt 0                              XXX how the fuck did d get in here?  actually need to talk about constructing the dual I think?
</pre>



</body>
</html>

