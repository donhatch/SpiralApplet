/*
    Notes:
        Uses System.nanoTime which requires java >= 1.4

    BUG: Time quanta per part doesn't take effect til animation stopped and restarted
    BUG: on assert fail in paint, displayed line number is too small by a few lines
    BUG: bad ticker anim when pixelsPerIncr = 4
    BUG: ending criteria isn't quite right-- should end when *all* contributing things have gone off screen or become tiny, need to clean up logic for that
    BUG: as soon as a tooltip is shown, performance went down, forevermore??
    TODO: smooth out animation when going very slowly
    TODO: gui for scale
    todo: check out LWJGL for consistent frame rate?
    TODO: maybe JavaFX? she says it works well for vsync: http://www.java-gaming.org/index.php?topic=27763.0.  ah good, it's included in jdk 7.
    TODO: use javax.swing.Timer instead of my own custom thread
          WHOA! as soon as I switched to a timer, I'm getting consistent timings! nice 60fps. wtf?
          well except every 5 seconds or so, it gives far faster for a few frames in a row. argh!
          sleeping for 11 ms seems to be a sweet spot.  screwy.
          and a few days later, it's not happening any more... it's going full speed again, even with the timer.  wtf??
          but then a few minutes later, it's throttled again.  weird weird weird.
          actually maybe when non-throttled, I'd been running it for a while?
    TODO: allow saving/restoring window positions, but in a discoverable non-evil way
*/

#include "macros.h"

// So can compile in pre-1.4,
// we use these instead of java.awt.event.MouseEvent.BUTTON1 etc.
#define java_awt_event_MouseEvent_BUTTON1 1
#define java_awt_event_MouseEvent_BUTTON2 2
#define java_awt_event_MouseEvent_BUTTON3 3

//import com.donhatchsw.util.Arrays;
import com.donhatchsw.util.MyMath;
import com.donhatchsw.util.VecMath;
//import com.donhatchsw.util.SortStuff;
import com.donhatchsw.util.Listenable;
import com.donhatchsw.compat.ArrayList;
//import com.donhatchsw.compat.IntArrayList;
//import com.donhatchsw.compat.DoubleArrayList;

import com.donhatchsw.awt.ColLayout;
import com.donhatchsw.awt.JRow;
import com.donhatchsw.awt.JCol;
import com.donhatchsw.awt.JTablePanel;

import javax.swing.ButtonGroup;
import javax.swing.JFrame;
import javax.swing.JPanel;
import javax.swing.JApplet;
import javax.swing.JLabel;
import javax.swing.JButton;
import javax.swing.JRadioButton;
import javax.swing.text.JTextComponent;
import javax.swing.JTextField;
import javax.swing.JTextArea;
import javax.swing.JToggleButton;
import javax.swing.JScrollPane;
import javax.swing.JSeparator;
import javax.swing.JSlider;
import javax.swing.JMenuBar;
import javax.swing.JMenu;
import javax.swing.JMenuItem;
//import javax.swing.JComboBox;
import javax.swing.JCheckBox;


public class SpiralApplet
    extends JApplet
{
    //
    // Utilities for applet stuff...
    //
        private String getParameterString(String paramName,
                                       String defaultValue)
        {
            String paramValueString = getParameter(paramName);
            if (paramValueString != null)
                return paramValueString;
            else
                return defaultValue;
        }
        private int getParameterInt(String paramName,
                                    int defaultValue)
        {
            String paramValueString = getParameter(paramName);
            if (paramValueString != null)
            {
                try
                {
                    return Integer.decode(paramValueString).intValue();
                }
                catch (NumberFormatException e)
                {
                    return 0;
                }
            }
            else
                return defaultValue;
        }
        private double getParameterDouble(String paramName,
                                          double defaultValue)
        {
            String paramValueString = getParameter(paramName);
            if (paramValueString != null)
            {
                try
                {
                    return Double.parseDouble(paramValueString);
                }
                catch (NumberFormatException e)
                {
                    return 0;
                }
            }
            else
                return defaultValue;
        }
        private boolean getParameterBoolean(String paramName,
                                            boolean defaultValue)
        {
            String paramValueString = getParameter(paramName);
            if (paramValueString != null)
            {
                // Too simplistic, only honors case-sensitive "true"
                //return Boolean.valueOf(paramValueString).booleanValue();

                try
                {
                    int n = Integer.decode(paramValueString).intValue();
                    return n != 0;
                }
                catch (NumberFormatException e)
                {
                    if (paramValueString.equalsIgnoreCase("true")
                     || paramValueString.equalsIgnoreCase("yes")
                     || paramValueString.equalsIgnoreCase("t")
                     || paramValueString.equalsIgnoreCase("y"))
                        return true;
                    return false;
                }
            }
            else
                return defaultValue;
        }

        // ButtonGroup doesn't support *at most* one checked.
        // Implement one that does.
        private static class ButtonGroupThatAllowsNone
        {
            private ArrayList buttons = new ArrayList();
            private ArrayList actionListeners = new ArrayList();
            public void add(final JToggleButton button) // checkbox or radio button
            {
                java.awt.event.ActionListener actionListener = new java.awt.event.ActionListener() {
                    public void actionPerformed(java.awt.event.ActionEvent e)
                    {
                        if (button.isSelected())
                        {
                            // then deselect everyone else
                            int nButtons = buttons.size();
                            for (int i = 0; i < nButtons; ++i)
                            {
                                JToggleButton otherButton = (JToggleButton)buttons.get(i);
                                if (otherButton != button)
                                    if (otherButton.isSelected())
                                        otherButton.setSelected(false);
                            }
                        }
                    }
                };
                button.addActionListener(actionListener);
                buttons.add(button);
                actionListeners.add(actionListener);
            }
        }; // class ButtonGroupThatAllowsNone
        // That was fun, let's make another that enforces
        // that the selection is a prefix of the set of buttons.
        private static class PrefixButtonGroup
        {
            private ArrayList buttons = new ArrayList();
            private ArrayList actionListeners = new ArrayList();
            public void add(final JToggleButton button) // checkbox or radio button
            {
                java.awt.event.ActionListener actionListener = new java.awt.event.ActionListener() {
                    public void actionPerformed(java.awt.event.ActionEvent e)
                    {
                        int nButtons = buttons.size();
                        if (button.isSelected())
                        {
                            // then select everyone before me
                            FORI (i, nButtons)
                            {
                                JToggleButton otherButton = (JToggleButton)buttons.get(i);
                                if (otherButton == button)
                                    break;
                                if (!otherButton.isSelected())
                                    otherButton.setSelected(true);
                            }
                        }
                        else
                        {
                            // deselect everyone after me
                            FORIDOWN(i, nButtons)
                            {
                                JToggleButton otherButton = (JToggleButton)buttons.get(i);
                                if (otherButton == button)
                                    break;
                                if (otherButton.isSelected())
                                    otherButton.setSelected(false);
                            }
                        }
                    }
                };
                button.addActionListener(actionListener);
                buttons.add(button);
                actionListeners.add(actionListener);
            }
        } // PrefixButtonGroup

        // http://tech-eureka.blogspot.com/2010/12/how-to-implement-repeating-swing.html
        private static class JRepeatingButton extends JButton
        {
            public JRepeatingButton(String text)
            {
                super(text);
            }
            public void addActionListener(final java.awt.event.ActionListener actionListener)
            {
                addMouseListener(new java.awt.event.MouseAdapter() {
                    private javax.swing.Timer repeatTimer = null;
                    private java.awt.event.ActionEvent synthesizedActionEvent = null;
                    public void mousePressed(java.awt.event.MouseEvent mouseEvent)
                    {
                        synthesizedActionEvent = new java.awt.event.ActionEvent(
                            JRepeatingButton.this,
                            java.awt.event.ActionEvent.ACTION_PERFORMED,
                            JRepeatingButton.this.getText(),
                            mouseEvent.getModifiers());
                        // the ctor that takes "when" introduced some time in (1.3, 1.6]
                        // so don't use it, so we can compile using 1.3
                        actionListener.actionPerformed(synthesizedActionEvent); // initial execution

                        repeatTimer = new javax.swing.Timer(100, new java.awt.event.ActionListener() {
                            public void actionPerformed(java.awt.event.ActionEvent timerActionEvent)
                            {
                                actionListener.actionPerformed(synthesizedActionEvent);
                            }
                        });
                        repeatTimer.setInitialDelay(500);
                        repeatTimer.start();
                    }
                    public void mouseReleased(java.awt.event.MouseEvent arg0)
                    {
                        repeatTimer.stop();
                        repeatTimer = null;
                        synthesizedActionEvent = null;
                    }
                });
            }
        } // JRepeatingButton

        // A textfield that turns green or red when editing and not yet committed.
        // Esc reverts.
        private static class JValidatingTextField extends JTextField
        {
            // subclass can override this
            public boolean validate(String text)
            {
                return true; // it's all good by default
            }

            private String committedText;
            public JValidatingTextField(String text)
            {
                super(text);
                committedText = getText();

                getDocument().addDocumentListener(new javax.swing.event.DocumentListener() {
                    private void anyUpdate(javax.swing.event.DocumentEvent e)
                    {
                        if (isEditable()) // use this as hint-- if not editable, probably makeTextComponentLikeLabel was called
                        {
                            if (!getText().equals(committedText)) // TODO: == doesn't work here?  I forget the difference
                            {
                                if (validate(getText()))
                                {
                                    // TODO: if value semantically equals committed value, turn white instead.  hmm, can build this into validate() by having it return a value (Object), maybe?
                                    setBackground(new java.awt.Color(192,255,192)); // light green
                                }
                                else
                                    setBackground(new java.awt.Color(255,192,192)); // pink
                            }
                            else
                                setBackground(java.awt.Color.white);
                        }
                    }
                    public void insertUpdate(javax.swing.event.DocumentEvent e)  {anyUpdate(e);}
                    public void removeUpdate(javax.swing.event.DocumentEvent e)  {anyUpdate(e);}
                    public void changedUpdate(javax.swing.event.DocumentEvent e) {anyUpdate(e);}
                });
                addKeyListener(new java.awt.event.KeyAdapter() {
                    public void keyPressed(java.awt.event.KeyEvent e)
                    {
                        if (e.getKeyCode() == java.awt.event.KeyEvent.VK_ESCAPE)
                        {
                            setText(committedText);
                        }
                    }
                });
                addActionListener(new java.awt.event.ActionListener() {
                    public void actionPerformed(java.awt.event.ActionEvent e)
                    {
                        if (validate(getText()))
                        {
                            committedText = getText();
                            setBackground(java.awt.Color.white);
                        }
                    }
                });
            }
            public void setText(String text)
            {
                super.setText(text);
                if (isEditable()) // use this as hint-- if not editable, probably makeTextComponentLikeLabel was called
                {
                    if (validate(getText()))
                    {
                        committedText = getText();
                        setBackground(java.awt.Color.white);
                    }
                }
            }
        } // JValidatingTextField


        private static class SpiralAppletControlPanel
            extends JPanel
        {
            public SpiralAppletControlPanel(final SpiralApplet applet)
            {
                java.awt.Container contentPane = this;

                contentPane.setLayout(new ColLayout());

                // used as "fill" argument to add()
                final java.awt.GridBagConstraints stretchx = new java.awt.GridBagConstraints(){{fill=HORIZONTAL;weightx=1.;}};
                final java.awt.GridBagConstraints stretchy = new java.awt.GridBagConstraints(){{fill=VERTICAL;weighty=1.;}};
                final java.awt.GridBagConstraints stretchxy = new java.awt.GridBagConstraints(){{fill=BOTH;weightx=weighty=1.;}};
                final java.awt.GridBagConstraints rightjustify = new java.awt.GridBagConstraints(){{anchor=EAST;}};
                final java.awt.GridBagConstraints centerjustify = new java.awt.GridBagConstraints(){{anchor=CENTER;}};

                // used as arg to setMargin()
                final java.awt.Insets nomargin = new java.awt.Insets(0,0,0,0);


                final java.awt.Color asciiToColor[] = new java.awt.Color[128];
                asciiToColor[' '] = null;
                asciiToColor['b'] = java.awt.Color.black;


                /*
                contentPane.add(new JSeparator(), stretchx);
                contentPane.add(new JLabel("File/Edit"));
                add(new JRow() {{
                    add(new JLabel("        ")); // indent a bit
                    add(new JCol() {{
                        // ...
                    }});
                }});
                */
                contentPane.add(new JSeparator(), stretchx);
                contentPane.add(new JLabel("Model"));
                add(new JRow() {{
                    add(new JLabel("        ")); // indent a bit
                    add(new JCol() {{
                        add(new JTablePanel() {{
                            {
                                final String toolTipText = "period";
                                add(new JLabel("Period:") {{
                                    setToolTipText(toolTipText);
                                }});
                                add(makeIncrementableTextFieldForInt(applet.spiralModelParams.n, toolTipText, 2));
                                add(new JLabel(" "));
                                add(new JTextFieldForNumber(applet.theSpiralModel.params.n) {{
                                    makeTextComponentLikeLabel(this);
                                    setToolTipText(toolTipText);
                                }});
                            }
                            advanceRow();
                            {
                                final String toolTipText = "number of parts into which to break 90 degrees";
                                add(new JLabel("Number of parts:") {{
                                    setToolTipText(toolTipText);
                                }});
                                add(makeIncrementableTextFieldForInt(applet.spiralModelParams.nParts, toolTipText, 1));
                                add(new JLabel(" "));
                                add(new JTextFieldForNumber(applet.theSpiralModel.params.nParts) {{
                                    makeTextComponentLikeLabel(this);
                                    setToolTipText(toolTipText);
                                }});
                            }
                            advanceRow();
                            {
                                final String toolTipText = "seed";
                                add(new JLabel("Random seed:") {{
                                    setToolTipText(toolTipText);
                                }});

                                add(makeIncrementableTextFieldForInt(applet.spiralModelParams.randomSeed, toolTipText, 1));
                                add(new JLabel(" "));
                                add(new JTextFieldForNumber(applet.theSpiralModel.params.randomSeed) {{
                                    makeTextComponentLikeLabel(this);
                                    setToolTipText(toolTipText);
                                }});
                            }
                        }});
                        add(new JRow() {
                            private ButtonGroup buttonGroup = new ButtonGroup();
                        {
                            add(new JLabel("Delta style:"));
                            add(new JLabel("  "));
                            add(new JRadioButton("<html>&plusmn;1</html>", applet.spiralModelParams.deltaStyle.get()==SpiralModel.DELTASTYLE_1) {{
                                setMargin(nomargin);
                                buttonGroup.add(this);
                                addActionListener(new java.awt.event.ActionListener() {
                                    public void actionPerformed(java.awt.event.ActionEvent e)
                                    {
                                        applet.spiralModelParams.deltaStyle.set(SpiralModel.DELTASTYLE_1);
                                        // no need to repaint
                                    }
                                });
                            }});
                            add(new JRadioButton("Any", applet.spiralModelParams.deltaStyle.get()==SpiralModel.DELTASTYLE_ANY) {{
                                setMargin(nomargin);
                                buttonGroup.add(this);
                                addActionListener(new java.awt.event.ActionListener() {
                                    public void actionPerformed(java.awt.event.ActionEvent e)
                                    {
                                        applet.spiralModelParams.deltaStyle.set(SpiralModel.DELTASTYLE_ANY);
                                        // no need to repaint
                                    }
                                });
                            }});
                            add(new JRadioButton("<html>&plusmn;1 wrap</html>", applet.spiralModelParams.deltaStyle.get()==SpiralModel.DELTASTYLE_1_WRAP) {{
                                setMargin(nomargin);
                                buttonGroup.add(this);
                                addActionListener(new java.awt.event.ActionListener() {
                                    public void actionPerformed(java.awt.event.ActionEvent e)
                                    {
                                        applet.spiralModelParams.deltaStyle.set(SpiralModel.DELTASTYLE_1_WRAP);
                                        // no need to repaint
                                    }
                                });
                            }});
                        }});

                        add(new JButton("Regenerate") {{
                            setMargin(nomargin);
                            // XXX TODO: red if params out of date
                            addActionListener(new java.awt.event.ActionListener() {
                                public void actionPerformed(java.awt.event.ActionEvent e)
                                {
                                    applet.theSpiralModel.init(applet.spiralModelParams.n.get(), applet.spiralModelParams.nParts.get(), applet.spiralModelParams.deltaStyle.get(), applet.spiralModelParams.randomSeed.get());

                                    applet.theSpiralView.focus.modEquals(
                                        applet.theSpiralModel.params.n.get(), 1);

                                    applet.theCanvas.repaint();
                                }
                            });
                        }});
                    }});
                }});
                contentPane.add(new JSeparator(), stretchx);
                contentPane.add(new JLabel("View"));
                add(new JRow() {{
                    add(new JLabel("        ")); // indent a bit
                    add(new JRow() {{
                        add(new JCol() {{
                            add(new JRow() {{
                                add(new JButton("reset focus to") {{
                                    setMargin(nomargin);
                                    addActionListener(new java.awt.event.ActionListener() {
                                        public void actionPerformed(java.awt.event.ActionEvent e)
                                        {
                                            applet.theSpiralView.focus.set(applet.theSpiralView.resetFocusTo.get(),1);
                                            applet.theCanvas.repaint();
                                        }
                                    });
                                }}, centerjustify);
                                add(new JTextFieldForNumber(applet.theSpiralView.resetFocusTo));
                            }});
                            add(new JRow() {{
                                add(new JRepeatingButton("") {
                                    public java.awt.Dimension getPreferredSize() { return new java.awt.Dimension(20,20); }
                                    public java.awt.Dimension getMinimumSize()   { return new java.awt.Dimension(20,20); }
                                    public void paint(java.awt.Graphics g)
                                    {
                                        super.paint(g);
                                        drawPixmapCentered(g, getSize(), asciiToColor,
                                                           new String[] {
                                                              "   b  b",
                                                              "  bb bb",
                                                              " bbbbbb",
                                                              "bbbbbbb",
                                                              " bbbbbb",
                                                              "  bb bb",
                                                              "   b  b",
                                                           });
                                    }
                                {
                                    addActionListener(new java.awt.event.ActionListener() {
                                        public void actionPerformed(java.awt.event.ActionEvent e)
                                        {
                                            applet.accelBackward();
                                        }
                                    });
                                    setToolTipText("<html>accelerate backward</html>");
                                }}, stretchxy);
                                add(new JRepeatingButton("") {
                                    public java.awt.Dimension getPreferredSize() { return new java.awt.Dimension(20,20); }
                                    public java.awt.Dimension getMinimumSize()   { return new java.awt.Dimension(20,20); }
                                    public void paint(java.awt.Graphics g)
                                    {
                                        super.paint(g);
                                        drawPixmapCentered(g, getSize(), asciiToColor,
                                                           new String[] {
                                                              "   b bb",
                                                              "  bb bb",
                                                              " bbb bb",
                                                              "bbbb bb",
                                                              " bbb bb",
                                                              "  bb bb",
                                                              "   b bb",
                                                           });
                                    }
                                {
                                    addActionListener(new java.awt.event.ActionListener() {
                                        public void actionPerformed(java.awt.event.ActionEvent e)
                                        {
                                            applet.stepBackward();
                                        }
                                    });
                                    setToolTipText("<html>step backward</html>");
                                }}, stretchxy);
                                add(new JRepeatingButton("") {
                                    public java.awt.Dimension getPreferredSize() { return new java.awt.Dimension(20,20); }
                                    public java.awt.Dimension getMinimumSize()   { return new java.awt.Dimension(20,20); }
                                    public void paint(java.awt.Graphics g)
                                    {
                                        super.paint(g);
                                        drawPixmapCentered(g, getSize(), asciiToColor,
                                                           new String[] {
                                                              "bbb bbb",
                                                              "bbb bbb",
                                                              "bbb bbb",
                                                              "bbb bbb",
                                                              "bbb bbb",
                                                              "bbb bbb",
                                                              "bbb bbb",
                                                           });
                                    }
                                {
                                    addActionListener(new java.awt.event.ActionListener() {
                                        public void actionPerformed(java.awt.event.ActionEvent e)
                                        {
                                            applet.pause();
                                        }
                                    });
                                    setToolTipText("<html>stop</html>");
                                }}, stretchxy);
                                add(new JRepeatingButton("") {
                                    public java.awt.Dimension getPreferredSize() { return new java.awt.Dimension(20,20); }
                                    public java.awt.Dimension getMinimumSize()   { return new java.awt.Dimension(20,20); }
                                    public void paint(java.awt.Graphics g)
                                    {
                                        super.paint(g);
                                        drawPixmapCentered(g, getSize(), asciiToColor,
                                                           new String[] {
                                                              "bb b   ",
                                                              "bb bb  ",
                                                              "bb bbb ",
                                                              "bb bbbb",
                                                              "bb bbb ",
                                                              "bb bb  ",
                                                              "bb b   ",
                                                           });
                                    }
                                {
                                    addActionListener(new java.awt.event.ActionListener() {
                                        public void actionPerformed(java.awt.event.ActionEvent e)
                                        {
                                            applet.stepForward();
                                        }
                                    });
                                    setToolTipText("<html>step forward</html>");
                                }}, stretchxy);
                                add(new JRepeatingButton("") {
                                    public java.awt.Dimension getPreferredSize() { return new java.awt.Dimension(20,20); }
                                    public java.awt.Dimension getMinimumSize()   { return new java.awt.Dimension(20,20); }
                                    public void paint(java.awt.Graphics g)
                                    {
                                        super.paint(g);
                                        drawPixmapCentered(g, getSize(), asciiToColor,
                                                           new String[] {
                                                              "b  b   ",
                                                              "bb bb  ",
                                                              "bbbbbb ",
                                                              "bbbbbbb",
                                                              "bbbbbb ",
                                                              "bb bb  ",
                                                              "b  b   ",
                                                           });
                                    }
                                {
                                    addActionListener(new java.awt.event.ActionListener() {
                                        public void actionPerformed(java.awt.event.ActionEvent e)
                                        {
                                            applet.accelForward();
                                        }
                                    });
                                    setToolTipText("<html>accelerate forward</html>");
                                }}, stretchxy);
                            }});
                        }});
                        add(new JLabel("    "));
                        add(new JCol() {{
                            add(new JTablePanel() {{
                                add(new JLabel("Anim sleep ms:"));
                                add(makeIncrementableTextFieldForInt(applet.animSleepMS, "number of milliseconds to sleep after each vsync pulse before calling repaint()", 1));
                                advanceRow();
                                add(new JLabel("Pixels per part:"));
                                add(makeIncrementableTextFieldForInt(applet.theSpiralView.pixelsPerPart, "pixels per part in ticker and stats plots", 1));
                                advanceRow();
                                add(new JLabel("Time quanta per part:"));
                                add(makeIncrementableTextFieldForInt(applet.theSpiralView.quantaPerPart, "time quanta per part", 1));
                            }});
                            add(new JCheckBoxForBoolean("show rungs", applet.theSpiralView.showRungsFlag) {{
                                setMargin(nomargin);
                            }});
                        }});
                    }});
                }});
                contentPane.add(new JSeparator(), stretchx);
                contentPane.add(new JLabel("Debug"));
                add(new JRow() {{
                    add(new JLabel("        ")); // indent a bit
                    add(new JCol() {{
                        add(new JCheckBoxForBoolean("show timing", applet.showTimingFlag) {{
                            setMargin(nomargin);
                        }});
                        add(new JCheckBoxForBoolean("show model ticker", applet.showTickerFlag) {{
                            setMargin(nomargin);
                        }});
                        add(new JCheckBoxForBoolean("show model spiral", applet.showSpiralFlag) {{
                            setMargin(nomargin);
                        }});
                        add(new JCheckBoxForBoolean("show model stats", applet.showStatsFlag) {{
                            setMargin(nomargin);
                        }});
                        add(new JCheckBoxForBoolean("print vsync lapses", applet.showVsyncLapsesFlag) {{
                            setMargin(nomargin);
                            setToolTipText("<html>if this is set, print whenever vsync lapse seems to be happening (assumes mostly 60hz framerate)</html>");
                        }});
                        add(new JRow() {{
                            add(new JButton("Dump window positions and sizes") {{
                                setMargin(nomargin);
                                addActionListener(new java.awt.event.ActionListener() {
                                    public void actionPerformed(java.awt.event.ActionEvent e)
                                    {
                                        System.out.println("----------------");
                                        System.out.println("      main applet: "+applet.theMainAppletWindow.getWidth()+"x"+applet.theMainAppletWindow.getHeight()+"+"+applet.theMainAppletWindow.getX()+"+"+applet.theMainAppletWindow.getY()+"");
                                        System.out.println("    control panel: "+applet.theControlPanelWindow.getWidth()+"x"+applet.theControlPanelWindow.getHeight()+"+"+applet.theControlPanelWindow.getX()+"+"+applet.theControlPanelWindow.getY()+"");
                                        System.out.println("             help: "+applet.theHelpWindow.getWidth()+"x"+applet.theHelpWindow.getHeight()+"+"+applet.theHelpWindow.getX()+"+"+applet.theHelpWindow.getY()+"");
                                        System.out.println("----------------");
                                    }
                                });
                            }});
                        }});
                        add(new JRow() {{


                            add(new JLabel("Window title:"));
                            add(new JTextFieldForString(applet.windowTitle) {
                                public java.awt.Dimension getPreferredSize()
                                {
                                    java.awt.Dimension superSize = super.getPreferredSize();
                                    // TODO: who owns it? can I tweak it and return it?
                                    return new java.awt.Dimension(200, superSize.height);
                                }
                                // weird, getPreferredSize seems adequate when returning 100... but when returning 200, it turns to zero!? unless we also provide getMinimumSize
                                public java.awt.Dimension getMinimumSize()
                                {
                                    return getPreferredSize();
                                }
                            });
                        }});
                    }});
                }});
                contentPane.add(new JSeparator(), stretchx);

                //randomlyColorize(this);

            } // SpiralAppletControlPanel ctor
        } // class SpiralAppletControlPanel

    //
    // Implementing Applet methods...
    //
        public SpiralApplet()
        {
            java.awt.Container contentPane = getContentPane();

            contentPane.setLayout(new ColLayout());

            // used as "fill" argument to add()
            final java.awt.GridBagConstraints stretchxy = new java.awt.GridBagConstraints(){{fill=BOTH;weightx=weighty=1.;}};

            contentPane.add(theCanvas = new TheCanvas() {}, stretchxy);


            //
            // Make the menu bar
            //
            if (true)
            {
                // http://www.isr.umd.edu/~austin/ence688r.d/java-swing/menu.d/DemoMenuItem.java
                JMenuBar menuBar = new JMenuBar();

                menuBar.setBorderPainted(false); // true is default. false makes it blend into the background a tiny bit more, which is good.

                this.setJMenuBar(menuBar);

                JMenu fileMenu = new JMenu("File", true);
                menuBar.add(fileMenu);

                JMenu editMenu = new JMenu("Edit", true);
                menuBar.add(editMenu);

                JMenu windowsMenu = new JMenu("Windows", true);
                menuBar.add(windowsMenu);
                windowsMenu.add(new JMenuItem("Control Panel") {{
                    addActionListener(new java.awt.event.ActionListener() {
                        public void actionPerformed(java.awt.event.ActionEvent e)
                        {
                            theControlPanelWindow.setState(JFrame.NORMAL); // not iconified
                            theControlPanelWindow.setVisible(true); // also brings it to front, apparently
                        }
                    });
                }});

                JMenu helpMenu = new JMenu("Help", true);
                menuBar.add(helpMenu);
                helpMenu.add(new JMenuItem("Help") {{
                    addActionListener(new java.awt.event.ActionListener() {
                        public void actionPerformed(java.awt.event.ActionEvent e)
                        {
                            help();
                        }
                    });
                }});
                helpMenu.add(new JMenuItem("About...") {{
                    // TODO: do me
                }});
            }

            //randomlyColorize(this);

            //
            // Make the control panel window
            //
            if (true)
            {
                theControlPanelWindow = new JFrame(windowTitle + " Control Panel");
                // no need for setDefaultCloseOperation
                // since the default is HIDE_ON_CLOSE which is what we want


                final boolean useScrollPane = false; // can set this to true if it gets big enough to warrant it

                final int preferredWidth = 600; // XXX big enough so tooltip doesn't spill out, since that causes perf problems forevermore
                final int preferredHeight = 400;


                java.awt.Component controlPanel = new SpiralAppletControlPanel(this) {
                    public java.awt.Dimension getPreferredSize()
                    {
                        if (useScrollPane)
                            return new java.awt.Dimension(preferredWidth, preferredHeight);
                        else
                            return super.getPreferredSize();
                    }
                    public java.awt.Dimension getMinimumSize()
                    {
                        if (useScrollPane)
                            return new java.awt.Dimension(preferredWidth, preferredHeight);
                        else
                            return super.getMinimumSize();
                    }
                };
                if (useScrollPane)
                    controlPanel = new JScrollPane(controlPanel);
                theControlPanelWindow.getContentPane().add(controlPanel);

                theControlPanelWindow.setLocation(730, 10);
                theControlPanelWindow.setSize(preferredWidth+34, preferredHeight); // empirical-- will be wrong on another machine, no doubt XXX TODO: can we compute a good preferred size? pack() or something? just want to pack width, not height, I think?
                theControlPanelWindow.setVisible(true);
            }


            //
            // Make the help window
            //
            {
                theHelpWindow = new JFrame("SpiralApplet Help");
                // no need for setDefaultCloseOperation
                // since the default is HIDE_ON_CLOSE which is what we want

                // TODO: figure out how to make it scroll in response to arrow keys

                if (true)
                {
                    // Use a JTextArea made to look like a label so text will be selectable
                    String text = "";
                    FORI (i, helpMessage.length)
                        text += "  " + helpMessage[i] + "  \n";
                    theHelpWindow.getContentPane().add(
                        new JScrollPane(
                            new JTextArea(text) {{
                                // make it like a JLabel as much as possible, but text selectable
                                this.setEditable(false);
                                this.setDisabledTextColor(java.awt.Color.black);
                                this.setBackground(null); // same as JLabel
                                this.setBorder(null); // same as JLabel
                            }}
                        ) {{
                            // if we don't do the following, it will screw up
                            // and pick a width that forces a horizontal scrollbar... lame!
                            this.setVerticalScrollBarPolicy(JScrollPane.VERTICAL_SCROLLBAR_ALWAYS);
                        }}
                    );
                }
                else
                {
                    // Use a JLabel -- text not selectable :-(
                    String htmlHelpMessage = "<html><pre>";
                    FORI (i, helpMessage.length)
                        htmlHelpMessage += helpMessage[i] + "  \n";
                    htmlHelpMessage += "</pre></html>";

                    theHelpWindow.getContentPane().add(new JScrollPane(new JLabel(htmlHelpMessage)) {{

                        // if we don't do the following, it will screw up
                        // and pick a width that forces a horizontal scrollbar... lame!
                        this.setVerticalScrollBarPolicy(JScrollPane.VERTICAL_SCROLLBAR_ALWAYS);
                    }});
                }

                theHelpWindow.setLocation(210,30); // XXX do I really want this?  can I center it instead? doing it so the help window doesn't end up in same place as main window.
                theHelpWindow.pack(); // so that getWidth() will be the preferred width
                theHelpWindow.setSize(theHelpWindow.getWidth(),700); // XXX heuristic for my screen
                //theHelpWindow.setVisible(true); // uncomment when debugging
            }
        } // SpiralApplet ctor

        static final String helpMessage[] = {
            "===================================================================",
            "Mouse:",
            "Keys:",
            "===================================================================",
        }; // helpMessage

        private void help()
        {
            theHelpWindow.setState(java.awt.Frame.NORMAL); // not ICONTIFIED
            theHelpWindow.setVisible(true);
            theHelpWindow.toFront();

            if (true)
            {
                FORI (i, helpMessage.length)
                    System.out.println(helpMessage[i]);
            }
        } // help

        // classNameAncestors
        private static String classNameAncestors(Class classs)
        {
            String text = classs.getName();

            if (text.indexOf("java.lang.") == 0)
                text = text.substring(10);
            if (text.indexOf("java.awt.") == 0)
                text = text.substring(9);
            if (text.indexOf("javax.swing.J") == 0)
                text = text.substring(12);

            //if (text.indexOf('$') != -1)
            if (classs.getSuperclass() != null)
                text += " > " + classNameAncestors(classs.getSuperclass());
            return text;
        } // classNameAncestors
        private static void dumpComponentHierarchy(java.awt.Component component, int depth, int iChildInParent, int nChildrenInParent)
        {
            FORI (i, depth) System.out.print(" ");

            System.out.print(iChildInParent+"/"+nChildrenInParent+" ");
            System.out.println(classNameAncestors(component.getClass()));

            if (component instanceof java.awt.Container)
            {
                java.awt.Container C = (java.awt.Container)component;
                int n = C.getComponentCount();
                for (int iChild = 0; iChild < n; ++iChild)
                {
                    //FORI (iIndent, depth) System.out.print(" "); System.out.println(iChild+"/"+n);
                    dumpComponentHierarchy(C.getComponent(iChild), depth+1, iChild, n);
                }
                if (n > 0)
                {
                    //FORI (iIndent, depth) System.out.print(" "); System.out.println(n+"/"+n);
                }
            }
        } // dumpComponentHierarchy

        private static void randomlyColorize(java.awt.Component c)
        {
            c.setBackground(new java.awt.Color((float)Math.random(),
                                               (float)Math.random(),
                                               (float)Math.random()));
            c.setForeground(new java.awt.Color((float)Math.random(),
                                               (float)Math.random(),
                                               (float)Math.random()));
            if (c instanceof java.awt.Container)
            {
                java.awt.Container C = (java.awt.Container)c;
                int n = C.getComponentCount();
                for (int i = 0; i < n; ++i)
                    randomlyColorize(C.getComponent(i));
            }
        } // randomlyColorize

        public void init()
        {
            eventVerbose = getParameterInt("EventVerbose", eventVerbose);
            if (eventVerbose >= 1) System.out.println("in init");

            graphicsAntiAliasingSetter = new GraphicsAntiAliasingSetter();

            theSpiralView.showRungsFlag.addListener(showRungsFlagListener = new Listenable.Listener() {
                public void valueChanged()
                {
                    theCanvas.repaint();
                }
            });

            theSpiralView.pixelsPerPart.addListener(pixelsPerPartListener = new Listenable.Listener() {
                public void valueChanged()
                {
                    if (theSpiralView.pixelsPerPart.get() <= 0)
                    {
                        // reject!
                        System.out.println("rejecting change to pixelsPerPart!");
                        theSpiralView.pixelsPerPart.set(1);
                        return; // we just got called recursively; our work is done
                    }

                    theCanvas.repaint();
                }
            });
            theSpiralView.quantaPerPart.addListener(quantaPerPartListener = new Listenable.Listener() {
                public void valueChanged()
                {
                    if (theSpiralView.quantaPerPart.get() <= 0)
                    {
                        // reject!
                        System.out.println("rejecting change to quantaPerPart!");
                        theSpiralView.quantaPerPart.set(1);
                        return; // we just got called recursively; our work is done
                    }

                    // XXX should this be in SpiralView? hmm
                    // XXX needs to be synchronized
                    theSpiralView.focusAnimationVelocity.divEquals(theSpiralView.focusQuantum);
                    theSpiralView.focusQuantum.set(1,theSpiralView.quantaPerPart.get()); // focusQuantum = 1/quantaPerPart
                    theSpiralView.focusAnimationVelocity.timesEquals(theSpiralView.focusQuantum);

                    // round focus to a multiple of focusQuantum.
                    // this makes sure focus hits integer boundaries,
                    // and prevents out-of-control rational denominators.
                    if (theSpiralView.focusQuantum.d % theSpiralView.focus.d != 0)
                    {
                        //System.out.println("rounding focus to multiple of focusQuantum!");
                        //PRINT(theSpiralView.focus);
                        //PRINT(theSpiralView.focusQuantum);
                        theSpiralView.focus.generalRoundEquals(theSpiralView.focusQuantum);
                        //PRINT(theSpiralView.focus);
                        //OUT("");
                    }


                    theCanvas.repaint(); // because focus may have changed
                }
            });

            showTimingFlag.addListener(showTimingFlagListener = new Listenable.Listener() {
                public void valueChanged()
                {
                    theCanvas.repaint();
                }
            });
            showTickerFlag.addListener(showTickerFlagListener = new Listenable.Listener() {
                public void valueChanged()
                {
                    theCanvas.repaint();
                }
            });
            showSpiralFlag.addListener(showSpiralFlagListener = new Listenable.Listener() {
                public void valueChanged()
                {
                    theCanvas.repaint();
                }
            });
            showStatsFlag.addListener(showStatsFlagListener = new Listenable.Listener() {
                public void valueChanged()
                {
                    theCanvas.repaint();
                }
            });

            if (eventVerbose >= 1) System.out.println("out init");
        } // init

        public void start()
        {
            if (eventVerbose >= 1) System.out.println("in start");
            if (eventVerbose >= 1) System.out.println("out start");
        }
        public void stop()
        {
            if (eventVerbose >= 1) System.out.println("in stop");
            if (eventVerbose >= 1) System.out.println("out stop");
        }
        public void destroy()
        {
            if (eventVerbose >= 1) System.out.println("in destroy");
            if (eventVerbose >= 1) System.out.println("out destroy");
        }

        //
        // Button behavor changed incompatibly between Java 1.1 and 1.4
        // (not sure exactly what version it changed in though).
        // (I think it was 1.4 since that's when getButton() was added
        // to MouseEvent).
        //
        private static int getButton(java.awt.event.MouseEvent e)
        {
            // gag me! we can't even query the java spec version number
            // since System.getProperty() throws a security exception
            // in netscape!
            // so use empirical evidence...
            int mods = e.getModifiers();
#if 0 // can't seem to get this to work under IE at all, so don't try for now, it will just be wrong under 1.4
            boolean is_1_4_or_greater = ((mods & ~0x1fff) != 0);
            if (is_1_4_or_greater)
            {
                try
                {
                    return e.getButton();
                }
                catch (NoSuchMethodError err)
                {
                    // this only happens in IE, not netscape. fall through...
                }
            }
#endif

            if ((mods & java.awt.event.InputEvent.ALT_MASK) != 0)
                return java_awt_event_MouseEvent_BUTTON2;
            if ((mods & java.awt.event.InputEvent.META_MASK) != 0)
                return java_awt_event_MouseEvent_BUTTON3;
            return java_awt_event_MouseEvent_BUTTON1;
        } // getButton

        private class TheCanvas
            extends JPanel
            implements java.awt.event.MouseListener,
                       java.awt.event.MouseMotionListener,
                       java.awt.event.KeyListener
        {
            TheCanvas()
            {
                // hmm, double buffering doesn't seem to make much difference, on my laptop??
                super(true); // double buffered
                //super(false); // not double buffered
                //PRINT(isDoubleBuffered());

                // Specify an "event listener" object
                // to respond to events.
                // (>= Java 1.1 event model).
                this.addMouseListener(this);
                this.addMouseMotionListener(this);
                this.addKeyListener(this);
            }

            //
            // MouseListener and MouseMotionListener methods...
            //
            public void mousePressed(java.awt.event.MouseEvent e)
            {
                if (eventVerbose >= 1) System.out.println("in mousePressed: "+e);
                if (eventVerbose >= 1)
                {
                    if (getButton(e) == java_awt_event_MouseEvent_BUTTON1)
                        System.out.println("    (left mouse)");
                    if (getButton(e) == java_awt_event_MouseEvent_BUTTON2)
                        System.out.println("    (middle mouse)");
                    if (getButton(e) == java_awt_event_MouseEvent_BUTTON3)
                        System.out.println("    (right mouse)");
                }

                theCanvas.repaint();

                if (eventVerbose >= 1) System.out.println("out mousePressed: "+e);
            } // mousePressed
            public void mouseReleased(java.awt.event.MouseEvent e)
            {
                if (eventVerbose >= 1) System.out.println("in mouseReleased: "+e);

                theCanvas.repaint();

                if (eventVerbose >= 1) System.out.println("out mouseReleased: "+e);
            } // mouseReleased
            public void mouseEntered(java.awt.event.MouseEvent e)
            {
                if (eventVerbose >= 1) System.out.println("in mouseEntered: "+e);
                // steal keyboard focus!
                //System.out.println("Requesting focus!");
                requestFocus(); // hey it works! (javac 1.3, runtime 1.6)  XXX what does "it works" mean?
                if (eventVerbose >= 1) System.out.println("out mouseEntered: "+e);
            }
            public void mouseExited(java.awt.event.MouseEvent e)
            {
                if (eventVerbose >= 1) System.out.println("in mouseExited: "+e);
                if (eventVerbose >= 1) System.out.println("out mouseExited: "+e);
            }
            public void mouseClicked(java.awt.event.MouseEvent e)
            {
                if (eventVerbose >= 1) System.out.println("in mouseClicked: "+e);
                if (eventVerbose >= 1) System.out.println("out mouseClicked: "+e);
            }
            public void mouseDragged(java.awt.event.MouseEvent e)
            {
                if (eventVerbose >= 2) System.out.println("  in mouseDragged: "+e);

                theCanvas.repaint();

                if (eventVerbose >= 2) System.out.println("  out mouseDragged: "+e);
            } // mouseDragged
            public void mouseMoved(java.awt.event.MouseEvent e)
            {
                if (eventVerbose >= 3) System.out.println("    in mouseMoved: "+e);

                if (eventVerbose >= 3) System.out.println("    out mouseMoved: "+e);
            } // mouseMoved

            //
            // KeyListener methods...
            //
            public void keyPressed(java.awt.event.KeyEvent e)
            {
                if (eventVerbose >= 1) System.out.println("in keyPressed: "+e);

                switch(e.getKeyCode())
                {
                    case java.awt.event.KeyEvent.VK_UP:
                    case java.awt.event.KeyEvent.VK_DOWN:
                        pause();
                        break;
                    case java.awt.event.KeyEvent.VK_LEFT:
                        if (e.isShiftDown())
                        {
                            accelBackward();
                        }
                        else
                        {
                            stepBackward();
                        }
                        break;

                    case java.awt.event.KeyEvent.VK_RIGHT:
                        if (e.isShiftDown())
                        {
                            accelForward();
                        }
                        else
                        {
                            stepForward();
                        }
                        break;
                    default:
                        // don't print anything, or we'll print too much (e.g. Shift, and any keys we handle in keyTyped())
                        //System.out.println("Unknown keycode "+java.awt.event.KeyEvent.getKeyText(e.getKeyCode())+" ("+e.getKeyCode()+")");
                        break;
                }
                if (eventVerbose >= 1) System.out.println("out keyPressed: "+e);
            } // keyPressed
            public void keyReleased(java.awt.event.KeyEvent e)
            {
                if (eventVerbose >= 1) System.out.println("in keyReleased: "+e);
                switch(e.getKeyCode())
                {
                    default:
                        break;
                }
                if (eventVerbose >= 1) System.out.println("out keyReleased: "+e);
            } // keyReleased
            public void keyTyped(java.awt.event.KeyEvent e)
            {
                if (eventVerbose >= 1) System.out.println("in keyTyped: "+e);
                char c = e.getKeyChar();

                // In java 1.6, apparently ctrl-letter
                // started coming out as just the letter
                // (with ke.isControlDown() true).
                // Detect this and change it to the old behavior...
                // XXX need to do something else, or nothing at all here, for old javas (1.1) in which isControlDown doesn't exist... or else just stop trying to support 1.1 at all
                if (c >= 'a' && c <= 'z' && e.isControlDown())
                {
                    c -= ('a'-1);
                }

    #define CTRL(lowerCaseLetter) ((lowerCaseLetter)-'a' + 1)
                switch (c)
                {
                    case '\n':
                        theCanvas.repaint();
                        break;
                    case CTRL('q'): // quit
                    {
                        System.out.println("Aww.");
                        System.exit(1);
                    }
                    default:
                        System.out.println("Unknown key '"+c+"'("+(int)e.getKeyChar()+") typed");
                        break;
                }
                if (eventVerbose >= 1) System.out.println("out keyTyped: "+e);
            } // keyTyped






#if 0 // no longer works in 1.7, and emits deprecation warning, so fuck it
            //
            // Make it so we get keyboard focus on startup,
            // without having to click first.  Thanks, Melinda!
            // The state of things seems to be:
            //      - Buttons and TextFields are apparently "focus traversable"
            //        by default.  Canvases and Applets aren't,
            //        implying (not obvious) that you need to click to type
            //        when the app starts,
            //        which is almost never the desired behavior.
            //        You can change this by overriding isFocusTraversable(),
            //        which we do below.
            //      - Other approaches using requestFocus():
            //        A Canvas calling requestFocus() doesn't seem to do
            //        anything.  An Applet calling requestFocus() doesn't
            //        do anything during init(), but I think it works
            //        if you put it in the mouseEntered handler or something,
            //        though this can lead to various unpredictabilities.
            //
            public boolean isFocusTraversable()
            {
                return true;
            }
#endif



            double lastStartTimePrinted = 0.;
            int lastNPaintsPrinted = 0;


            // PAINT/DISPLAY/DRAW
            public void paintComponent(java.awt.Graphics g)
            {
                //try { Thread.sleep(50); } catch (InterruptedException e) {}
                java.awt.Dimension size = getSize();

                timingGraph.recordPaintStartTime(size.width+3);


                if (eventVerbose >= 1) System.out.println("in paint");


                if (showVsyncLapsesFlag.get())
                {
                    // Try to print out an idea of how frequent the lapses in vsync
                    // are happening
                    int sampleSize = 10;
                    if (timingGraph.startTimes.size() >= sampleSize+1
                     && nPaints >= lastNPaintsPrinted + 100
                     && (timingGraph.startTimes.get(timingGraph.startTimes.size()-1)-timingGraph.startTimes.get(timingGraph.startTimes.size()-1-sampleSize))/sampleSize < .01666*3/4.)
                    {
                        if (lastStartTimePrinted == 0.)
                            System.out.println("Hey! low frame time");
                        else
                            System.out.println("Hey! low frame time after "+(timingGraph.startTimes.get(timingGraph.startTimes.size()-1)-lastStartTimePrinted)+" secs");
                        lastNPaintsPrinted = nPaints;
                        lastStartTimePrinted = timingGraph.startTimes.get(timingGraph.startTimes.size()-1);
                    }
                }
                else
                {
                    lastStartTimePrinted = 0L;
                    lastNPaintsPrinted = 0;
                }

                // TODO: need to synchronize this I think
                theSpiralView.focus.plusEquals(theSpiralView.focusAnimationVelocity);
                theSpiralView.focus.modEquals(theSpiralModel.params.n.get(), 1);

                double minSize = (double)MIN(size.width, size.height);

                MyGraphics mg = new MyGraphics(g, size,
                    -size.width/minSize,size.width/minSize,
                    -size.height/minSize,size.height/minSize);

                if (implementAntiAliasingInHardware)
                {
                    graphicsAntiAliasingSetter.setAntiAliasing(g,
                                                               antiAliasingFlag,
                                                               //1
                                                               eventVerbose
                                                               );
                }


                //
                // Clear to black...
                //
                g.setColor(java.awt.Color.black);
                g.fillRect(0,0, size.width,size.height);


                double pixelsPerMilli = 4.;
                if (showTimingFlag.get())
                {
                    timingGraph.preDraw(g,size,pixelsPerMilli);
                }

                int nItersPrimal=0, nItersDual=0;
                if (showTickerFlag.get())
                {
                    drawTicker(g,
                               size,
                               size.width/2.,
                               size.height/2.,
                               theSpiralModel,
                               theSpiralView);
                }
                if (showSpiralFlag.get())
                {
                    double scale = .95; // TODO: gui hook for this
                    if (true)
                    {
                        // draw dual spiral
                        nItersDual = drawSpiral(mg,
                                   scale,
                                   theSpiralModel,
                                   theSpiralView,
                                   false, // drawPrimalFlag
                                   true, // drawDualFlag
                                   false, // drawRungsFlag
                                   antiAliasingFlag);
                    }
                    if (true)
                    {
                        // draw primal spiral
                        nItersPrimal = drawSpiral(mg,
                                   scale,
                                   theSpiralModel,
                                   theSpiralView,
                                   true, // drawPrimalFlag
                                   false, // drawDualFlag
                                   theSpiralView.showRungsFlag.get(), // drawRungsFlag
                                   antiAliasingFlag);
                    }
                }
                if (showStatsFlag.get())
                {
                    drawStats(g,
                              size,
                              theSpiralModel,
                              theSpiralView);
                }




                nPaints++;
                g.setColor(java.awt.Color.white);
                g.drawString(""+nPaints+" paints",
                              size.width - 75,
                              20);

                g.drawString("focus: "+theSpiralView.focus,
                             10,
                             20);



                if (showTimingFlag.get())
                {
                    g.drawString("dual iterations: "+nItersDual,
                                 10,
                                 60);
                    g.drawString("primal iterations: "+nItersPrimal,
                                 10,
                                 80);
                    timingGraph.draw(g,
                                     size,
                                     pixelsPerMilli);
                }



                if (!showStatsFlag.get()
                 && !showTimingFlag.get())
                {
                    // draw dot at exact center of window,
                    // for debugging.
                    g.setColor(java.awt.Color.red);
                    // 1 -> 0..1
                    // 2 -> 0..2
                    // 3 -> 1..2
                    // 4 -> 1..3
                    // 5 -> 2..3
                    // 6 -> 2..4
                    int x0 = (size.width-1)/2;
                    int x1 = (size.width+2)/2;
                    int y0 = (size.height-1)/2;
                    int y1 = (size.height+2)/2;
                    g.fillRect(x0,y0,
                               x1-x0,y1-y0);
                }



                // swing swaps buffers for us

                if (eventVerbose >= 1) System.out.println("out paint");

                timingGraph.recordPaintEndTime(size.width+3);
            } // paint

        } // class TheCanvas








        public TimingGraph timingGraph = new TimingGraph();

        // Calculate the angle C, opposite side c,
        // given side lengths a, b, c,
        // using c^2 = a^2 + b^2 - 2*a*b*cos(C)
        private static double triangleAngle(double a, double b, double c)
        {
            return Math.acos((a*a + b*b - c*c) / (2*a*b));
        }

        // Find vertex v2 that completes the triangle with given edge lengths,
        // such that v0,v1,v2 are CCW.
        private static double[] completeTriangle(double v0[],
                                                 double v1[],
                                                 double dist12,
                                                 double dist20)
        {
            // Make sure has only 2 entries
            v0 = new double[]{v0[0],v0[1]};
            v1 = new double[]{v1[0],v1[1]};
            double ang0 = triangleAngle(VecMath.dist(v0,v1), dist20, dist12);
            double dir01[] = VecMath.normalize(VecMath.vmv(v1,v0));
            double v2[] = VecMath.sxvpsxvpsxv(
                1.,                    v0,
                dist20*Math.cos(ang0), dir01,
                dist20*Math.sin(ang0), VecMath.xv2(dir01));
            return v2;
        } // completeTriangle

        private static double twiceTriangleArea(double x0, double y0,
                                                double x1, double y1,
                                                double x2, double y2)
        {
            return (x1-x0)*(y2-y0) - (x2-x0)*(y1-y0);
        }
        private static double twiceTriangleArea(double v0[],
                                           double v1[],
                                           double v2[])
        {
            return twiceTriangleArea(v0[0], v0[1],
                                     v1[0], v1[1],
                                     v2[0], v2[1]);
        }














        public static class SpiralModel
        {
            public static final int DELTASTYLE_MIN = 0;
            public static final int DELTASTYLE_1 = 0;
            public static final int DELTASTYLE_ANY = 1;
            public static final int DELTASTYLE_1_WRAP = 2;
            public static final int DELTASTYLE_MAX = 2;


            public static class Params
            {
                // XXX same thing in applet... should this be a little subclass?
                public Listenable.Int n = new Listenable.Int(2, 1000*1000*1000, 1000); // must be positive multiple of 2
                public Listenable.Int nParts = new Listenable.Int(1, 1000*1000*1000, 90); // must be >= 2
                public Listenable.Int deltaStyle = new Listenable.Int(SpiralModel.DELTASTYLE_MIN, SpiralModel.DELTASTYLE_MAX, SpiralModel.DELTASTYLE_ANY);
                public Listenable.Int randomSeed = new Listenable.Int(0, (1<<31)-1, 1);
            }

            public Params params = new Params();



            public int theList[/*n*/];
            public double centers[/*n*/][/*2*/]; // centers[i] is center of theList up through index i, rotated and scaled canonically
            public double weights[/*n*/]; // weights[i] is area of dual diagram of theList up through index i, rotated and scaled canonically

            SpiralModel()
            {
                init(params.n.get(),
                     params.nParts.get(),
                     params.deltaStyle.get(),
                     params.randomSeed.get());
            }

            public void init(int n,
                             int nParts,
                             int deltaStyle, // DELTASTYLE_1 or DELTASTYLE_ANY or DELTASTYLE_1_WRAP
                             int randomSeed)
            {
                this.params.n.set(n);
                this.params.nParts.set(nParts);
                this.params.deltaStyle.set(deltaStyle);
                this.params.randomSeed.set(randomSeed);

                java.util.Random rng = new java.util.Random(randomSeed);
                assert(n >= 2);
                assert(n % 2 == 0); // doesn't work with odd n
                assert(nParts >= 2); // doesn't work with only one part

                this.theList = new int[n];
                if (deltaStyle == DELTASTYLE_1)
                {
                    int maxPasses = 100;
                    int val = nParts/4*2; // somewhat arbitrary even starting point... will turn random (but still even, since n is even) on second pass.

                    boolean done = false;
                    FORI (iPass, maxPasses)
                    {
                        FORI (i, n)
                        {
                            if (iPass >= 1 && val == this.theList[i])
                            {
                                done = true;
                                break;
                            }
                            assert(val >= 0 && val < nParts);
                            this.theList[i] = val;

                            if (val == 0)
                                val = 1;
                            else if (val == nParts-1)
                                val = nParts-2;
                            else if (rng.nextBoolean())
                                val += 1;
                            else
                                val -= 1;
                        }
                        if (done)
                            break;
                    }
                    assert(done);
                }
                else if (deltaStyle == DELTASTYLE_ANY
                      || deltaStyle == DELTASTYLE_1_WRAP)
                {
                    int maxPasses = 100;


                    int val = nParts/4*2; // somewhat arbitrary even starting point... will turn random (but still even, since n is even) on second pass.
                    if (deltaStyle == DELTASTYLE_1_WRAP)
                    {
                        val = 0; // so it will likely cross over near beginning, so what it's doing will be more obvious at beginning
                    }
                    PRINT(nParts);
                    assert(val >= 0 && val < nParts && val%2 == 0);

                    boolean done = false;
                    int sign = -1; // initial val is biased a bit downwards, so there is guaranteed to be room upwards. so set sign initially to -1, so it will immediately switch to 1 and there will be room.
                    int nRemainingThisSign = 0;
                    FORI (iPass, maxPasses)
                    {
                        FORI (i, n)
                        {
                            if (iPass >= 1 && val == this.theList[i])
                            {
                                done = true;
                                break;
                            }
                            assert(val >= 0 && val < nParts);
                            this.theList[i] = val;

                            if (nRemainingThisSign == 0)
                            {
                                if (deltaStyle == DELTASTYLE_ANY)
                                {
                                    sign = -sign;
                                    if (sign == -1)
                                    {
                                        assert(val > 0);
                                        nRemainingThisSign = 1+rng.nextInt(val);
                                    }
                                    else
                                    {
                                        assert(nParts-1-val > 0);
                                        nRemainingThisSign = 1+rng.nextInt(nParts-1-val);
                                    }
                                }
                                else // DELTASTYLE_1_WRAP
                                {
                                    sign = rng.nextBoolean() ? 1 : -1;
                                    nRemainingThisSign = 1;
                                    if (sign==-1)
                                    {
                                        if (val == 0)
                                        {
                                            sign = 1;
                                            nRemainingThisSign = nParts-1;
                                        }
                                    }
                                    else
                                    {
                                        if (val == nParts-1)
                                        {
                                            sign = -1;
                                            nRemainingThisSign = nParts-1;
                                        }
                                    }
                                }
                            }

                            val += sign;
                            --nRemainingThisSign;
                        }
                        if (done)
                            break;
                    }
                    assert(done);
                }
                else
                    assert(false);

                // sanity check-- parity of value should be same as parity of index
                FORI (i, n)
                {
                    assert((theList[i] + i)%2 == 0);
                }

                this.centers = new double[n][2];
                this.weights = new double[n];
                if (true)
                {
                    // compute all cumulative centers and weights

                    double prevWeight = 0.;
                    double prevCenter[] = {0.,0.};
                    double thisWeight = 0.;
                    double thisCenter[] = {0.,0.};

                    boolean done = false;

                    double prevVal = theList[n-1];

                    int maxPasses = 2 + 10000/n; // really should be, roughly, one complete pass plus some fixed number of iterations
                    double scratch[] = new double[3];
                    PRINT(maxPasses);
                    FORI (iPass, maxPasses)
                    {
                        FORI (i, n)
                        {
                            // Compute new weight and center
                            // from prev weight and center

                            // val is (proportional to) primalAng-dualAng.
                            // when val increases, it means primalAng is increasing
                            // (i.e. Priscilla is moving, Dudley is turning)
                            // when val decreases, it means dualAng is increasing
                            // (i.e. Dudley is moving, Priscilla is turning)
                            // but, we always keep it canonicalized so that dualAng is 0.
                            double val = theList[i];
                            double prevPrimalAng = Math.PI/2 * ((prevVal+.5)/nParts);
                            double primalAng = Math.PI/2 * ((val+.5)/nParts);
                            if (primalAng > prevPrimalAng)
                            {
                                updateCenterAndWeightWhenPriscillaMoved(
                                        prevCenter[0], prevCenter[1], prevWeight,
                                        prevPrimalAng,
                                        primalAng,
                                        scratch);
                                thisCenter[0] = scratch[0];
                                thisCenter[1] = scratch[1];
                                thisWeight = scratch[2];
                            }
                            else
                            {
                                updateCenterAndWeightWhenDudleyMoved(
                                        prevCenter[0], prevCenter[1], prevWeight,
                                        prevPrimalAng,
                                        primalAng,
                                        scratch);
                                thisCenter[0] = scratch[0];
                                thisCenter[1] = scratch[1];
                                thisWeight = scratch[2];

                            }

                            if (done)
                            {
                                assert(VecMath.equalsExactly(this.centers[i], thisCenter));
                                assert(this.weights[i] == thisWeight);
                            }
                            else if (iPass > 0
                                  && VecMath.equalsExactly(this.centers[i], thisCenter)
                                  && this.weights[i] == thisWeight)
                            {
                                System.out.println("centers and weights stabilized at iPass="+iPass+" i="+i+"/n="+n);
                                done = true;
                            }
                            else
                            {
                                if (iPass==1 && i == n-1)
                                {
                                    // oh no, didn't stabilize.. print out the damage
                                    PRINTVEC(this.centers[i]);
                                    PRINT(this.weights[i]);
                                    PRINTVEC(thisCenter);
                                    PRINT(thisWeight);
                                }

                                VecMath.copyvec(this.centers[i], thisCenter);
                                this.weights[i] = thisWeight;
                            }

                            prevCenter[0] = thisCenter[0];
                            prevCenter[1] = thisCenter[1];
                            prevWeight = thisWeight;
                            prevVal = val;
                        }
                    }
                    assert(done);
                }

                // sanity check-- all centers should have strictly positive y coord.
                FORI (i, n)
                {
                    // theorem says center has positive y coord
                    if (!(centers[i][1] > 0.))
                    {
                        System.out.println("Oh no! centers["+i+"] = "+centers[i][1]+" <= 0!");
                    }
                    double primalAng = (theList[i]+.5)/nParts*(Math.PI*.5);

                    // theorem says |areaBasedMoment| <= sin(2*primalAng)/4
                    if (!(VecMath.norm(centers[i])*(weights[i]*.5) < Math.sin(2*primalAng)/4))
                    {
                        System.out.println("Oh no! centers["+i+"] = "+centers[i][1]+" has length "+VecMath.norm(centers[i])*(weights[i]*.5)+" >= "+Math.sin(2*primalAng)/4+"!");
                    }
                }
            } // init
        }; // public class SpiralModel
        public static class SpiralView
        {
            public Listenable.Int resetFocusTo = new Listenable.Int(0,0, 636);
            public Rational focus = new Rational(resetFocusTo.get(),1); // always modulo spiralModel.params.n
            public Listenable.Int pixelsPerPart = new Listenable.Int(2, 1024, 2); // must be >= 1
            public Listenable.Int quantaPerPart = new Listenable.Int(2, 1024, 1); // must be >= 1
            public Listenable.Boolean showRungsFlag = new Listenable.Boolean(false);
            public Rational focusQuantum = new Rational(1,quantaPerPart.get());
            public Rational focusAnimationVelocity = new Rational(0,1);
            public SpiralView()
            {}
        }; // public class SpiralView



        public static void updateCenterAndWeightWhenPriscillaMoved(
                double oldCenterX,
                double oldCenterY,
                double oldWeight,
                double oldPrimalMinusDualAng,
                double newPrimalMinusDualAng,
                double newCenterAndWeight[])
        {
            // primalAng is increasing. (assuming newPrimalMinusDual > oldPrimalMinusDual).
            // this shrinks the canonical representation of the primal,
            // thereby shrinking the center accordingly.
            // nothing happens to the weight,
            // nor to the direction from origin to center.
            double shrink = Math.cos(newPrimalMinusDualAng)
                          / Math.cos(oldPrimalMinusDualAng);
            assert(shrink < 1.); // XXX actually I think this can be relaxed
            double newCenterX = shrink * oldCenterX;
            double newCenterY = shrink * oldCenterY;
            double newWeight = oldWeight;
            newCenterAndWeight[0] = newCenterX;
            newCenterAndWeight[1] = newCenterY;
            newCenterAndWeight[2] = newWeight;
        } // updateCenterAndWeightWhenPriscillaMoved

        public static void updateCenterAndWeightWhenDudleyMoved(
                double oldCenterX,
                double oldCenterY,
                double oldWeight,
                double oldPrimalMinusDualAng,
                double newPrimalMinusDualAng,
                double newCenterAndWeight[])
        {
            // dualAng is increasing... (assuming newPrimalMinusDual < oldPrimalMinusDual).
            // decrease primalAng to compensate,
            // so dualAng ends up zero.
            // the formula for shrink is magic, worked out on paper
            double shrink = Math.sin(newPrimalMinusDualAng)
                          / Math.sin(oldPrimalMinusDualAng);
            assert(shrink <= 1.); // XXX actually I think this can be relaxed

            double weightIncr = shrink*Math.sin(oldPrimalMinusDualAng-newPrimalMinusDualAng);
            assert(weightIncr >= 0.);
            double oldWeightShrunk = oldWeight * SQR(shrink);
            double newWeight = oldWeightShrunk + weightIncr;

            // angle to rotate previous picture by (rotate CW, so it's negative)
            double t = newPrimalMinusDualAng-oldPrimalMinusDualAng;
            assert(t <= 0.);
            double ct = Math.cos(t);
            double st = Math.sin(t);
            double m[][] = {
                {ct,st},
                {-st,ct},
            };
            double newCenterX = m[0][0]*oldCenterX + m[1][0]*oldCenterY;
            double newCenterY = m[0][1]*oldCenterX + m[1][1]*oldCenterY;

            if (newWeight == 0.)
                assert(weightIncr == 0.);
            else
            {
                newCenterX = LERP(newCenterX, Math.cos(newPrimalMinusDualAng), weightIncr/newWeight);
                newCenterY = LERP(newCenterY, Math.sin(newPrimalMinusDualAng), weightIncr/newWeight);
            }
            newCenterAndWeight[0] = newCenterX;
            newCenterAndWeight[1] = newCenterY;
            newCenterAndWeight[2] = newWeight;
        } // updateCenterAndWeightWhenDudleyMoved
                        



        // for the drawStats function
        public static interface DataFetcher
        {
            public int nData();
            public void getDatum(int i, double putDatumHere[/*2*/]);
        } // abstract class DataFetcher

        // more general drawStats, takes an arbitrary iteration and bounds
        public static void drawOnePlot(java.awt.Graphics g,
                                       java.awt.Dimension gsize,

                                     // called like this:
                                     //     2,100,1, gx0,gx1, 1,100,2,  "left label", "right label",
                                     //     2,100,1, gy0,gy1, 1,100,2,  "bottom label", "top label",

                                     int gX0OuterFrameWidth, int gX0LabelWidth, int gX0InnerFrameWidth, // in pixels
                                     int gX0, int gX1, // in pixels-- may be in either order
                                     int gX1OuterFrameWidth, int gX1LabelWidth, int gX1InnerFrameWidth, // in pixels
                                     String gX0Label, String gX1Label,

                                     int gY0OuterFrameWidth, int gY0LabelWidth, int gY0InnerFrameWidth, // in pixels
                                     int gY0, int gY1, // in pixels-- may be in either order
                                     int gY1OuterFrameWidth, int gY1LabelWidth, int gY1InnerFrameWidth, // in pixels
                                     String gY0Label, String gY1Label,

                                     double x0, double x1, // values to put at gX0,gX1
                                     double y0, double y1, // values to put at gY0,gY1
                                     int nPartsMajorX, int nPartsMajorY, // for major grid lines

                                     java.awt.Color outerFrameColor,
                                     java.awt.Color innerFrameColor,
                                     java.awt.Color majorGridColor,
                                     java.awt.Color labelColor,
                                     java.awt.Color boundsColor,
                                     java.awt.Color dataColor,

                                     DataFetcher possibleBoundsFetcher,
                                     DataFetcher dataFetcher)

        {
            assumpt(gX0 < gX1);
            assumpt(gY0 != gY1);
            if (gY0 > gY1)
            {
                int temp;
                SWAP(gY0OuterFrameWidth, gY1OuterFrameWidth, temp);
                SWAP(gY0LabelWidth, gY1LabelWidth, temp);
                SWAP(gY0, gY1, temp);
                SWAP(gY0InnerFrameWidth, gY1InnerFrameWidth, temp);
            }
            assert(gY0 < gY1);


            if (true)
            {
                //  +-----------------+ - gY0000
                //  |   outer frame   |
                //  |+---------------+| - gY000
                //  ||               ||
                //  || +-----------+ || - gY00
                //  || |inner frame| ||
                //  || |+---------+| || - gY0
                //  || ||         || ||
                //  || |+---------+| || - gY1
                //  || +-----------+ || - gY11
                //  ||               ||
                //  |+---------------+| - gY111
                //  +-----------------+ - gY1111

                int gX00 = gX0-gX0InnerFrameWidth;
                int gX000 = gX00-gX0LabelWidth;
                int gX0000 = gX000-gX0OuterFrameWidth;
                int gX11 = gX1+gX1InnerFrameWidth;
                int gX111 = gX11+gX1LabelWidth;
                int gX1111 = gX111+gX1OuterFrameWidth;

                int gY00 = gY0-gY0InnerFrameWidth;
                int gY000 = gY00-gY0LabelWidth;
                int gY0000 = gY000-gY0OuterFrameWidth;
                int gY11 = gY1+gY1InnerFrameWidth;
                int gY111 = gY11+gY1LabelWidth;
                int gY1111 = gY111+gY1OuterFrameWidth;

                // draw outer frame
                g.setColor(outerFrameColor);
                g.fillRect(gX0000,gY0000, gX1111-gX0000,gY000-gY0000); // top
                g.fillRect(gX0000,gY111, gX1111-gX0000,gY1111-gY111); // bottom
                g.fillRect(gX0000,gY000, gX000-gX0000,gY111-gY000); // left
                g.fillRect(gX111,gY000, gX1111-gX111,gY111-gY000); // right

                // draw inner frame
                g.setColor(innerFrameColor);
                g.fillRect(gX00,gY00, gX11-gX00,gY0-gY00); // top
                g.fillRect(gX00,gY1, gX11-gX00,gY11-gY1); // bottom
                g.fillRect(gX00,gY0, gX0-gX00,gY1-gY0); // left
                g.fillRect(gX1,gY0, gX11-gX1,gY1-gY0); // right
            }

                
            // draw major grid lines (after frames, to make sure bounds are right)
            g.setColor(majorGridColor);
            // draw labels
            g.setColor(labelColor);
            // draw bounds
            g.setColor(boundsColor);
            // draw data
            g.setColor(dataColor);

        } // drawStats

        public static void drawStats(java.awt.Graphics g,
                                     java.awt.Dimension gsize,
                                     SpiralModel spiralModel,
                                     SpiralView spiralView)
        {
            // momentAng-dualAng vs. primalAng-dualAng graph
            {
                int nParts = spiralModel.params.nParts.get();
                int pixelsPerPart = spiralView.pixelsPerPart.get();
                int pixelsInPlot = nParts * pixelsPerPart + 1;


                // these bounds include inner frame
                int x0 = (gsize.width-pixelsInPlot)/2;
                int x1 = x0 + pixelsInPlot;
                int y1 = gsize.height/2 - 60;
                int y0 = y1 - pixelsInPlot;

                java.awt.Color gray64 = new java.awt.Color(64,64,64);
                drawOnePlot(g,
                            gsize,
                            2,100,1, x0+1,x1-1, 1,3,2, "momentAng-dualAng", null, // left to right
                            2,100,1, y1-1,y0+1, 1,3,2, null, "primalAng-dualAng", // bottom to top

                            0., Math.PI/2., // values to put at x bounds
                            0., Math.PI/2., // values to put at y bounds

                            nParts, nParts, // for major grid lines

                            java.awt.Color.blue, // outerFrameColor
                            java.awt.Color.white, // innerFrameColor
                            gray64, // majorGridColor
                            gray64, // labelColor
                            java.awt.Color.green, // boundsColor
                            java.awt.Color.red, // dataColor
                            new DataFetcher() { // possibleBoundsFetcher
                                public int nData()
                                {
                                    return 0;
                                }
                                public void getDatum(int i, double putDatumHere[/*2*/])
                                {
                                    assert(false);
                                }
                            },
                            new DataFetcher() { // dataFetcher
                                public int nData()
                                {
                                    return 0;
                                }
                                public void getDatum(int i, double putDatumHere[/*2*/])
                                {
                                    assert(false);
                                }
                            });


                // frame
                /*
                g.setColor(java.awt.Color.white);
                g.drawLine(x0,y0,x1-1,y0); // top
                g.drawLine(x0,y1-1,x1-1,y1-1); // bottom
                g.drawLine(x0,y0+1,x0,y1-2); // left
                g.drawLine(x1-1,y0+1,x1-1,y1-2); // right
                */

                // grid lines
                g.setColor(new java.awt.Color(64,64,64));
                int nMajor = 9;
                FORI (iMajor, nMajor+1)
                {
                    int x = (int)LERP(x0,x1-1,(double)iMajor/(double)nMajor); // position of vertical line
                    int y = (int)LERP(y0,y1-1,(double)iMajor/(double)nMajor); // position of horizontal line
                    g.drawString(iMajor==0 ? "   0" : ""+(90*iMajor/nMajor),
                                 x-6, y1+20);
                    g.drawString(iMajor==nMajor ? "   0" : ""+(90-90*iMajor/nMajor),
                                 x0-20, y+5);
                    if (iMajor != 0 && iMajor != nMajor)
                    {
                        g.drawLine(x,y0+1,x,y1-2); // vertical
                        g.drawLine(x0+1,y,x1-2,y); // horizontal
                    }
                }
                g.drawString("primalAng-dualAng", x0+(pixelsInPlot-103)/2, y1+40); // string width is 103 empirically
                g.drawString("momentAng-dualAng", x0-30-114, (y0+y1)/2+4); // string width is 114 empirically

                g.setColor(java.awt.Color.red);
                int n = spiralModel.params.n.get();
                FORI (i, n)
                {
                    int val = spiralModel.theList[i];
                    double center[] = spiralModel.centers[i];
                    double weight = spiralModel.weights[i];
                    double primalAng = (val+.5)/nParts * (Math.PI*.5);
                    int x = (int)LERP(x0,x1-1, primalAng/(Math.PI*.5));
                    double momentAng = Math.atan2(center[1],center[0]);
                    int y = (int)LERP(y1-1,y0, momentAng/(Math.PI*.5));
                    g.fillRect(x,y,1,1);

                    double maybeTopMomentAng = primalAng;
                    int maybeTopY = (int)LERP(y1-1,y0,maybeTopMomentAng/(Math.PI*.5));
                    g.setColor(java.awt.Color.green);
                    g.fillRect(x,maybeTopY-2,1,1); // should leave exactly 1 pixel gap
                    g.setColor(java.awt.Color.red);
                }
            }


            // |twiceAreaBasedMoment|/(primalR*dualR^2) vs. primalAng-dualAng graph
            {
                int nParts = spiralModel.params.nParts.get();
                int pixelsPerPart = spiralView.pixelsPerPart.get();
                int pixelsInPlot = nParts * pixelsPerPart + 1;

                int x0 = (gsize.width-pixelsInPlot)/2;
                int x1 = x0 + pixelsInPlot;
                int y0 = gsize.height/2 + 10;
                int y1 = gsize.height - 50;

                // frame
                g.setColor(java.awt.Color.white);
                g.drawLine(x0,y0,x1-1,y0); // top
                g.drawLine(x0,y1-1,x1-1,y1-1); // bottom
                g.drawLine(x0,y0+1,x0,y1-2); // left
                g.drawLine(x1-1,y0+1,x1-1,y1-2); // right

                // grid lines and labels
                g.setColor(new java.awt.Color(64,64,64));
                int nMajor = 9;
                FORI (iMajor, nMajor+1)
                {
                    int x = (int)LERP(x0,x1-1,(double)iMajor/(double)nMajor); // position of vertical line
                    int y = (int)LERP(y0,y1-1,(double)iMajor/(double)nMajor); // position of horizontal line
                    g.drawString(iMajor==0 ? "   0" : ""+(90*iMajor/nMajor),
                                 x-6, y1+20);
                    /*
                    g.drawString(iMajor==nMajor ? "   0" : ""+(90-90*iMajor/nMajor),
                                 x0-20, y+5);
                    */
                    if (iMajor != 0 && iMajor != nMajor)
                    {
                        g.drawLine(x,y0+1,x,y1-2); // vertical
                        g.drawLine(x0+1,y,x1-2,y); // horizontal
                    }
                }
                g.drawString("primalAng-dualAng", x0+(pixelsInPlot-103)/2, y1+40); // string width is 103 empirically
                g.drawString("|twiceAreaBasedMoment| / (primalR*dualR^2)", x0-30-248, (y0+y1)/2+4); // string width is 248 empirically

                g.setColor(java.awt.Color.red);
                int n = spiralModel.params.n.get();
                FORI (i, n)
                {
                    int val = spiralModel.theList[i];
                    double center[] = spiralModel.centers[i];
                    double weight = spiralModel.weights[i];
                    double primalAng = (val+.5)/nParts * (Math.PI*.5);
                    assert(EQ(primalAng, primalAng, 1e-6));
                    int x = (int)LERP(x0,x1-1, primalAng/(Math.PI*.5));
                    double momentR = VecMath.norm(center) * weight;
                    int y = (int)LERP(y1-1,y0, momentR);
                    g.fillRect(x,y,1,1);

                    double maybeTopMomentR = .5*Math.sin(2*primalAng);
                    int maybeTopY = (int)LERP(y1-1,y0,maybeTopMomentR);
                    g.setColor(java.awt.Color.green);
                    g.fillRect(x,maybeTopY-2,1,1); // should leave exactly 1 pixel gap
                    g.setColor(java.awt.Color.red);
                }
            }
            // area vs. primalAng-dualAng graph
            // this is actually a stupid graph,
            // since area is obviously unbounded
            // no matter what the current primal angle is.
            {
                int nParts = spiralModel.params.nParts.get();
                int pixelsPerPart = spiralView.pixelsPerPart.get();
                int pixelsInPlot = nParts * pixelsPerPart + 1;

                int x0 = (gsize.width+pixelsInPlot)/2 + 10;
                int x1 = x0 + pixelsInPlot;
                int y0 = gsize.height/2 + 10;
                int y1 = gsize.height - 50;

                // frame
                g.setColor(java.awt.Color.white);
                g.drawLine(x0,y0,x1-1,y0); // top
                g.drawLine(x0,y1-1,x1-1,y1-1); // bottom
                g.drawLine(x0,y0+1,x0,y1-2); // left
                g.drawLine(x1-1,y0+1,x1-1,y1-2); // right

                // grid lines and labels
                g.setColor(new java.awt.Color(64,64,64));
                int nMajor = 9;
                FORI (iMajor, nMajor+1)
                {
                    int x = (int)LERP(x0,x1-1,(double)iMajor/(double)nMajor); // position of vertical line
                    int y = (int)LERP(y0,y1-1,(double)iMajor/(double)nMajor); // position of horizontal line
                    g.drawString(iMajor==0 ? "   0" : ""+(90*iMajor/nMajor),
                                 x-6, y1+20);
                    /*
                    g.drawString(iMajor==nMajor ? "   0" : ""+(90-90*iMajor/nMajor),
                                 x0-20, y+5);
                    */
                    if (iMajor != 0 && iMajor != nMajor)
                    {
                        g.drawLine(x,y0+1,x,y1-2); // vertical
                        g.drawLine(x0+1,y,x1-2,y); // horizontal
                    }
                }
                g.drawString("primalAng-dualAng", x0+(pixelsInPlot-103)/2, y1+40); // string width is 103 empirically
                //g.drawString("area", x0-30-23, (y0+y1)/2+4); // string width is 23 empirically
                g.drawString("area", x1+10, (y0+y1)/2+4);

                g.setColor(java.awt.Color.red);
                int n = spiralModel.params.n.get();
                FORI (i, n)
                {
                    int val = spiralModel.theList[i];
                    double center[] = spiralModel.centers[i];
                    double weight = spiralModel.weights[i];
                    double primalAng = (val+.5)/nParts * (Math.PI*.5);
                    assert(EQ(primalAng, primalAng, 1e-6));
                    int x = (int)LERP(x0,x1-1, primalAng/(Math.PI*.5));
                    double area = weight*.5;
                    int y = (int)LERP(y1-1,y0, area);
                    g.fillRect(x,y,1,1);
                }
            }
        } // drawStats

        public static void drawTicker(java.awt.Graphics g,
                                      java.awt.Dimension gsize,
                                      double gCenterX, double gCenterY, // in pixels from upper-left corner of window
                                      SpiralModel spiralModel,
                                      SpiralView spiralView)
        {
            //System.out.println("    in drawTicker");
            int n = spiralModel.params.n.get();
            int nParts = spiralModel.params.nParts.get();
            int pixelsPerPart = spiralView.pixelsPerPart.get();
            //PRINT(nParts);
            //PRINT(pixelsPerPart);
            //PRINT(gCenterX);
            //PRINT(gCenterY);

            assert(n > 0);
            assert(pixelsPerPart > 0);
            assert(n % 2 == 0); // whole thing doesn't work otherwise


            java.awt.Color gray128 = new java.awt.Color(128,128,128);
            java.awt.Color gray64 = new java.awt.Color(64,64,64);
            java.awt.Color gray32 = new java.awt.Color(32,32,32);


            // Given gCenterX,gCenterY,
            // figure out the "base" pixel index.
            // this is the pixel where val=0 would go
            // at an exact even integer focus
            // (val=0 is only achievable on even focus).
            // If ixBase,iyBase are both .5 mod 1,
            // then we round one down and one up-- that's the purpose of the -round(-) thing.
            // XXX TODO: this works since the inputs are all multiples of .5, but may not be the most robust way in general, should think about it more
            int ixBase = (int)Math.round(gCenterX + (nParts-1)*pixelsPerPart*.25 - .5);
            int iyBase = -(int)Math.round(-(gCenterY + (nParts-1)*pixelsPerPart*.25 - .5));
            // from now on we never use gCenterX,gCenterY again
            //PRINT(gCenterX + (nParts-1)*pixelsPerPart*.25 - .5);
            //PRINT(gCenterY + (nParts-1)*pixelsPerPart*.25 - .5);
            //PRINT(ixBase);
            //PRINT(iyBase);

            // figure out where to draw rails, i.e. bounds
            // of ticker stip.
            // this should be the same regardless of focus.
            //  1->1
            //  2->1
            //  3->2
            //  4->2
            //  5->3
            //  pixelsPerPart -> (pixelsPerPart+1)/2
            int ixLowerRail = ixBase;
            int iyLowerRail = iyBase + (pixelsPerPart+1)/2;
            int ixUpperRail = ixBase;
            int iyUpperRail = iyBase - (nParts-1)*pixelsPerPart - (pixelsPerPart+1)/2;

            {
                // draw the rails...
                // (diagonal lines lower-left to upper-right).
                g.setColor(gray128);
                int gsizeMin = MIN(gsize.width, gsize.height);
                g.drawLine(ixLowerRail-gsizeMin,iyLowerRail+gsizeMin,
                           ixLowerRail+gsizeMin,iyLowerRail-gsizeMin);
                g.drawLine(ixUpperRail-gsizeMin,iyUpperRail+gsizeMin,
                           ixUpperRail+gsizeMin,iyUpperRail-gsizeMin);
                // and the center line...
                g.setColor(gray32);
                if ((iyLowerRail-iyUpperRail)%2 == 0)
                {
                    // one diagonal line exactly halfway between rails
                    g.drawLine(ixLowerRail-gsizeMin,(iyLowerRail+iyUpperRail)/2+gsizeMin,
                               ixLowerRail+gsizeMin,(iyLowerRail+iyUpperRail)/2-gsizeMin);
                }
                else
                {
                    // two diagonal lines
                    g.drawLine(ixLowerRail-gsizeMin,(iyLowerRail+iyUpperRail-1)/2+gsizeMin,
                               ixLowerRail+gsizeMin,(iyLowerRail+iyUpperRail-1)/2-gsizeMin);
                    g.drawLine(ixLowerRail-gsizeMin,(iyLowerRail+iyUpperRail+1)/2+gsizeMin,
                               ixLowerRail+gsizeMin,(iyLowerRail+iyUpperRail+1)/2-gsizeMin);
                }
                // draw focus
                // (diagonal line upper-left to lower-right, across strip)
                g.setColor(gray128);
                if (pixelsPerPart%2 == 0)
                    FORI (iPart, nParts)
                        g.fillRect(ixBase-iPart*pixelsPerPart/2,
                                   iyBase-iPart*pixelsPerPart/2,1,1);
                else
                    FORI (iPart, nParts)
                    {
                        if (iPart%2==0)
                        {
                            g.setColor(gray128);
                            g.fillRect(ixBase-iPart*pixelsPerPart/2,
                                       iyBase-iPart*pixelsPerPart/2,1,1);
                        }
                        else
                        {
                            g.setColor(gray64);
                            g.fillRect(ixBase-(iPart*pixelsPerPart+1)/2,
                                       iyBase-(iPart*pixelsPerPart-1)/2,1,1);
                            g.fillRect(ixBase-(iPart*pixelsPerPart-1)/2,
                                       iyBase-(iPart*pixelsPerPart+1)/2,1,1);
                        }
                    }
            }

            if (false) // can change to true for debugging
            {
                if (false)
                {
                    // blue for base
                    g.setColor(java.awt.Color.blue);
                    FORI (iPart, nParts)
                        g.fillRect(ixBase,iyBase-iPart*pixelsPerPart,1,1);
                }

                if (true)
                {
                    // yellow for rail
                    g.setColor(java.awt.Color.yellow);
                    g.fillRect(ixLowerRail,iyLowerRail,1,1);
                    g.fillRect(ixUpperRail,iyUpperRail,1,1);
                }
            }


            // the two indices bounding
            // the focus
            spiralView.focus.modEquals(n,1); // make sure
            Rational focus = spiralView.focus;
            //PRINT(focus);
            int i0 = focus.floor();
            //PRINT(i0);
            Rational frac = focus.minus(i0,1); // frac = focus - i0, before modding i0 by n
            i0 = MOD(i0, n);
            //PRINT(i0);
            int i1 = (i0+1)%n;
            int val0 = spiralModel.theList[i0];
            int val1 = spiralModel.theList[i1];
            //PRINT(val0);
            //PRINT(val1);
            //PRINT(frac);
            Rational val = new Rational(val0,1).lerpEquals(val1,1, frac.n,frac.d); // val = lerp(val0,val1,frac)
            //PRINT(val);


            // Now we need to figure out
            // the exact pixel index at which to place the vertex i0.
            // Everything else will be computed exactly relative to that.
            //
            // There are two cases:
            //         increasing... focus is on a vertical segment,
            //         i.e. in the middle of a primal edge / dual vertex
            //             /     /
            //            /\i1  /
            //           /  |  /
            //          /  i0\/
            //         /     /
            //         decreasing... focus is on a horizontal segment,
            //         i.e. in the middle of a primal vertex / dual edge
            //             /     /
            //            /\    /
            //           /i0-i1/
            //          /    \/
            //         /     /

            int ix0, iy0;
            {
                // figure out how many pixels from base to i0

                Rational upperLeftOffset = new Rational(val0*pixelsPerPart, 2);
                Rational lowerLeftOffset = val.minus(val0,1).abs().times(pixelsPerPart,2);
                //PRINT(upperLeftOffset);
                //PRINT(lowerLeftOffset);

                // upperLeftOffset is now a multiple of .5.
                // adjust lowerLeftOffset to nearest Value that's the same as upperLeftOffset mod 1.

                if (upperLeftOffset.d == 1) // i.e. if it's an integer
                    lowerLeftOffset.roundEquals();
                else
                    lowerLeftOffset.plusEquals(1,2).roundEquals().minusEquals(1,2); // round to nearest thing that's .5 mod 1
                //PRINT(lowerLeftOffset);

                //double xOffset = (-upperLeftOffset - lowerLeftOffset);
                //double yOffset = (-upperLeftOffset + lowerLeftOffset);
                //assert((double)(int)xOffset == xOffset);
                //assert((double)(int)yOffset == yOffset);

                Rational xOffset = upperLeftOffset.times(-1,1).minus(lowerLeftOffset);
                Rational yOffset = upperLeftOffset.times(-1,1).plus(lowerLeftOffset);
                //PRINT(xOffset);
                //PRINT(yOffset);
                assert(xOffset.d == 1);
                assert(yOffset.d == 1);


                ix0 = ixBase + xOffset.n;
                iy0 = iyBase + yOffset.n;
                //PRINT(ix0);
                //PRINT(iy0);
            }

            if (true)
            {
                g.setColor(new java.awt.Color(128,128,255)); // light blue
                {
                    int prevX = ix0;
                    int prevY = iy0;
                    int prevVal = spiralModel.theList[i0];
                    for (int i = (i0+1)%n; ; i = (i+1)%n)
                    {
                        int thisVal = spiralModel.theList[i];
                        int thisX, thisY;
                        if (thisVal > prevVal)
                        {
                            // vertical seg upwards
                            thisX = prevX;
                            thisY = prevY - (thisVal-prevVal) * pixelsPerPart;
                        }
                        else
                        {
                            // horizonal seg to right
                            thisY = prevY;
                            thisX = prevX + (prevVal-thisVal) * pixelsPerPart;
                        }
                        g.drawLine(prevX,prevY,thisX,thisY);
                        if (thisX >= gsize.width || thisY < 0)
                            break;
                        prevVal = thisVal;
                        prevX = thisX;
                        prevY = thisY;
                    }
                }

                g.setColor(new java.awt.Color(128,255,128)); // light green
                {
                    int prevX = ix0;
                    int prevY = iy0;
                    int prevVal = spiralModel.theList[i0];
                    for (int i = MOD(i0-1,n); ; i = MOD(i-1,n))
                    {
                        int thisVal = spiralModel.theList[i];
                        int thisX, thisY;
                        if (thisVal < prevVal)
                        {
                            // vertical seg downwards
                            thisX = prevX;
                            thisY = prevY + (prevVal-thisVal) * pixelsPerPart;
                        }
                        else
                        {
                            // horizonal seg to left
                            thisY = prevY;
                            thisX = prevX - (thisVal-prevVal) * pixelsPerPart;
                        }
                        g.drawLine(prevX,prevY,thisX,thisY);
                        if (thisX < 0 || thisY >= gsize.height)
                            break;
                        prevVal = thisVal;
                        prevX = thisX;
                        prevY = thisY;
                    }
                }
            }

            //System.out.println("    out drawTicker");
        } // drawTicker

        // returns number of inner loop iterations.
        public static int drawSpiral(MyGraphics mg,
                                     double scale,
                                     SpiralModel spiralModel,
                                     SpiralView spiralView,
                                     boolean drawPrimalFlag,
                                     boolean drawDualFlag,
                                     boolean drawRungsFlag,
                                     boolean antiAliasFlag)
        {
            int debugLevel = 0; // 1 = global, 2 = and some per-increment

            // have to be drawing something
            assert(drawPrimalFlag || drawDualFlag || drawRungsFlag);
            // don't draw primal and dual at same time
            assert(!drawPrimalFlag || !drawDualFlag);

            if (debugLevel >= 1) System.out.println("    in drawSpiral "+(drawPrimalFlag?"primal":"")+(drawDualFlag?"dual":"")+(drawRungsFlag?",rungs":""));

            int n = spiralModel.params.n.get();
            int nParts = spiralModel.params.nParts.get();

            // the two indices bounding
            // the focus
            spiralView.focus.modEquals(n,1); // make sure
            Rational focus = spiralView.focus;
            if (debugLevel >= 1) PRINT(focus);
            int i0 = focus.floor();
            if (debugLevel >= 1) PRINT(i0);
            Rational frac = focus.minus(i0,1); // frac = focus - i0, before modding i0 by n
            i0 = MOD(i0, n);
            if (debugLevel >= 1) PRINT(i0);
            int i1 = (i0+1)%n;
            int val0 = spiralModel.theList[i0];
            int val1 = spiralModel.theList[i1];
            if (debugLevel >= 1) PRINT(val0);
            if (debugLevel >= 1) PRINT(val1);
            if (debugLevel >= 1) PRINT(frac);
            double val = LERP(val0,val1,frac.toDouble()); // XXX TODO: use rational arithmetic all the way through... maybe? actually might not be necessary in this function
            if (debugLevel >= 1) PRINT(val);

            if (debugLevel >= 1)
            {
                PRINT(focus);
                PRINT(i0);
                PRINT(i1);
                PRINT(frac);
                PRINT(val0);
                PRINT(val1);
                PRINT(val);
            }

            java.awt.Color gray128 = new java.awt.Color(128,128,128);
            java.awt.Color gray64 = new java.awt.Color(64,64,64);
            java.awt.Color gray32 = new java.awt.Color(32,32,32);
            java.awt.Color pink = new java.awt.Color(255,128,128);
            java.awt.Color dimPink = new java.awt.Color(128,64,64);

            int returnValue = 0;

            // scanDir=1: the part *after* (bigger than) the focus.
            // scanDir=-1: the part *before* (smaller than) the focus.
            int scanDirs[] = {1, -1};
            FORI (iScanDir, 2)
            {
                int scanDir = scanDirs[iScanDir];
                if (debugLevel >= 1) System.out.println("        scanDir = "+scanDir);

                if (drawPrimalFlag)
                {
                    if (scanDir < 0)
                        mg.setColor(new java.awt.Color(128,255,128)); // light green
                    else
                        mg.setColor(new java.awt.Color(128,128,255)); // light blue
                }
                else
                {
                    if (scanDir < 0)
                        mg.setColor(java.awt.Color.white);
                    else
                        mg.setColor(gray64);
                }


                double dualAng = 0;
                double primalAng = Math.PI/2 * ((val+.5)/nParts);
                double dualR = scale;
                double primalR = scale;

                double dualX = dualR * Math.cos(dualAng);
                double dualY = dualR * Math.sin(dualAng);
                double primalX = primalR * Math.cos(primalAng);
                double primalY = primalR * Math.sin(primalAng);

                if (debugLevel >= 1 && scanDir > 0)
                {
                    PRINT(RTOD(primalAng));
                    PRINT(RTOD(dualAng));
                    PRINT(primalX);
                    PRINT(primalY);
                }



                // Accumulate and draw center of curvature, if scanDir  is -1
                double centerX = 0.;
                double centerY = 0.;
                double twiceArea = 0.;
                boolean centerHasStabilized = false;


                double prevPrevVal = val;
                double prevVal = val;
                for (int i = scanDir==1?i1:i0; ; i = MOD(i+scanDir,n))
                {
                    returnValue++;

                    // TODO: combine straight parts, the line will look better

                    int thisVal = spiralModel.theList[i];
                    if (scanDir==1 ? thisVal > prevVal : thisVal < prevVal)
                    {
                        // primal movement, dual turn
                        if (debugLevel >= 2 && scanDir > 0) System.out.println("            primal movement, dual turn");
                        double angleDelta = (double)(thisVal-prevVal)/(double)nParts * (Math.PI*.5);
                        if (debugLevel >= 2 && scanDir > 0) PRINT(RTOD(angleDelta));
                        double nextPrimalAng = primalAng + angleDelta;
                        if (nextPrimalAng > Math.PI)
                            nextPrimalAng -= 2*Math.PI;
                        else if (nextPrimalAng < -Math.PI)
                            nextPrimalAng += 2*Math.PI;
                        if (debugLevel >= 2 && scanDir > 0) PRINT(RTOD(nextPrimalAng));
                        double nextPrimalR = primalR * Math.cos(primalAng-dualAng)
                                                     / Math.cos(nextPrimalAng-dualAng);
                        double nextPrimalX = nextPrimalR * Math.cos(nextPrimalAng);
                        double nextPrimalY = nextPrimalR * Math.sin(nextPrimalAng);
                        if (debugLevel >= 2 && scanDir > 0) PRINT(nextPrimalR);
                        if (debugLevel >= 2 && scanDir > 0) PRINT(nextPrimalX);
                        if (debugLevel >= 2 && scanDir > 0) PRINT(nextPrimalY);

                        if (drawPrimalFlag)
                        {
                            mg.drawLine(primalX, primalY,
                                        nextPrimalX, nextPrimalY,
                                        antiAliasFlag);
                            if (
                                prevPrevVal != prevVal &&
                                (thisVal<prevVal) != (prevVal<prevPrevVal))
                            {
                                // draw point at larger-index endpoint of the line
                                if (scanDir < 0)
                                {
                                    mg.drawPoint(primalX, primalY, 5);
                                }
                                else
                                {
                                    mg.drawPoint(primalX, primalY, 3);
                                }
                            }
                            if (scanDir > 0)
                            {
                                if (SQR(nextPrimalX)+SQR(nextPrimalY)
                                   > SQR(1) + SQR(2)) // XXX should be max distance of any corner of window from origin
                                    break;
                            }
                            else
                            {
                                if (SQR(nextPrimalX)+SQR(nextPrimalY) < SQR(1e-3)
                                 && centerHasStabilized)
                                    break;
                            }
                        }
                        if (drawRungsFlag &&
                            prevPrevVal != prevVal &&
                            (thisVal<prevVal != (prevVal<prevPrevVal)))
                        {
                            java.awt.Color savedColor = mg.getColor();
                            mg.setColor(dimPink);
                            mg.drawLine(primalX, primalY,
                                        dualX, dualY,
                                        antiAliasFlag);
                            mg.setColor(savedColor);
                        }

                        primalAng = nextPrimalAng;
                        primalR = nextPrimalR;
                        primalX = nextPrimalX;
                        primalY = nextPrimalY;
                    }
                    else if (scanDir==1 ? thisVal < prevVal : thisVal > prevVal)
                    {
                        // dual movement, primal turn
                        if (debugLevel >= 2 && scanDir > 0) System.out.println("            dual movement, primal turn");
                        double angleDelta = (double)(prevVal-thisVal)/(double)nParts * (Math.PI*.5);
                        double nextDualAng = dualAng + angleDelta;
                        if (nextDualAng > Math.PI)
                            nextDualAng -= 2*Math.PI;
                        else if (nextDualAng < -Math.PI)
                            nextDualAng += 2*Math.PI;
                        // worked this out on paper.
                        // don't think too hard about the scanDir=-1 case, in which case angleDelta is negative and the triangle is inside out... it just works.
                        double nextDualR= dualR * Math.sin(primalAng-dualAng)
                                                / Math.sin(primalAng-nextDualAng);
                        double nextDualX = nextDualR * Math.cos(nextDualAng);
                        double nextDualY = nextDualR * Math.sin(nextDualAng);

                        if (drawDualFlag)
                        {
                            mg.drawLine(dualX, dualY,
                                        nextDualX, nextDualY,
                                        antiAliasFlag);

                            if (prevVal==prevPrevVal
                             || (thisVal<prevVal) != (prevVal<prevPrevVal))
                            {
                                if (scanDir < 0)
                                {
                                    mg.drawPoint(dualX, dualY, 5);
                                    mg.drawLine(0.,0.,
                                                dualX, dualY,
                                                antiAliasFlag);
                                }
                                else
                                    mg.drawPoint(dualX, dualY, 3);
                            }

                            if (scanDir > 0)
                            {
                                if (SQR(nextDualX)+SQR(nextDualY)
                                   > SQR(1) + SQR(2)) // XXX should be max distance of any corner of window from origin
                                    break;
                            }
                            else
                            {
                                if (SQR(nextDualX)+SQR(nextDualY) < SQR(1e-3)
                                 && centerHasStabilized)
                                    break;
                            }
                        }
                        if (drawRungsFlag &&
                            (prevVal!=prevPrevVal &&
                            (thisVal<prevVal != (prevVal<prevPrevVal))))
                        {
                            java.awt.Color savedColor = mg.getColor();
                            mg.setColor(dimPink);
                            mg.drawLine(primalX, primalY,
                                        dualX, dualY,
                                        antiAliasFlag);
                            mg.setColor(savedColor);
                        }

                        if (scanDir < 0)
                        {
                            double twiceAreaIncr = twiceTriangleArea(0.,0., dualX,dualY, nextDualX,nextDualY);
                            assert(twiceAreaIncr <= 0.); // area triangle is negative since scanning backwards
                            twiceAreaIncr = ABS(twiceAreaIncr);

                            if (twiceArea+twiceAreaIncr == twiceArea)
                            {
                                centerHasStabilized = true;
                                // don't break til it's all visually small enough too
                            }
                            //if (dualY != 0.) // experimenting-- if we omit first one, should sometimes assert-fail due to center being too low. seems to work.
                            {
                                twiceArea += twiceAreaIncr;

                                centerX = LERP(centerX, primalX, twiceAreaIncr/twiceArea);
                                centerY = LERP(centerY, primalY, twiceAreaIncr/twiceArea);
                                //PRINT(twiceAreaIncr);
                                //PRINT(twiceAreaIncr*primalX);
                                //PRINT(twiceAreaIncr*primalY);
                            }
                        }

                        dualAng = nextDualAng;
                        dualR = nextDualR;
                        dualX = nextDualX;
                        dualY = nextDualY;
                    }

                    if (drawDualFlag // actually maybe should be another flag for this?
                     && scanDir < 0)
                    {
                        // actually just want normalized, but we'll divide by dualR later instead
                        double m[][] = {
                            {dualX,dualY},
                            {-dualY,dualX},
                        };
                        double center[] = VecMath.vxm(spiralModel.centers[i], m);
                        VecMath.vxs(center, center, primalR/dualR); // divide by dualR because we should never have multiplied by it
                        //VecMath.vxs(center, center, 2.); // XXX I don't understand this
                        java.awt.Color savedColor = mg.getColor();
                        mg.setColor(java.awt.Color.yellow);

                        boolean big = (spiralModel.theList[i] > spiralModel.theList[(i+1)%n])
                                 && !(spiralModel.theList[MOD(i-1,n)] > spiralModel.theList[i]);
                        mg.drawPoint(center[0], center[1], big?3:1);
                        mg.setColor(savedColor);
                    }

                    prevPrevVal = prevVal;
                    prevVal = thisVal;
                }

                if (scanDir < 0 && drawPrimalFlag)
                {
                    mg.setColor(java.awt.Color.yellow);
                    mg.drawPoint(centerX, centerY, 5);
                    if (centerY <= 0.)
                    {
                        System.out.println("HEY! centerY is "+centerY);
                    }
                    //assert(centerY > 0.);

                    {
                        // Part of the theorem I'm trying to prove
                        // says that:
                        //      |moment| <= |p| |d|^2 sin(2 t) / 4   
                        // i.e. |center| <= |p| |d|^2 sin(2 t) / (4*area)
                        // i.e. |center| <= |p| |d|^2 sin(2 t) / (2*twiceArea)
                        // I.e. it's in a certain pie slice, bounded by two rays
                        // and an arc.  Draw that arc.
                        double initialPrimalAng = (val+.5)/nParts*(Math.PI*.5); // dualAng is 0
                        double arcRadius = Math.sin(2*initialPrimalAng) / (2*twiceArea) * scale;
                        mg.setColor(java.awt.Color.yellow);
                        mg.drawThickArc(-arcRadius,-arcRadius,
                                        2*arcRadius,2*arcRadius,
                                        0., // startRadians
                                        initialPrimalAng, // arcRadians
                                        1., // thickness in pixels
                                        antiAliasFlag);


                        // well hell, that actually wasn't very interesting.
                        // let's actually do the actual moment and arc too, in magenta.
                        // (scaled so max possible is 1).
                        mg.setColor(java.awt.Color.magenta);
                        arcRadius = Math.sin(2*initialPrimalAng) * scale;
                        mg.drawPoint(centerX*(2*twiceArea),centerY*(2*twiceArea),5);
                        mg.drawThickArc(-arcRadius,-arcRadius,
                                        2*arcRadius,2*arcRadius,
                                        0., // startRadians
                                        initialPrimalAng, // arcRadians
                                        1., // thickness in pixels
                                        antiAliasFlag);
                    }

                }

            } // for iScanDir

            if (debugLevel >= 1) System.out.println("    out drawSpiral "+(drawPrimalFlag?"primal":"")+(drawDualFlag?"dual":"")+(drawRungsFlag?",rungs":""));
            return returnValue;
        } // drawSpiral


        private void accelBackward()
        {
            boolean startAnimationFlag = theSpiralView.focusAnimationVelocity.n == 0;
            theSpiralView.focusAnimationVelocity.minusEquals(theSpiralView.focusQuantum);
            if (startAnimationFlag)
                startTheAnimation();
        }
        private void stepBackward()
        {
            theSpiralView.focusAnimationVelocity.set(0,1);
            theSpiralView.focus.minusEquals(theSpiralView.focusQuantum);
            theSpiralView.focus.modEquals(theSpiralModel.params.n.get(), 1);
            theCanvas.repaint();
        }
        private void pause()
        {
            theSpiralView.focusAnimationVelocity.set(0,1);
            theCanvas.repaint();
        }
        private void stepForward()
        {
            theSpiralView.focusAnimationVelocity.set(0,1);
            theSpiralView.focus.plusEquals(theSpiralView.focusQuantum);
            theSpiralView.focus.modEquals(theSpiralModel.params.n.get(), 1);
            theCanvas.repaint();
        }
        private void accelForward()
        {
            boolean startAnimationFlag = theSpiralView.focusAnimationVelocity.n == 0;
            theSpiralView.focusAnimationVelocity.plusEquals(theSpiralView.focusQuantum);
            if (startAnimationFlag)
                startTheAnimation();
        }

        // actually this should probably be in a listener on focusAnimationVelocity
        // I probably have the thread-safety all wrong too
        // but then again I probably have it wrong for paint as well...
        // XXX paint really needs to take a synchronized snapshot of everything it needs, I think...
        // and, acquire a lock on the big things that don't change often but that are too expensive to snapshot
        // (the model).
        private javax.swing.Timer theTimer = null;
        javafx.animation.AnimationTimer theAnimationTimer = null;
        private void startTheAnimation()
        {
            System.out.println("in startTheAnimation");
            if (!useJavaFX)
            {
                if (theTimer == null)
                {
                    System.out.println("    creating timer");
                    theTimer = new javax.swing.Timer(animSleepMS.get(), new java.awt.event.ActionListener() {
                        public void actionPerformed(java.awt.event.ActionEvent e) {
                            if (eventVerbose >= 1) System.out.println("in timer action");

                            // TODO: make a synchronizedGet() and synchronizedSet() method to facilitate this?
                            boolean focusAnimationVelocityIsZero;
                            synchronized(theSpiralView.focusAnimationVelocity)
                            {
                                focusAnimationVelocityIsZero = (theSpiralView.focusAnimationVelocity.n == 0);
                            }
                            if (focusAnimationVelocityIsZero)
                            {
                                System.out.println("    stopping timer");
                                theTimer.stop();
                            }

                            theCanvas.repaint();
                            int animSleepMSvalue = animSleepMS.get();
                            if (animSleepMSvalue >= 0)
                                theTimer.setDelay(animSleepMSvalue);

                            if (false) // can set this to true to make the timing graph show time between firings
                            {
                                double now = timingGraph.timeSeconds();
                                timingGraph.startTimes.set(timingGraph.startTimes.size()-1, now);
                                timingGraph.endTimes.set(timingGraph.endTimes.size()-1, now);
                            }
                            if (eventVerbose >= 1) System.out.println("out timer action");
                        }
                    });
                }
                System.out.println("    starting timer");
                theTimer.start();
            }
            if (useJavaFX)
            {
                if (theAnimationTimer == null)
                {
                    // interesting, see http://www.javamex.com/tutorials/threads/sleep.shtml for issues and bugs
                    System.out.println("    creating javafx animation timer");
                    theAnimationTimer = new javafx.animation.AnimationTimer() {
                        public void handle(long nanos)
                        {
                            if (eventVerbose >= 1) System.out.println("in timer action");

                            // TODO: make a synchronizedGet() and synchronizedSet() method to facilitate this?
                            boolean focusAnimationVelocityIsZero;
                            synchronized(theSpiralView.focusAnimationVelocity)
                            {
                                focusAnimationVelocityIsZero = (theSpiralView.focusAnimationVelocity.n == 0);
                            }
                            if (focusAnimationVelocityIsZero)
                            {
                                System.out.println("    stopping javafx animation timer");
                                theAnimationTimer.stop();
                            }


                            int animSleepMSvalue = animSleepMS.get();
                            try { Thread.sleep(MAX(animSleepMSvalue,0)); } catch (InterruptedException e) {}
                            theCanvas.repaint();


                            if (false) // can set this to true to make the timing graph show time between firings
                            {
                                double now = timingGraph.timeSeconds();
                                timingGraph.startTimes.set(timingGraph.startTimes.size()-1, now);
                                timingGraph.endTimes.set(timingGraph.endTimes.size()-1, now);
                            }
                            if (eventVerbose >= 1) System.out.println("out timer action");
                        }
                    };
                }
                System.out.println("    starting timer");
                theAnimationTimer.start();
            }
            System.out.println("out startTheAnimation");
        }


    //
    // App-specific variables...
    //


        public static boolean useJavaFX = true;
        public SpiralModel.Params spiralModelParams = new SpiralModel.Params(); // gui copy, flushed to model when Regenerate button pressed
        public SpiralModel theSpiralModel = new SpiralModel();
        public SpiralView theSpiralView = new SpiralView();
        public Listenable.Int animSleepMS = new Listenable.Int(0, 1000*1000, -1); // 11 seems to be empirical sweet spot when using javax.swing.Timer... still speeds up for a few frames every 5 seconds or so
        public Listenable.Boolean showTimingFlag = new Listenable.Boolean(false);
        public Listenable.Boolean showTickerFlag = new Listenable.Boolean(true);
        public Listenable.Boolean showSpiralFlag = new Listenable.Boolean(true);
        public Listenable.Boolean showStatsFlag = new Listenable.Boolean(false);
        public Listenable.Boolean showVsyncLapsesFlag = new Listenable.Boolean(false);
        public JRow focusInControlPanelRow = null;


        private java.awt.Component theCanvas = null;
        private javafx.scene.image.ImageView theImageView = null;
        //private java.awt.Component theHelpWindow = null;
        private JFrame theMainAppletWindow = null;
        private JFrame theControlPanelWindow = null;
        private JFrame theHelpWindow = null;
        private Listenable.String windowTitle = new Listenable.String("Spiral Applet");

        private Listenable.Listener showRungsFlagListener = null;
        private Listenable.Listener focusListener = null;
        private Listenable.Listener pixelsPerPartListener = null;
        private Listenable.Listener quantaPerPartListener = null;
        private Listenable.Listener showTimingFlagListener = null;
        private Listenable.Listener showTickerFlagListener = null;
        private Listenable.Listener showSpiralFlagListener = null;
        private Listenable.Listener showStatsFlagListener = null;


    //
    // Applet-generic member variables...
    //
        private GraphicsAntiAliasingSetter graphicsAntiAliasingSetter;
        private int eventVerbose = 0; // can set with eventVerbose=1 on command line
        private static int nonEventVerbose = 0; // so static classes can refer to it
        private boolean antiAliasingFlag = false;
        private boolean implementAntiAliasingInHardware = true; // XXX should have a better name for this-- really mean let java runtime do it
        private boolean doubleBufferFlag = false; // TODO: swing does this for us... can get rid of it, as soon as I figure out how to do the magnifying glass without it
        private java.awt.Image backBufferImage = null;
        private MyGraphics3D mostRecentGraphics = null;
        private int nPaints = 0;


    public static class JTextFieldForString extends JValidatingTextField
    {
        private Listenable.Listener listener; // need to keep a strong ref to it for as long as I'm alive
        public JTextFieldForString(final Listenable.String s)
        {
            super(s.get());
            s.addListener(listener = new Listenable.Listener() {
                public void valueChanged()
                {
                    setText(s.get());
                }
            });
            addActionListener(new java.awt.event.ActionListener() {
                public void actionPerformed(java.awt.event.ActionEvent e)
                {
                    s.set(getText());
                }
            });
        }
    } // JTextFieldForString



    // Stolen from MC4DControlPanel.java
    public static class JTextFieldForNumber extends JValidatingTextField
    {
        private Listenable.Listener listener; // need to keep a strong ref to it for as long as I'm alive
        private Listenable.Number f;

        // override super's
        public boolean validate(String text)
        {
            try {
                // attempt to parse, ignore return value
                if (f instanceof Listenable.Int)
                    Integer.parseInt(text);
                else
                    Double.parseDouble(text);
                return true;
            } catch (Exception e) {
                return false;
            }
        }

        // common code we call in a couple of places
        private void updateText(Listenable.Number f)
        {
            if (f instanceof Listenable.Int)
                setText(""+((Listenable.Int)f).get());
            else if (f instanceof Listenable.Float)
                setText(""+((Listenable.Float)f).get());
            else
                setText(""+(float)((Listenable.Double)f).get()); // XXX ARGH! we lose precision with this (float) cast, but if we don't do it, we can get, for example, 37.092999999999996 which looks lame.  should figure out another way to prevent that.
        }

        public JTextFieldForNumber(final Listenable.Number f)
        {
            super(f instanceof Listenable.Int ? ""+((Listenable.Int)f).max() // XXX not quite right, min may be longer string than max
                   : "99.99"); // give it enough space for 99.999 (on my computer, always seems to give an extra space, which we don't need)
            this.f = f;
            updateText(f);
            f.addListener(listener = new Listenable.Listener() {
                public void valueChanged()
                {
                    updateText(f);
                }
            });
            addActionListener(new java.awt.event.ActionListener() {
                public void actionPerformed(java.awt.event.ActionEvent e)
                {
                    try
                    {
                        f.setDouble(Double.valueOf(getText()).doubleValue());
                    }
                    catch (java.lang.NumberFormatException nfe)
                    {
                        // maybe should print an error message or something
                        updateText(f);
                    }
                }
            });
        }

        public java.awt.Dimension getPreferredSize()
        {
            //System.out.println("in JTextFieldForNumber.getPreferredSize()");
            // default seems taller than necessary
            // on my computer... and in recent VMs it's even worse
            // (changed from 29 to 31).
            // Fudge it a bit...
            // XXX not sure this will look good on all systems... if it doesn't, we can just remove it
            // XXX hmm, actually makes things mess up when growing and shrinking, that's weird
            java.awt.Dimension preferredSize = super.getPreferredSize();
            //System.out.println("textfield.super.preferredSize() = "+preferredSize);
            if (true)
                preferredSize.height -= 2;

            // XXX another hack, wtf?
            if (true)
            {
                if (f instanceof Listenable.Int)
                    preferredSize.width = 55; // big enough to hold 1,000,000 comfortably-- bleah
                else
                {
                    //preferredSize.width = 100;
                    preferredSize.width = 50; // for this app, this is plenty, although it's bogus in general
                }
            }

            //System.out.println("out JTextFieldForNumber.getPreferredSize(), returning "+preferredSize);
            return preferredSize;
        }
        // weird, the following is called during horizontal shrinking
        // but not during horizontal expanding... if we don't do this too
        // then it looks wrong when shrinking.  what a hack...
        public java.awt.Dimension getMinimumSize()
        {
            //System.out.println("in JTextFieldForNumber.getMinimumSize()");
            java.awt.Dimension minimumSize = super.getMinimumSize();
            //System.out.println("textfield.super.minimumSize() = "+minimumSize);
            if (true)
                minimumSize.height -= 2;

            // XXX another hack, wtf?
            if (true)
            {
                if (f instanceof Listenable.Int)
                    minimumSize.width = 55;
                else
                    minimumSize.width = 100;
            }

            //System.out.println("out JTextFieldForNumber.getMinimumSize(), returning "+minimumSize);
            return minimumSize;
        }
    } // JTextFieldForNumber


    public static class JCheckBoxForBoolean extends JCheckBox
    {
        private Listenable.Listener listener; // need to keep a strong ref to it for as long as I'm alive
        public JCheckBoxForBoolean(String name, final Listenable.Boolean b)
        {
            super(name);
            setSelected(b.get());
            addItemListener(new java.awt.event.ItemListener() {
                public void itemStateChanged(java.awt.event.ItemEvent e)
                {
                    b.set(isSelected());
                }
            });
            b.addListener(listener = new Listenable.Listener() {
                public void valueChanged()
                {
                    setSelected(b.get());
                }
            });
        }
    } // JCheckBoxForBoolean

    public static class JSliderForFloat extends JSlider
    {
        private Listenable.Listener listener; // need to keep a strong ref to it for as long as I'm alive

        // private helper function
        private void updateThumb(Listenable.Number f)
        {
            double value = f.getDouble();
            double defaultValue = f.defaultDouble();
            double frac = (value-f.minDouble())/(f.maxDouble()-f.minDouble());

            //setValue((int)(getMinimum() + ((getMaximum()-getVisibleAmount())-getMinimum())*frac));
            setValue((int)(getMinimum() + (getMaximum()-getMinimum())*frac));
        }

        public JSliderForFloat(final Listenable.Number f)
        {
            // 3 significant digits seems reasonable...
            /*
            super(JSlider.HORIZONTAL,
                  (int)Math.round(f.minDouble()*1000),
                  (int)Math.round(f.maxDouble()*1000),
                  (int)Math.round(f.getDouble())*1000);
            */
            super(JSlider.HORIZONTAL, 0, 1000, 500);

            if (false)
            {
                PRINT(getMinimum());
                PRINT(getMaximum());
                PRINT(getValue());
            }

            setMinorTickSpacing(1);  // .001 units
            setMajorTickSpacing(10); // .01 units
            f.addListener(listener = new Listenable.Listener() {
                public void valueChanged()
                {
                    updateThumb(f);
                }
            });
            addChangeListener(new javax.swing.event.ChangeListener() {
                public void stateChanged(javax.swing.event.ChangeEvent e)
                {
                    if (false)
                    {
                        System.out.println("==================");
                        System.out.println("    min = "+getMinimum());
                        System.out.println("    max = "+getMaximum());
                        System.out.println("    max-min = "+(getMaximum()-getMinimum()));
                        System.out.println("    getValue() = "+getValue());
                        System.out.println("    getMinorTickSpacing() = "+getMinorTickSpacing());
                        System.out.println("    getMajorTickSpacing() = "+getMajorTickSpacing());
                        System.out.println("    getSize() = "+getSize());
                        System.out.println("    getPreferredSize() = "+getPreferredSize());
                    }
                    // Doing the following in double precision makes a difference;
                    // if we do it in float, we get ugly values in the textfield
                    double frac = (double)(getValue()-getMinimum())
                                / (double)(getMaximum()-getMinimum());
                    f.setDouble(f.minDouble() + frac*(f.maxDouble()-f.minDouble()));
                    // will trigger valueChanged()
                    // which will call updateThumb()
                }
            });
            updateThumb(f); // because we fucked it up in the contructor?
        }
    } // JSliderForFloat

    // nice utility, maybe move to donhatchsw
    public static void drawPixmapCentered(java.awt.Graphics g,
                                          java.awt.Dimension size,
                                          java.awt.Color asciiToColor[],
                                          String[] rows)
    {
        if (false)
        {
            // hack-- pad with the color at 0,0
            g.setColor(asciiToColor[rows[0].charAt(0)]);
            PRINT(size.width);
            PRINT(size.height);
            g.fillRect(0,0, size.width,size.height);
        }

        int x0 = (size.width - rows[0].length())/2;
        int y0 = (size.height - rows.length)/2;
        java.awt.Color prevColor = null;
        FORI (iRow, rows.length)
        {
            String row = rows[iRow];
            int nCols = row.length();
            FORI (iCol, nCols)
            {
                char c = row.charAt(iCol);
                java.awt.Color color = asciiToColor[c];
                if (color != null)
                {
                    if (color != prevColor)
                    {
                        g.setColor(color);
                        prevColor = color;
                    }
                    g.fillRect(x0+iCol, y0+iRow, 1, 1);
                }
            }
        }
    } // drawPixmapCentered


    // make it like a JLabel as much as possible, but text selectable
    private static void makeTextComponentLikeLabel(JTextComponent textComponent)
    {
        textComponent.setEditable(false);
        textComponent.setDisabledTextColor(java.awt.Color.black);
        textComponent.setBackground(null); // same as JLabel
        textComponent.setBorder(null); // same as JLabel
        textComponent.setEnabled(true); // otherwise not selectable
    }

    static JRow makeIncrementableTextFieldForInt(final Listenable.Int f, final String name, final int increment)
    {
        final java.awt.Color asciiToColor[] = new java.awt.Color[128];
        asciiToColor[' '] = null;
        asciiToColor['b'] = java.awt.Color.black;
        return new JRow() {{
            add(new JRepeatingButton("") {
                public java.awt.Dimension getPreferredSize() { return new java.awt.Dimension(11,11); }
                public java.awt.Dimension getMinimumSize()   { return new java.awt.Dimension(11,11); }
                public void paint(java.awt.Graphics g)
                {
                    super.paint(g);
                    drawPixmapCentered(g, getSize(), asciiToColor,
                                       new String[] {
                                          "bbb bbb",
                                       });
                }
            {
                addActionListener(new java.awt.event.ActionListener() {
                    public void actionPerformed(java.awt.event.ActionEvent e)
                    {
                        f.set(f.get()-increment);
                    }
                });
                setToolTipText("<html>decrement "+name+"</html>");
            }});
            add(new JTextFieldForNumber(f) {{
                setToolTipText("<html>"+name+"</html>");
            }} );
            add(new JRepeatingButton("") {
                public java.awt.Dimension getPreferredSize() { return new java.awt.Dimension(11,11); }
                public java.awt.Dimension getMinimumSize()   { return new java.awt.Dimension(11,11); }
                public void paint(java.awt.Graphics g)
                {
                    super.paint(g);
                    drawPixmapCentered(g, getSize(), asciiToColor,
                                       new String[] {
                                          " b   b ",
                                          "bbb bbb",
                                          " b   b ",
                                       });
                }
            {
                addActionListener(new java.awt.event.ActionListener() {
                    public void actionPerformed(java.awt.event.ActionEvent e)
                    {
                        f.set(f.get()+increment);
                    }
                });
                setToolTipText("<html>increment "+name+"</html>");
            }});
        }};
    } // makeIncrementableTextFieldForNumber






    private static java.lang.reflect.Method nanoTimeMethod = null;
    {
        try {
            nanoTimeMethod = System.class.getMethod("nanoTime", new Class[]{});
        }
        catch (NoSuchMethodException e) {System.out.println("no such method exception!");}
    }
    // System.nanoTime().
    // don't call this unless you know nanoTimeMethod != null.
    private static long System_nanoTime()
    {
        try {
            // object allocation here is a bummer.
            // maybe better to compile using javac >= 1.4
            // but with flag saying create class files for earlier jvm?
            Object answer = nanoTimeMethod.invoke(null, new Object[]{});
            return ((Long)answer).longValue();
        }
        catch (IllegalAccessException e) {assert(false); return 0L;}
        catch (java.lang.reflect.InvocationTargetException e) {assert(false); return 0L;}
    }

    // Time in seconds from when we initialize the times,
    // using System.nanoTime() if it exists (jvm >= 1.4),
    // otherwise System.currentTimeMillis().
    private static double timeSeconds()
    {
        boolean useNanoTime = (nanoTimeMethod != null);
        if (useNanoTime)
            return (double)(System_nanoTime() - nanos0) / 1e9;
        else
            return (double)(System.currentTimeMillis() - millis0) / 1e3;
    }

    private static long millis0 = System.currentTimeMillis();
    private static long nanos0 = (nanoTimeMethod!=null ? System_nanoTime() : 0L);




    //
    // Main...
    //
    public static void main(final String args[])
    {
        if (true)
        {
            Rational.confidenceTest();
        }
        if (false) // turn this on to get a crude little timing test
        {
            if (nanoTimeMethod != null)
            {
                FORI (ii,100)
                {
                    {
                        long m0 = System.currentTimeMillis();
                        long n0 = System_nanoTime();
                        FORI (i, 999)
                            System.currentTimeMillis();
                        long m1 = System.currentTimeMillis();
                        long n1 = System_nanoTime();
                        System.out.println("1000 m's and 1 n: "+(m1-m0)+" m");
                        System.out.println("1000 m's and 1 n: "+(n1-n0)+" n");
                    }
                    {
                        long n0 = System_nanoTime();
                        long m0 = System.currentTimeMillis();
                        FORI (i, 999)
                            System.currentTimeMillis();
                        long n1 = System_nanoTime();
                        long m1 = System.currentTimeMillis();
                        System.out.println("1000 m's and 1 n: "+(m1-m0)+" m");
                        System.out.println("1000 m's and 1 n: "+(n1-n0)+" n");
                    }
                }
                FORI (ii,100)
                {
                    {
                        long m0 = System.currentTimeMillis();
                        long n0 = System_nanoTime();
                        FORI (i, 999)
                            System_nanoTime();
                        long m1 = System.currentTimeMillis();
                        long n1 = System_nanoTime();
                        System.out.println("1 m and 1000 n's: "+(m1-m0)+" m");
                        System.out.println("1 m and 1000 n's: "+(n1-n0)+" n");
                    }
                    {
                        long n0 = System_nanoTime();
                        long m0 = System.currentTimeMillis();
                        FORI (i, 999)
                            System_nanoTime();
                        long n1 = System_nanoTime();
                        long m1 = System.currentTimeMillis();
                        System.out.println("1 m and 1000 n's: "+(m1-m0)+" m");
                        System.out.println("1 m and 1000 n's: "+(n1-n0)+" n");
                    }
                }

                System.out.println();
                System.exit(0);
            }
        }
        if (false)
        {
            // http://stackoverflow.com/questions/12805373/java-modulo-operator
            // surprising!
            //PRINT(fmod(5.59, 2));
            PRINT(5.59 % 2); // 1.5899999999999999
            PRINT(5.59 - 2); // 3.59
            PRINT(5.59 - 4); // 1.5899999999999999
            PRINT(5.59 - 2 - 2); // 1.5899999999999999
            PRINT(5.59); // 5.59
            PRINT(3.59); // 3.59
            PRINT(1.59); // 1.59
        }

        System.out.println("in main");
        System.out.println("    java "+System.getProperty("java.version"));


        final SpiralApplet applet = new SpiralApplet();

        final JFrame frame = new JFrame(applet.windowTitle.get());

        // TODO: what was I thinking?  can't use 1.2 any more?? need to use reflection to see whether I can do this
        //frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); // supposedly exists since java 1.4, but I can see starting in 1.3, weird
        frame.getContentPane().add(applet);

        //dumpComponentHierarchy(frame, 0, 0, 1);

        // the following seems to be necessary, or getParameter() will crash, at least in 1.4.  Want to send params from command line anyway.
        applet.setStub(new java.applet.AppletStub() {
             public void appletResize(int width, int height)
                 { /* should resize frame, but a SpiralApplet never asks to be resized */ }
             public java.applet.AppletContext getAppletContext() { return null;}
             public java.net.URL getCodeBase() { return null; }
             public java.net.URL getDocumentBase() { return null; }
             public String getParameter(String name)
             {
                 // case insensitive... and unfortunately there's no
                 // startsWithIgnoreCase
                 String prefix = name.toLowerCase() + "=";
                 int i;
                 FOR (i, args.length)
                     if (args[i].toLowerCase().startsWith(prefix))
                         return args[i].substring(prefix.length());
                 return null;
             }
             public boolean isActive() { return true; }
        });

        applet.init();
        applet.start();

        frame.setLocation(10, 10);
        frame.setSize(601,600);
        frame.setSize(718,583);
        frame.setSize(500,600);

        frame.setVisible(true);

        applet.theMainAppletWindow = frame;


        // for benefit of any debugging function that wants to loop over frames...
        applet.theControlPanelWindow.setName("control panel window");
        applet.theMainAppletWindow.setName("main applet window");
        applet.theHelpWindow.setName("help");

        if (useJavaFX)
        {
            // creating a JFXPanel implicitly starts the JavaFX runtime.
            // unless we do this, the AnimationTimer will be non-functional!
            System.out.println("initializing javafx...");
            new javafx.embed.swing.JFXPanel();
            System.out.println("done.");
        }


        // do the timing workaround suggested in http://www.javamex.com/tutorials/threads/sleep_issues.shtml
        if (true)
        {
            Thread thread = new Thread(new Runnable() {
                public void run()
                {
                    System.out.println("in thread run");
                    System.out.println("    sleeping forever");
                    try { Thread.sleep(Long.MAX_VALUE); } catch (InterruptedException e) {}
                    assert(false);
                    System.out.println("out thread run");
                    System.exit(1);
                }
            });
            thread.setDaemon(true); // make it so the java vm won't wait for it to finish before exiting
            thread.start();
        }

        // why can't we get here in any toolkit ever?
        System.out.println("out main");
    } // main

} // class SpiralApplet
