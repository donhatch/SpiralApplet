/*
    Notes:
        Uses System.nanoTime which requires java >= 1.4

    BUG: on assert fail in paint, displayed line number is too small by a few lines
    BUG: bad ticker anim when pixelsPerIncr = 4
    BUG: ending criteria isn't quite right-- should end when *all* contributing things have gone off screen or become tiny, need to clean up logic for that
    BUG: as soon as a tooltip is shown, performance went down, forevermore??
    TODO: smooth out animation when going very slowly
    TODO: gui for scale
    TODO: upgrade to >=1.5 and use templates
    TODO: upgrade to >=1.4 and use System.nanoTime
    TODO: check out LWJGL for consistent frame rate?
    TODO: maybe JavaFX? she says it works well for vsync: http://www.java-gaming.org/index.php?topic=27763.0.  ah good, it's included in jdk 7.
    TODO: use javax.swing.Timer instead of my own custom thread
          WHOA! as soon as I switched to a timer, I'm getting consistent timings! nice 60fps. wtf?
          well except every 5 seconds or so, it gives far faster for a few frames in a row. argh!
          sleeping for 11 ms seems to be a sweet spot.  screwy.
*/

#include "macros.h"

// So can compile in pre-1.4,
// we use these instead of java.awt.event.MouseEvent.BUTTON1 etc.
#define java_awt_event_MouseEvent_BUTTON1 1
#define java_awt_event_MouseEvent_BUTTON2 2
#define java_awt_event_MouseEvent_BUTTON3 3

//import com.donhatchsw.util.Arrays;
import com.donhatchsw.util.MyMath;
import com.donhatchsw.util.VecMath;
//import com.donhatchsw.util.SortStuff;
import com.donhatchsw.util.Listenable;
import com.donhatchsw.compat.ArrayList;
//import com.donhatchsw.compat.IntArrayList;
//import com.donhatchsw.compat.DoubleArrayList;

import com.donhatchsw.awt.ColLayout;
import com.donhatchsw.awt.JRow;
import com.donhatchsw.awt.JCol;
import com.donhatchsw.awt.JTablePanel;

import javax.swing.ButtonGroup;
import javax.swing.JFrame;
import javax.swing.JPanel;
import javax.swing.JApplet;
import javax.swing.JLabel;
import javax.swing.JButton;
import javax.swing.JRadioButton;
import javax.swing.text.JTextComponent;
import javax.swing.JTextField;
import javax.swing.JTextArea;
import javax.swing.JToggleButton;
import javax.swing.JScrollPane;
import javax.swing.JSeparator;
import javax.swing.JSlider;
import javax.swing.JMenuBar;
import javax.swing.JMenu;
import javax.swing.JMenuItem;
//import javax.swing.JComboBox;
import javax.swing.JCheckBox;


public class SpiralApplet
    extends JApplet
{
    //
    // Utilities for applet stuff...
    //
        private String getParameterString(String paramName,
                                       String defaultValue)
        {
            String paramValueString = getParameter(paramName);
            if (paramValueString != null)
                return paramValueString;
            else
                return defaultValue;
        }
        private int getParameterInt(String paramName,
                                    int defaultValue)
        {
            String paramValueString = getParameter(paramName);
            if (paramValueString != null)
            {
                try
                {
                    return Integer.decode(paramValueString).intValue();
                }
                catch (NumberFormatException e)
                {
                    return 0;
                }
            }
            else
                return defaultValue;
        }
        private double getParameterDouble(String paramName,
                                          double defaultValue)
        {
            String paramValueString = getParameter(paramName);
            if (paramValueString != null)
            {
                try
                {
                    return Double.parseDouble(paramValueString);
                }
                catch (NumberFormatException e)
                {
                    return 0;
                }
            }
            else
                return defaultValue;
        }
        private boolean getParameterBoolean(String paramName,
                                            boolean defaultValue)
        {
            String paramValueString = getParameter(paramName);
            if (paramValueString != null)
            {
                // Too simplistic, only honors case-sensitive "true"
                //return Boolean.valueOf(paramValueString).booleanValue();

                try
                {
                    int n = Integer.decode(paramValueString).intValue();
                    return n != 0;
                }
                catch (NumberFormatException e)
                {
                    if (paramValueString.equalsIgnoreCase("true")
                     || paramValueString.equalsIgnoreCase("yes")
                     || paramValueString.equalsIgnoreCase("t")
                     || paramValueString.equalsIgnoreCase("y"))
                        return true;
                    return false;
                }
            }
            else
                return defaultValue;
        }

        // ButtonGroup doesn't support *at most* one checked.
        // Implement one that does.
        private static class ButtonGroupThatAllowsNone
        {
            private ArrayList buttons = new ArrayList();
            private ArrayList actionListeners = new ArrayList();
            public void add(final JToggleButton button) // checkbox or radio button
            {
                java.awt.event.ActionListener actionListener = new java.awt.event.ActionListener() {
                    public void actionPerformed(java.awt.event.ActionEvent e)
                    {
                        if (button.isSelected())
                        {
                            // then deselect everyone else
                            int nButtons = buttons.size();
                            for (int i = 0; i < nButtons; ++i)
                            {
                                JToggleButton otherButton = (JToggleButton)buttons.get(i);
                                if (otherButton != button)
                                    if (otherButton.isSelected())
                                        otherButton.setSelected(false);
                            }
                        }
                    }
                };
                button.addActionListener(actionListener);
                buttons.add(button);
                actionListeners.add(actionListener);
            }
        }; // class ButtonGroupThatAllowsNone
        // That was fun, let's make another that enforces
        // that the selection is a prefix of the set of buttons.
        private static class PrefixButtonGroup
        {
            private ArrayList buttons = new ArrayList();
            private ArrayList actionListeners = new ArrayList();
            public void add(final JToggleButton button) // checkbox or radio button
            {
                java.awt.event.ActionListener actionListener = new java.awt.event.ActionListener() {
                    public void actionPerformed(java.awt.event.ActionEvent e)
                    {
                        int nButtons = buttons.size();
                        if (button.isSelected())
                        {
                            // then select everyone before me
                            FORI (i, nButtons)
                            {
                                JToggleButton otherButton = (JToggleButton)buttons.get(i);
                                if (otherButton == button)
                                    break;
                                if (!otherButton.isSelected())
                                    otherButton.setSelected(true);
                            }
                        }
                        else
                        {
                            // deselect everyone after me
                            FORIDOWN(i, nButtons)
                            {
                                JToggleButton otherButton = (JToggleButton)buttons.get(i);
                                if (otherButton == button)
                                    break;
                                if (otherButton.isSelected())
                                    otherButton.setSelected(false);
                            }
                        }
                    }
                };
                button.addActionListener(actionListener);
                buttons.add(button);
                actionListeners.add(actionListener);
            }
        } // PrefixButtonGroup

        // http://tech-eureka.blogspot.com/2010/12/how-to-implement-repeating-swing.html
        private static class JRepeatingButton extends JButton
        {
            public JRepeatingButton(String text)
            {
                super(text);
            }
            public void addActionListener(final java.awt.event.ActionListener actionListener)
            {
                addMouseListener(new java.awt.event.MouseAdapter() {
                    private javax.swing.Timer repeatTimer = null;
                    private java.awt.event.ActionEvent synthesizedActionEvent = null;
                    public void mousePressed(java.awt.event.MouseEvent mouseEvent)
                    {
                        synthesizedActionEvent = new java.awt.event.ActionEvent(
                            JRepeatingButton.this,
                            java.awt.event.ActionEvent.ACTION_PERFORMED,
                            JRepeatingButton.this.getText(),
                            mouseEvent.getModifiers());
                        // the ctor that takes "when" introduced some time in (1.3, 1.6]
                        // so don't use it, so we can compile using 1.3
                        actionListener.actionPerformed(synthesizedActionEvent); // initial execution

                        repeatTimer = new javax.swing.Timer(100, new java.awt.event.ActionListener() {
                            public void actionPerformed(java.awt.event.ActionEvent timerActionEvent)
                            {
                                actionListener.actionPerformed(synthesizedActionEvent);
                            }
                        });
                        repeatTimer.setInitialDelay(500);
                        repeatTimer.start();
                    }
                    public void mouseReleased(java.awt.event.MouseEvent arg0)
                    {
                        repeatTimer.stop();
                        repeatTimer = null;
                        synthesizedActionEvent = null;
                    }
                });
            }
        } // JRepeatingButton

        // A textfield that turns green or red when editing and not yet committed.
        // Esc reverts.
        private static class JValidatingTextField extends JTextField
        {
            // subclass can override this
            public boolean validate(String text)
            {
                return true; // it's all good by default
            }

            private String committedText;
            public JValidatingTextField(String text)
            {
                super(text);
                committedText = getText();

                getDocument().addDocumentListener(new javax.swing.event.DocumentListener() {
                    private void anyUpdate(javax.swing.event.DocumentEvent e)
                    {
                        if (isEditable()) // use this as hint-- if not editable, probably makeTextComponentLikeLabel was called
                        {
                            if (!getText().equals(committedText)) // TODO: == doesn't work here?  I forget the difference
                            {
                                if (validate(getText()))
                                {
                                    // TODO: if value semantically equals committed value, turn white instead.  hmm, can build this into validate() by having it return a value (Object), maybe?
                                    setBackground(new java.awt.Color(192,255,192)); // light green
                                }
                                else
                                    setBackground(new java.awt.Color(255,192,192)); // pink
                            }
                            else
                                setBackground(java.awt.Color.white);
                        }
                    }
                    public void insertUpdate(javax.swing.event.DocumentEvent e)  {anyUpdate(e);}
                    public void removeUpdate(javax.swing.event.DocumentEvent e)  {anyUpdate(e);}
                    public void changedUpdate(javax.swing.event.DocumentEvent e) {anyUpdate(e);}
                });
                addKeyListener(new java.awt.event.KeyAdapter() {
                    public void keyPressed(java.awt.event.KeyEvent e)
                    {
                        if (e.getKeyCode() == java.awt.event.KeyEvent.VK_ESCAPE)
                        {
                            setText(committedText);
                        }
                    }
                });
                addActionListener(new java.awt.event.ActionListener() {
                    public void actionPerformed(java.awt.event.ActionEvent e)
                    {
                        if (validate(getText()))
                        {
                            committedText = getText();
                            setBackground(java.awt.Color.white);
                        }
                    }
                });
            }
            public void setText(String text)
            {
                super.setText(text);
                if (isEditable()) // use this as hint-- if not editable, probably makeTextComponentLikeLabel was called
                {
                    if (validate(getText()))
                    {
                        committedText = getText();
                        setBackground(java.awt.Color.white);
                    }
                }
            }
        } // JValidatingTextField


        private static class SpiralAppletControlPanel
            extends JPanel
        {
            public SpiralAppletControlPanel(final SpiralApplet applet)
            {
                java.awt.Container contentPane = this;

                contentPane.setLayout(new ColLayout());

                // used as "fill" argument to add()
                final java.awt.GridBagConstraints stretchx = new java.awt.GridBagConstraints(){{fill=HORIZONTAL;weightx=1.;}};
                final java.awt.GridBagConstraints stretchy = new java.awt.GridBagConstraints(){{fill=VERTICAL;weighty=1.;}};
                final java.awt.GridBagConstraints stretchxy = new java.awt.GridBagConstraints(){{fill=BOTH;weightx=weighty=1.;}};
                final java.awt.GridBagConstraints rightjustify = new java.awt.GridBagConstraints(){{anchor=EAST;}};
                final java.awt.GridBagConstraints centerjustify = new java.awt.GridBagConstraints(){{anchor=CENTER;}};

                // used as arg to setMargin()
                final java.awt.Insets nomargin = new java.awt.Insets(0,0,0,0);


                final java.awt.Color asciiToColor[] = new java.awt.Color[128];
                asciiToColor[' '] = null;
                asciiToColor['b'] = java.awt.Color.black;


                /*
                contentPane.add(new JSeparator(), stretchx);
                contentPane.add(new JLabel("File/Edit"));
                add(new JRow() {{
                    add(new JLabel("        ")); // indent a bit
                    add(new JCol() {{
                        // ...
                    }});
                }});
                */
                contentPane.add(new JSeparator(), stretchx);
                contentPane.add(new JLabel("Model"));
                add(new JRow() {{
                    add(new JLabel("        ")); // indent a bit
                    add(new JCol() {{
                        add(new JTablePanel() {{
                            add(new JLabel("Period:"));
                            add(makeIncrementableTextFieldForInt(applet.spiralModelParams.n, "period", 1));
                            add(new JLabel(" "));
                            add(new JTextFieldForNumber(applet.theSpiralModel.params.n) {{
                                makeTextComponentLikeLabel(this);
                            }});
                            advanceRow();
                            add(new JLabel("Number of parts:"));
                            add(makeIncrementableTextFieldForInt(applet.spiralModelParams.nParts, "number of parts", 1));
                            add(new JLabel(" "));
                            add(new JTextFieldForNumber(applet.theSpiralModel.params.nParts) {{
                                makeTextComponentLikeLabel(this);
                            }});
                            advanceRow();
                            add(new JLabel("Random seed:"));

                            add(makeIncrementableTextFieldForInt(applet.spiralModelParams.randomSeed, "seed", 1));
                            add(new JLabel(" "));
                            add(new JTextFieldForNumber(applet.theSpiralModel.params.randomSeed) {{
                                makeTextComponentLikeLabel(this);
                            }});
                        }});
                        add(new JRow() {
                            private ButtonGroup buttonGroup = new ButtonGroup();
                        {
                            add(new JLabel("Delta style:"));
                            add(new JLabel("  "));
                            add(new JRadioButton("<html>&plusmn;1</html>", applet.spiralModelParams.deltaStyle.get()==SpiralModel.DELTASTYLE_1) {{
                                setMargin(nomargin);
                                buttonGroup.add(this);
                                addActionListener(new java.awt.event.ActionListener() {
                                    public void actionPerformed(java.awt.event.ActionEvent e)
                                    {
                                        applet.spiralModelParams.deltaStyle.set(SpiralModel.DELTASTYLE_1);
                                        // no need to repaint
                                    }
                                });
                            }});
                            add(new JRadioButton("Any", applet.spiralModelParams.deltaStyle.get()==SpiralModel.DELTASTYLE_ANY) {{
                                setMargin(nomargin);
                                buttonGroup.add(this);
                                addActionListener(new java.awt.event.ActionListener() {
                                    public void actionPerformed(java.awt.event.ActionEvent e)
                                    {
                                        applet.spiralModelParams.deltaStyle.set(SpiralModel.DELTASTYLE_ANY);
                                        // no need to repaint
                                    }
                                });
                            }});
                        }});

                        add(new JButton("Regenerate") {{
                            setMargin(nomargin);
                            // XXX TODO: red if params out of date
                            addActionListener(new java.awt.event.ActionListener() {
                                public void actionPerformed(java.awt.event.ActionEvent e)
                                {
                                    applet.theSpiralModel.init(applet.spiralModelParams.n.get(), applet.spiralModelParams.nParts.get(), applet.spiralModelParams.deltaStyle.get(), applet.spiralModelParams.randomSeed.get());
                                    applet.theSpiralView.focus.set(fmod(applet.theSpiralView.focus.get(), applet.theSpiralModel.params.n.get()));

                                    applet.theCanvas.repaint();
                                }
                            });
                        }});
                    }});
                }});
                contentPane.add(new JSeparator(), stretchx);
                contentPane.add(new JLabel("View"));
                add(new JRow() {{
                    add(new JLabel("        ")); // indent a bit
                    add(new JRow() {{
                        add(new JCol() {{
                            add(new JRow() {{
                                add(new JButton("reset focus") {{
                                    setMargin(nomargin);
                                    addActionListener(new java.awt.event.ActionListener() {
                                        public void actionPerformed(java.awt.event.ActionEvent e)
                                        {
                                            applet.theSpiralView.focus.set(0.);
                                            applet.theCanvas.repaint();
                                        }
                                    });
                                }}, centerjustify);

                                if (true) // can make it visible/invisible on the fly with the "show focus in control panel" debug checkbox
                                    add(applet.focusInControlPanelRow = new JRow() {{
                                        add(new JLabel(" focus: "));
                                        add(new JTextFieldForNumber(applet.theSpiralView.focus){{
                                            makeTextComponentLikeLabel(this);
                                        }});
                                    }});
                            }});
                            add(new JRow() {{
                                add(new JRepeatingButton("") {
                                    public java.awt.Dimension getPreferredSize() { return new java.awt.Dimension(20,20); }
                                    public java.awt.Dimension getMinimumSize()   { return new java.awt.Dimension(20,20); }
                                    public void paint(java.awt.Graphics g)
                                    {
                                        super.paint(g);
                                        drawPixmapCentered(g, getSize(), asciiToColor,
                                                           new String[] {
                                                              "   b  b",
                                                              "  bb bb",
                                                              " bbbbbb",
                                                              "bbbbbbb",
                                                              " bbbbbb",
                                                              "  bb bb",
                                                              "   b  b",
                                                           });
                                    }
                                {
                                    addActionListener(new java.awt.event.ActionListener() {
                                        public void actionPerformed(java.awt.event.ActionEvent e)
                                        {
                                            applet.accelBackward();
                                        }
                                    });
                                    setToolTipText("<html>accelerate backward</html>");
                                }}, stretchxy);
                                add(new JRepeatingButton("") {
                                    public java.awt.Dimension getPreferredSize() { return new java.awt.Dimension(20,20); }
                                    public java.awt.Dimension getMinimumSize()   { return new java.awt.Dimension(20,20); }
                                    public void paint(java.awt.Graphics g)
                                    {
                                        super.paint(g);
                                        drawPixmapCentered(g, getSize(), asciiToColor,
                                                           new String[] {
                                                              "   b bb",
                                                              "  bb bb",
                                                              " bbb bb",
                                                              "bbbb bb",
                                                              " bbb bb",
                                                              "  bb bb",
                                                              "   b bb",
                                                           });
                                    }
                                {
                                    addActionListener(new java.awt.event.ActionListener() {
                                        public void actionPerformed(java.awt.event.ActionEvent e)
                                        {
                                            applet.stepBackward();
                                        }
                                    });
                                    setToolTipText("<html>step backward</html>");
                                }}, stretchxy);
                                add(new JRepeatingButton("") {
                                    public java.awt.Dimension getPreferredSize() { return new java.awt.Dimension(20,20); }
                                    public java.awt.Dimension getMinimumSize()   { return new java.awt.Dimension(20,20); }
                                    public void paint(java.awt.Graphics g)
                                    {
                                        super.paint(g);
                                        drawPixmapCentered(g, getSize(), asciiToColor,
                                                           new String[] {
                                                              "bbb bbb",
                                                              "bbb bbb",
                                                              "bbb bbb",
                                                              "bbb bbb",
                                                              "bbb bbb",
                                                              "bbb bbb",
                                                              "bbb bbb",
                                                           });
                                    }
                                {
                                    addActionListener(new java.awt.event.ActionListener() {
                                        public void actionPerformed(java.awt.event.ActionEvent e)
                                        {
                                            applet.pause();
                                        }
                                    });
                                    setToolTipText("<html>stop</html>");
                                }}, stretchxy);
                                add(new JRepeatingButton("") {
                                    public java.awt.Dimension getPreferredSize() { return new java.awt.Dimension(20,20); }
                                    public java.awt.Dimension getMinimumSize()   { return new java.awt.Dimension(20,20); }
                                    public void paint(java.awt.Graphics g)
                                    {
                                        super.paint(g);
                                        drawPixmapCentered(g, getSize(), asciiToColor,
                                                           new String[] {
                                                              "bb b   ",
                                                              "bb bb  ",
                                                              "bb bbb ",
                                                              "bb bbbb",
                                                              "bb bbb ",
                                                              "bb bb  ",
                                                              "bb b   ",
                                                           });
                                    }
                                {
                                    addActionListener(new java.awt.event.ActionListener() {
                                        public void actionPerformed(java.awt.event.ActionEvent e)
                                        {
                                            applet.stepForward();
                                        }
                                    });
                                    setToolTipText("<html>step forward</html>");
                                }}, stretchxy);
                                add(new JRepeatingButton("") {
                                    public java.awt.Dimension getPreferredSize() { return new java.awt.Dimension(20,20); }
                                    public java.awt.Dimension getMinimumSize()   { return new java.awt.Dimension(20,20); }
                                    public void paint(java.awt.Graphics g)
                                    {
                                        super.paint(g);
                                        drawPixmapCentered(g, getSize(), asciiToColor,
                                                           new String[] {
                                                              "b  b   ",
                                                              "bb bb  ",
                                                              "bbbbbb ",
                                                              "bbbbbbb",
                                                              "bbbbbb ",
                                                              "bb bb  ",
                                                              "b  b   ",
                                                           });
                                    }
                                {
                                    addActionListener(new java.awt.event.ActionListener() {
                                        public void actionPerformed(java.awt.event.ActionEvent e)
                                        {
                                            applet.accelForward();
                                        }
                                    });
                                    setToolTipText("<html>accelerate forward</html>");
                                }}, stretchxy);
                            }});
                        }});
                        add(new JLabel("    "));
                        add(new JCol() {{
                            add(new JTablePanel() {{
                                add(new JLabel("Anim sleep ms:"));
                                add(makeIncrementableTextFieldForInt(applet.animSleepMS, "anim sleep ms", 1));
                                advanceRow();
                                add(new JLabel("Pixels per part:"));
                                add(makeIncrementableTextFieldForInt(applet.theSpiralView.pixelsPerPart, "pixels per part", 1));
                            }});
                            add(new JCheckBoxForBoolean("rungs", applet.theSpiralView.showRungsFlag) {{
                                setMargin(nomargin);
                            }});
                        }});
                    }});
                }});
                contentPane.add(new JSeparator(), stretchx);
                contentPane.add(new JLabel("Debug"));
                add(new JRow() {{
                    add(new JLabel("        ")); // indent a bit
                    add(new JCol() {{
                        add(new JCheckBoxForBoolean("show timing", applet.showTimingFlag) {{
                            setMargin(nomargin);
                        }});
                        add(new JCheckBoxForBoolean("show model", applet.showNonTimingFlag) {{
                            setMargin(nomargin);
                        }});
                        add(new JCheckBoxForBoolean("show focus in control panel", applet.showFocusInControlPanelFlag) {{
                            setMargin(nomargin);
                        }});
                        add(new JCheckBoxForBoolean("print vsync lapses", applet.showVsyncLapsesFlag) {{
                            setMargin(nomargin);
                            setToolTipText("<html>if this is set, print whenever vsync lapse seems to be happening (assumes mostly 60hz framerate)</html>");
                        }});
                        add(new JRow() {{
                            add(new JButton("Dump window positions and sizes") {{
                                setMargin(nomargin);
                                addActionListener(new java.awt.event.ActionListener() {
                                    public void actionPerformed(java.awt.event.ActionEvent e)
                                    {
                                        System.out.println("----------------");
                                        System.out.println("      main applet: "+applet.theMainAppletWindow.getWidth()+"x"+applet.theMainAppletWindow.getHeight()+"+"+applet.theMainAppletWindow.getX()+"+"+applet.theMainAppletWindow.getY()+"");
                                        System.out.println("    control panel: "+applet.theControlPanelWindow.getWidth()+"x"+applet.theControlPanelWindow.getHeight()+"+"+applet.theControlPanelWindow.getX()+"+"+applet.theControlPanelWindow.getY()+"");
                                        System.out.println("             help: "+applet.theHelpWindow.getWidth()+"x"+applet.theHelpWindow.getHeight()+"+"+applet.theHelpWindow.getX()+"+"+applet.theHelpWindow.getY()+"");
                                        System.out.println("----------------");
                                    }
                                });
                            }});
                        }});
                        add(new JRow() {{


                            add(new JLabel("Window title:"));
                            add(new JTextFieldForString(applet.windowTitle) {
                                public java.awt.Dimension getPreferredSize()
                                {
                                    java.awt.Dimension superSize = super.getPreferredSize();
                                    // TODO: who owns it? can I tweak it and return it?
                                    return new java.awt.Dimension(200, superSize.height);
                                }
                                // weird, getPreferredSize seems adequate when returning 100... but when returning 200, it turns to zero!? unless we also provide getMinimumSize
                                public java.awt.Dimension getMinimumSize()
                                {
                                    return getPreferredSize();
                                }
                            });
                        }});
                    }});
                }});
                contentPane.add(new JSeparator(), stretchx);

                //randomlyColorize(this);

            } // SpiralAppletControlPanel ctor
        } // class SpiralAppletControlPanel

    //
    // Implementing Applet methods...
    //
        public SpiralApplet()
        {
            java.awt.Container contentPane = getContentPane();

            contentPane.setLayout(new ColLayout());

            // used as "fill" argument to add()
            final java.awt.GridBagConstraints stretchxy = new java.awt.GridBagConstraints(){{fill=BOTH;weightx=weighty=1.;}};

            contentPane.add(theCanvas = new TheCanvas() {}, stretchxy);

            //
            // Make the menu bar
            //
            if (true)
            {
                // http://www.isr.umd.edu/~austin/ence688r.d/java-swing/menu.d/DemoMenuItem.java
                JMenuBar menuBar = new JMenuBar();

                menuBar.setBorderPainted(false); // true is default. false makes it blend into the background a tiny bit more, which is good.

                this.setJMenuBar(menuBar);

                JMenu fileMenu = new JMenu("File", true);
                menuBar.add(fileMenu);

                JMenu editMenu = new JMenu("Edit", true);
                menuBar.add(editMenu);

                JMenu windowsMenu = new JMenu("Windows", true);
                menuBar.add(windowsMenu);
                windowsMenu.add(new JMenuItem("Control Panel") {{
                    addActionListener(new java.awt.event.ActionListener() {
                        public void actionPerformed(java.awt.event.ActionEvent e)
                        {
                            theControlPanelWindow.setState(JFrame.NORMAL); // not iconified
                            theControlPanelWindow.setVisible(true); // also brings it to front, apparently
                        }
                    });
                }});

                JMenu helpMenu = new JMenu("Help", true);
                menuBar.add(helpMenu);
                helpMenu.add(new JMenuItem("Help") {{
                    addActionListener(new java.awt.event.ActionListener() {
                        public void actionPerformed(java.awt.event.ActionEvent e)
                        {
                            help();
                        }
                    });
                }});
                helpMenu.add(new JMenuItem("About...") {{
                    // TODO: do me
                }});
            }

            //randomlyColorize(this);

            //
            // Make the control panel window
            //
            if (true)
            {
                theControlPanelWindow = new JFrame(windowTitle + " Control Panel");
                // no need for setDefaultCloseOperation
                // since the default is HIDE_ON_CLOSE which is what we want


                final boolean useScrollPane = false; // can set this to true if it gets big enough to warrant it

                final int preferredWidth = 600; // XXX big enough so tooltip doesn't spill out, since that causes perf problems forevermore
                final int preferredHeight = 400;


                java.awt.Component controlPanel = new SpiralAppletControlPanel(this) {
                    public java.awt.Dimension getPreferredSize()
                    {
                        if (useScrollPane)
                            return new java.awt.Dimension(preferredWidth, preferredHeight);
                        else
                            return super.getPreferredSize();
                    }
                    public java.awt.Dimension getMinimumSize()
                    {
                        if (useScrollPane)
                            return new java.awt.Dimension(preferredWidth, preferredHeight);
                        else
                            return super.getMinimumSize();
                    }
                };
                if (useScrollPane)
                    controlPanel = new JScrollPane(controlPanel);
                theControlPanelWindow.getContentPane().add(controlPanel);

                theControlPanelWindow.setLocation(730, 10);
                theControlPanelWindow.setSize(preferredWidth+34, preferredHeight); // empirical-- will be wrong on another machine, no doubt XXX TODO: can we compute a good preferred size? pack() or something? just want to pack width, not height, I think?
                theControlPanelWindow.setVisible(true);
            }


            //
            // Make the help window
            //
            {
                theHelpWindow = new JFrame("SpiralApplet Help");
                // no need for setDefaultCloseOperation
                // since the default is HIDE_ON_CLOSE which is what we want

                // TODO: figure out how to make it scroll in response to arrow keys

                if (true)
                {
                    // Use a JTextArea made to look like a label so text will be selectable
                    String text = "";
                    FORI (i, helpMessage.length)
                        text += "  " + helpMessage[i] + "  \n";
                    theHelpWindow.getContentPane().add(
                        new JScrollPane(
                            new JTextArea(text) {{
                                // make it like a JLabel as much as possible, but text selectable
                                this.setEditable(false);
                                this.setDisabledTextColor(java.awt.Color.black);
                                this.setBackground(null); // same as JLabel
                                this.setBorder(null); // same as JLabel
                            }}
                        ) {{
                            // if we don't do the following, it will screw up
                            // and pick a width that forces a horizontal scrollbar... lame!
                            this.setVerticalScrollBarPolicy(JScrollPane.VERTICAL_SCROLLBAR_ALWAYS);
                        }}
                    );
                }
                else
                {
                    // Use a JLabel -- text not selectable :-(
                    String htmlHelpMessage = "<html><pre>";
                    FORI (i, helpMessage.length)
                        htmlHelpMessage += helpMessage[i] + "  \n";
                    htmlHelpMessage += "</pre></html>";

                    theHelpWindow.getContentPane().add(new JScrollPane(new JLabel(htmlHelpMessage)) {{

                        // if we don't do the following, it will screw up
                        // and pick a width that forces a horizontal scrollbar... lame!
                        this.setVerticalScrollBarPolicy(JScrollPane.VERTICAL_SCROLLBAR_ALWAYS);
                    }});
                }

                theHelpWindow.setLocation(210,30); // XXX do I really want this?  can I center it instead? doing it so the help window doesn't end up in same place as main window.
                theHelpWindow.pack(); // so that getWidth() will be the preferred width
                theHelpWindow.setSize(theHelpWindow.getWidth(),700); // XXX heuristic for my screen
                //theHelpWindow.setVisible(true); // uncomment when debugging
            }
        } // SpiralApplet ctor

        static final String helpMessage[] = {
            "===================================================================",
            "Mouse:",
            "Keys:",
            "===================================================================",
        }; // helpMessage

        private void help()
        {
            theHelpWindow.setState(java.awt.Frame.NORMAL); // not ICONTIFIED
            theHelpWindow.setVisible(true);
            theHelpWindow.toFront();

            if (true)
            {
                FORI (i, helpMessage.length)
                    System.out.println(helpMessage[i]);
            }
        } // help

        // classNameAncestors
        private static String classNameAncestors(Class classs)
        {
            String text = classs.getName();

            if (text.indexOf("java.lang.") == 0)
                text = text.substring(10);
            if (text.indexOf("java.awt.") == 0)
                text = text.substring(9);
            if (text.indexOf("javax.swing.J") == 0)
                text = text.substring(12);

            //if (text.indexOf('$') != -1)
            if (classs.getSuperclass() != null)
                text += " > " + classNameAncestors(classs.getSuperclass());
            return text;
        } // classNameAncestors
        private static void dumpComponentHierarchy(java.awt.Component component, int depth, int iChildInParent, int nChildrenInParent)
        {
            FORI (i, depth) System.out.print(" ");

            System.out.print(iChildInParent+"/"+nChildrenInParent+" ");
            System.out.println(classNameAncestors(component.getClass()));

            if (component instanceof java.awt.Container)
            {
                java.awt.Container C = (java.awt.Container)component;
                int n = C.getComponentCount();
                for (int iChild = 0; iChild < n; ++iChild)
                {
                    //FORI (iIndent, depth) System.out.print(" "); System.out.println(iChild+"/"+n);
                    dumpComponentHierarchy(C.getComponent(iChild), depth+1, iChild, n);
                }
                if (n > 0)
                {
                    //FORI (iIndent, depth) System.out.print(" "); System.out.println(n+"/"+n);
                }
            }
        } // dumpComponentHierarchy

        private static void randomlyColorize(java.awt.Component c)
        {
            c.setBackground(new java.awt.Color((float)Math.random(),
                                               (float)Math.random(),
                                               (float)Math.random()));
            c.setForeground(new java.awt.Color((float)Math.random(),
                                               (float)Math.random(),
                                               (float)Math.random()));
            if (c instanceof java.awt.Container)
            {
                java.awt.Container C = (java.awt.Container)c;
                int n = C.getComponentCount();
                for (int i = 0; i < n; ++i)
                    randomlyColorize(C.getComponent(i));
            }
        } // randomlyColorize

        public void init()
        {
            eventVerbose = getParameterInt("EventVerbose", eventVerbose);
            if (eventVerbose >= 1) System.out.println("in init");

            graphicsAntiAliasingSetter = new GraphicsAntiAliasingSetter();

            theSpiralView.showRungsFlag.addListener(showRungsFlagListener = new Listenable.Listener() {
                public void valueChanged()
                {
                    theCanvas.repaint();
                }
            });

            theSpiralView.focus.addListener(focusListener = new Listenable.Listener() {
                public void valueChanged()
                {
                    // polish the value: if it's almost exactly 0 mod .125, round it
                    double value = theSpiralView.focus.get();
                    double roundedValue = Math.round(value*8)*.125;
                    if (roundedValue != value
                     && ABS(value-roundedValue) < 1e-6)
                    {
                        System.out.println("rounding focus from "+value+" to "+roundedValue);
                        theSpiralView.focus.set(roundedValue);
                    }
                }
            });
            theSpiralView.pixelsPerPart.addListener(pixelsPerPartListener = new Listenable.Listener() {
                public void valueChanged()
                {
                    if (theSpiralView.pixelsPerPart.get() <= 0)
                    {
                        // reject!
                        System.out.println("rejecting change to pixelsPerPart!");
                        theSpiralView.pixelsPerPart.set(2);
                        return; // we'll get called again
                    }

                    // XXX should this be in SpiralView? hmm
                    theSpiralView.focusQuantum = 2./3./theSpiralView.pixelsPerPart.get();

                    theCanvas.repaint();
                }
            });
            showTimingFlag.addListener(showTimingFlagListener = new Listenable.Listener() {
                public void valueChanged()
                {
                    theCanvas.repaint();
                }
            });
            showNonTimingFlag.addListener(showNonTimingFlagListener = new Listenable.Listener() {
                public void valueChanged()
                {
                    theCanvas.repaint();
                }
            });
            showFocusInControlPanelFlag.addListener(showFocusInControlPanelListener = new Listenable.Listener() {
                public void valueChanged()
                {
                    focusInControlPanelRow.setVisible(showFocusInControlPanelFlag.get());
                    theCanvas.repaint();
                }
            });

            if (eventVerbose >= 1) System.out.println("out init");
        } // init

        public void start()
        {
            if (eventVerbose >= 1) System.out.println("in start");
            if (eventVerbose >= 1) System.out.println("out start");
        }
        public void stop()
        {
            if (eventVerbose >= 1) System.out.println("in stop");
            if (eventVerbose >= 1) System.out.println("out stop");
        }
        public void destroy()
        {
            if (eventVerbose >= 1) System.out.println("in destroy");
            if (eventVerbose >= 1) System.out.println("out destroy");
        }

        //
        // Button behavor changed incompatibly between Java 1.1 and 1.4
        // (not sure exactly what version it changed in though).
        // (I think it was 1.4 since that's when getButton() was added
        // to MouseEvent).
        //
        private static int getButton(java.awt.event.MouseEvent e)
        {
            // gag me! we can't even query the java spec version number
            // since System.getProperty() throws a security exception
            // in netscape!
            // so use empirical evidence...
            int mods = e.getModifiers();
#if 0 // can't seem to get this to work under IE at all, so don't try for now, it will just be wrong under 1.4
            boolean is_1_4_or_greater = ((mods & ~0x1fff) != 0);
            if (is_1_4_or_greater)
            {
                try
                {
                    return e.getButton();
                }
                catch (NoSuchMethodError err)
                {
                    // this only happens in IE, not netscape. fall through...
                }
            }
#endif

            if ((mods & java.awt.event.InputEvent.ALT_MASK) != 0)
                return java_awt_event_MouseEvent_BUTTON2;
            if ((mods & java.awt.event.InputEvent.META_MASK) != 0)
                return java_awt_event_MouseEvent_BUTTON3;
            return java_awt_event_MouseEvent_BUTTON1;
        } // getButton

        private class TheCanvas
            extends JPanel
            implements java.awt.event.MouseListener,
                       java.awt.event.MouseMotionListener,
                       java.awt.event.KeyListener
        {
            TheCanvas()
            {
                // hmm, double buffering doesn't seem to make much difference, on my laptop??
                super(true); // double buffered
                //super(false); // not double buffered
                //PRINT(isDoubleBuffered());

                // Specify an "event listener" object
                // to respond to events.
                // (>= Java 1.1 event model).
                this.addMouseListener(this);
                this.addMouseMotionListener(this);
                this.addKeyListener(this);
            }

            //
            // MouseListener and MouseMotionListener methods...
            //
            public void mousePressed(java.awt.event.MouseEvent e)
            {
                if (eventVerbose >= 1) System.out.println("in mousePressed: "+e);
                if (eventVerbose >= 1)
                {
                    if (getButton(e) == java_awt_event_MouseEvent_BUTTON1)
                        System.out.println("    (left mouse)");
                    if (getButton(e) == java_awt_event_MouseEvent_BUTTON2)
                        System.out.println("    (middle mouse)");
                    if (getButton(e) == java_awt_event_MouseEvent_BUTTON3)
                        System.out.println("    (right mouse)");
                }

                theCanvas.repaint();

                if (eventVerbose >= 1) System.out.println("out mousePressed: "+e);
            } // mousePressed
            public void mouseReleased(java.awt.event.MouseEvent e)
            {
                if (eventVerbose >= 1) System.out.println("in mouseReleased: "+e);

                theCanvas.repaint();

                if (eventVerbose >= 1) System.out.println("out mouseReleased: "+e);
            } // mouseReleased
            public void mouseEntered(java.awt.event.MouseEvent e)
            {
                if (eventVerbose >= 1) System.out.println("in mouseEntered: "+e);
                // steal keyboard focus!
                //System.out.println("Requesting focus!");
                requestFocus(); // hey it works! (javac 1.3, runtime 1.6)  XXX what does "it works" mean?
                if (eventVerbose >= 1) System.out.println("out mouseEntered: "+e);
            }
            public void mouseExited(java.awt.event.MouseEvent e)
            {
                if (eventVerbose >= 1) System.out.println("in mouseExited: "+e);
                if (eventVerbose >= 1) System.out.println("out mouseExited: "+e);
            }
            public void mouseClicked(java.awt.event.MouseEvent e)
            {
                if (eventVerbose >= 1) System.out.println("in mouseClicked: "+e);
                if (eventVerbose >= 1) System.out.println("out mouseClicked: "+e);
            }
            public void mouseDragged(java.awt.event.MouseEvent e)
            {
                if (eventVerbose >= 2) System.out.println("  in mouseDragged: "+e);

                theCanvas.repaint();

                if (eventVerbose >= 2) System.out.println("  out mouseDragged: "+e);
            } // mouseDragged
            public void mouseMoved(java.awt.event.MouseEvent e)
            {
                if (eventVerbose >= 3) System.out.println("    in mouseMoved: "+e);

                if (eventVerbose >= 3) System.out.println("    out mouseMoved: "+e);
            } // mouseMoved

            //
            // KeyListener methods...
            //
            public void keyPressed(java.awt.event.KeyEvent e)
            {
                if (eventVerbose >= 1) System.out.println("in keyPressed: "+e);

                switch(e.getKeyCode())
                {
                    case java.awt.event.KeyEvent.VK_UP:
                    case java.awt.event.KeyEvent.VK_DOWN:
                        pause();
                        break;
                    case java.awt.event.KeyEvent.VK_LEFT:
                        if (e.isShiftDown())
                        {
                            accelBackward();
                        }
                        else
                        {
                            stepBackward();
                        }
                        break;

                    case java.awt.event.KeyEvent.VK_RIGHT:
                        if (e.isShiftDown())
                        {
                            accelForward();
                        }
                        else
                        {
                            stepForward();
                        }
                        break;
                    default:
                        // don't print anything, or we'll print too much (e.g. Shift, and any keys we handle in keyTyped())
                        //System.out.println("Unknown keycode "+java.awt.event.KeyEvent.getKeyText(e.getKeyCode())+" ("+e.getKeyCode()+")");
                        break;
                }
                if (eventVerbose >= 1) System.out.println("out keyPressed: "+e);
            } // keyPressed
            public void keyReleased(java.awt.event.KeyEvent e)
            {
                if (eventVerbose >= 1) System.out.println("in keyReleased: "+e);
                switch(e.getKeyCode())
                {
                    default:
                        break;
                }
                if (eventVerbose >= 1) System.out.println("out keyReleased: "+e);
            } // keyReleased
            public void keyTyped(java.awt.event.KeyEvent e)
            {
                if (eventVerbose >= 1) System.out.println("in keyTyped: "+e);
                char c = e.getKeyChar();

                // In java 1.6, apparently ctrl-letter
                // started coming out as just the letter
                // (with ke.isControlDown() true).
                // Detect this and change it to the old behavior...
                // XXX need to do something else, or nothing at all here, for old javas (1.1) in which isControlDown doesn't exist... or else just stop trying to support 1.1 at all
                if (c >= 'a' && c <= 'z' && e.isControlDown())
                {
                    c -= ('a'-1);
                }

    #define CTRL(lowerCaseLetter) ((lowerCaseLetter)-'a' + 1)
                switch (c)
                {
                    case '\n':
                        theCanvas.repaint();
                        break;
                    case CTRL('q'): // quit
                    {
                        System.out.println("Aww.");
                        System.exit(1);
                    }
                    default:
                        System.out.println("Unknown key '"+c+"'("+(int)e.getKeyChar()+") typed");
                        break;
                }
                if (eventVerbose >= 1) System.out.println("out keyTyped: "+e);
            } // keyTyped






            //
            // Make it so we get keyboard focus on startup,
            // without having to click first.  Thanks, Melinda!
            // The state of things seems to be:
            //      - Buttons and TextFields are apparently "focus traversable"
            //        by default.  Canvases and Applets aren't,
            //        implying (not obvious) that you need to click to type
            //        when the app starts,
            //        which is almost never the desired behavior.
            //        You can change this by overriding isFocusTraversable(),
            //        which we do below.
            //      - Other approaches using requestFocus():
            //        A Canvas calling requestFocus() doesn't seem to do
            //        anything.  An Applet calling requestFocus() doesn't
            //        do anything during init(), but I think it works
            //        if you put it in the mouseEntered handler or something,
            //        though this can lead to various unpredictabilities.
            //
            public boolean isFocusTraversable()
            {
                return true;
            }



            // holy mother of god
            private String formatFixedPoint(double d, int prec)
            {
                boolean wasNegative = false;
                if (d < 0.)
                {
                    wasNegative = true;
                    d = -d;
                }
                FORI (i, prec)
                    d *= 10;
                long l = (long)Math.round(d);
                String answer = "";
                FORI (i, prec)
                {
                    answer = l%10 + answer;
                    l /= 10;
                }
                return l + "." + answer;
            }


            double lastStartTimePrinted = 0.;
            int lastNPaintsPrinted = 0;


            // PAINT/DISPLAY/DRAW
            public void paintComponent(java.awt.Graphics g)
            {
                //try { Thread.sleep(50); } catch (InterruptedException e) {}
                java.awt.Dimension size = getSize();
                int maxRingBufferSize = size.width + 3; // some slop

                double startTime = timeSeconds();
                while (startTimes.size() >= maxRingBufferSize) startTimes.deleteFirst();
                startTimes.append(startTime);

                if (eventVerbose >= 1) System.out.println("in paint");


                if (showVsyncLapsesFlag.get())
                {
                    // Try to print out an idea of how frequent the lapses in vsync
                    // are happening
                    int sampleSize = 10;
                    if (startTimes.size() >= sampleSize+1
                     && nPaints >= lastNPaintsPrinted + 100
                     && (startTimes.get(startTimes.size()-1)-startTimes.get(startTimes.size()-1-sampleSize))/sampleSize < .01666*3/4.)
                    {
                        if (lastStartTimePrinted == 0.)
                            System.out.println("Hey! low frame time");
                        else
                            System.out.println("Hey! low frame time after "+(startTime-lastStartTimePrinted)+" secs");
                        lastNPaintsPrinted = nPaints;
                        lastStartTimePrinted = startTime;
                    }
                }
                else
                {
                    lastStartTimePrinted = 0L;
                    lastNPaintsPrinted = 0;
                }

                // TODO: need to synchronize this I think
                theSpiralView.focus.set(
                    fmod(theSpiralView.focus.get() + theSpiralView.focusAnimationVelocity.get(),
                         theSpiralModel.params.n.get()));

                double minSize = (double)MIN(size.width, size.height);

                MyGraphics mg = new MyGraphics(g, size,
                    -size.width/minSize,size.width/minSize,
                    -size.height/minSize,size.height/minSize);

                if (implementAntiAliasingInHardware)
                {
                    graphicsAntiAliasingSetter.setAntiAliasing(g,
                                                               antiAliasingFlag,
                                                               //1
                                                               eventVerbose
                                                               );
                }


                //
                // Clear to black...
                //
                g.setColor(java.awt.Color.black);
                g.fillRect(0,0, size.width,size.height);


                double pixelsPerMilli = 4.;
                if (showTimingFlag.get())
                {
                    // background horizontal lines for timing
                    g.setColor(java.awt.Color.darkGray);
                    for (int i = 0; ; i++)
                    {
                        int y = size.height-(int)Math.round(i*pixelsPerMilli*1000./60.);
                        if (y < 0)
                            break;
                        g.fillRect(0,y-1,
                                   size.width,2);
                    }
                }

                if (showNonTimingFlag.get())
                {
                    drawTicker(g,
                               size,
                               size.width/2.,
                               size.height/2.,
                               theSpiralModel,
                               theSpiralView);


                    double scale = .5; // TODO: gui hook for this
                    if (false)
                    {
                        // draw dual spiral
                        drawSpiral(mg,
                                   scale,
                                   theSpiralModel,
                                   theSpiralView,
                                   false, // drawPrimalFlag
                                   true, // drawDualFlag
                                   false, // drawRungsFlag
                                   antiAliasingFlag);
                    }
                    if (false)
                    {
                        // draw primal spiral
                        drawSpiral(mg,
                                   scale,
                                   theSpiralModel,
                                   theSpiralView,
                                   true, // drawPrimalFlag
                                   false, // drawDualFlag
                                   theSpiralView.showRungsFlag.get(), // drawRungsFlag
                                   antiAliasingFlag);
                    }
                }




                nPaints++;
                g.setColor(java.awt.Color.white);
                g.drawString(""+nPaints+" paints",
                              size.width - 75,
                              20);

                g.drawString("focus: "+theSpiralView.focus,
                             10,
                             20);



                if (showTimingFlag.get())
                {
                    {
                        for (int iCol = 0; iCol < size.width; ++iCol)
                        {
                            int x = size.width-1-iCol;
                            int y = size.height;
                            if (iCol==0)
                            {
                                double now = timeSeconds();
                                double paintTimeSoFar = now-startTime;
                                assert(paintTimeSoFar >= 0.);
                                //PRINT(paintTimeSoFar);
                                g.setColor(java.awt.Color.yellow);
                                int barHeight = (int)(.5+paintTimeSoFar*(1000.*pixelsPerMilli));
                                g.fillRect(x,y-barHeight,
                                           1,barHeight);
                                y -= barHeight;
                            }
                            else if (iCol <= endTimes.size() && iCol < startTimes.size())
                            {
                                double paintTime = endTimes.get(endTimes.size()-iCol) - startTimes.get(startTimes.size()-1-iCol);
                                assert(paintTime >= 0.);
                                //PRINT(paintTime);
                                g.setColor(java.awt.Color.green);
                                int barHeight = (int)(.5+paintTime*(1000.*pixelsPerMilli));
                                g.fillRect(x,y-barHeight,
                                           1,barHeight);
                                y -= barHeight;
                            }
                            if (iCol>=1 && (iCol-1) < startTimes.size() && (iCol-1) < endTimes.size())
                            {
                                double nonPaintTime = (startTimes.get(startTimes.size()-1-(iCol-1)) - endTimes.get(endTimes.size()-1-(iCol-1)));
                                //PRINT(nonPaintTime);
                                assert(nonPaintTime >= 0.);
                                g.setColor(java.awt.Color.red);
                                int barHeight = (int)(.5+nonPaintTime*(1000.*pixelsPerMilli));
                                g.fillRect(x,y-barHeight,
                                           1,barHeight);
                                y -= barHeight;
                            }
                        }
                    }
                    {
                        int frames = startTimes.size()-1;
                        double seconds = (double)(startTimes.get(startTimes.size()-1)-startTimes.get(0));
                        if (seconds > 0.) // implies frames must be > 0 too
                        {
                            g.setColor(java.awt.Color.white);
                            g.drawString("fps over "+frames+" frames: "+formatFixedPoint(frames/seconds,3),
                                         size.width-300,
                                         40);
                            g.drawString("spf over "+frames+" frames: "+formatFixedPoint(seconds/frames, 5),
                                         size.width-300,
                                         60);
                            g.setColor(java.awt.Color.red);
                            g.drawString("red is time outside paintComponent",
                                         size.width-300,
                                         80);
                            g.setColor(java.awt.Color.green);
                            g.drawString("green is time in paintComponent",
                                         size.width-300,
                                         100);
                        }
                    }
                }

                if (true)
                {
                    // draw dot at exact center of window,
                    // for debugging.
                    g.setColor(java.awt.Color.red);
                    // 1 -> 0..1
                    // 2 -> 0..2
                    // 3 -> 1..2
                    // 4 -> 1..3
                    // 5 -> 2..3
                    // 6 -> 2..4
                    int x0 = (size.width-1)/2;
                    int x1 = (size.width+2)/2;
                    int y0 = (size.height-1)/2;
                    int y1 = (size.height+2)/2;
                    g.fillRect(x0,y0,
                               x1-x0,y1-y0);
                }



                // swing swaps buffers for us

                if (eventVerbose >= 1) System.out.println("out paint");

                while (endTimes.size() >= maxRingBufferSize) endTimes.deleteFirst();
                double endTime = timeSeconds();
                endTimes.append(endTime);
            } // paint

        } // class TheCanvas


        // ring buffer of doubles.
        // O(1) operations:
        //     size()
        //     get()
        //     deleteFirst()
        //     append() (amortized)
        private class DoubleRingBuffer
        {
            private int i0 = 0;
            private int size = 0;
            private double[] array = new double[1];

            public int size()
            {
                return size;
            }
            public double get(int index)
            {
                if (index < 0 || index >= size)
                    throw new IndexOutOfBoundsException("DoubleRingBuffer.get: "+index+" out of bounds 0.."+size+"-1");
                return array[(i0+index)%array.length];
            }
            public void set(int index, double item)
            {
                if (index < 0 || index >= size)
                    throw new IndexOutOfBoundsException("DoubleRingBuffer.set: "+index+" out of bounds 0.."+size+"-1");
                array[(i0+index)%array.length] = item;
            }
            public void append(double item)
            {
                if (size == array.length)
                {
                    // grow
                    double newArray[] = new double[array.length*2];
                    System.arraycopy(array, i0, newArray, 0, size-i0);
                    System.arraycopy(array, 0, newArray, size-i0, i0);
                    array = newArray;
                    i0 = 0;
                    // and size stays the same... now half of array.length
                }
                array[(i0+size++)%array.length] = item;
            }
            public void deleteFirst()
            {
                if (size == 0)
                {
                    throw new IndexOutOfBoundsException("DoubleRingBuffer.deleteFirst: buffer is empty");
                }
                i0 = (i0+1)%array.length;
                size--;
            }
        } // private class DoubleRingBuffer

        public DoubleRingBuffer startTimes = new DoubleRingBuffer();
        public DoubleRingBuffer endTimes = new DoubleRingBuffer();




        // Calculate the angle C, opposite side c,
        // given side lengths a, b, c,
        // using c^2 = a^2 + b^2 - 2*a*b*cos(C)
        private static double triangleAngle(double a, double b, double c)
        {
            return Math.acos((a*a + b*b - c*c) / (2*a*b));
        }

        // Find vertex v2 that completes the triangle with given edge lengths,
        // such that v0,v1,v2 are CCW.
        private static double[] completeTriangle(double v0[],
                                                 double v1[],
                                                 double dist12,
                                                 double dist20)
        {
            // Make sure has only 2 entries
            v0 = new double[]{v0[0],v0[1]};
            v1 = new double[]{v1[0],v1[1]};
            double ang0 = triangleAngle(VecMath.dist(v0,v1), dist20, dist12);
            double dir01[] = VecMath.normalize(VecMath.vmv(v1,v0));
            double v2[] = VecMath.sxvpsxvpsxv(
                1.,                    v0,
                dist20*Math.cos(ang0), dir01,
                dist20*Math.sin(ang0), VecMath.xv2(dir01));
            return v2;
        } // completeTriangle

        private static double twiceTriangleArea(double x0, double y0,
                                                double x1, double y1,
                                                double x2, double y2)
        {
            return (x1-x0)*(y2-y0) - (x2-x0)*(y1-y0);
        }
        private static double twiceTriangleArea(double v0[],
                                           double v1[],
                                           double v2[])
        {
            return twiceTriangleArea(v0[0], v0[1],
                                     v1[0], v1[1],
                                     v2[0], v2[1]);
        }

        // XXX does this belong in MyMath or something?
        public static double fmod(double a, double b)
        {
            /*   oh no! roundoff error!
            double temp = a / b;
            return (temp - Math.floor(temp)) * b;
            */
            a %= b;
            if (a < 0.) // retarded
                a += b;
            return a;
        }














        public static class SpiralModel
        {
            public static final int DELTASTYLE_MIN = 0;
            public static final int DELTASTYLE_1 = 0;
            public static final int DELTASTYLE_ANY = 1;
            public static final int DELTASTYLE_MAX = 1;


            public static class Params
            {
                // XXX same thing in applet... should this be a little subclass?
                public Listenable.Int n = new Listenable.Int(2, 1000*1000*1000, 100); // must be positive multiple of 2
                public Listenable.Int nParts = new Listenable.Int(1, 1000*1000*1000, 3); // must be >= 2
                public Listenable.Int deltaStyle = new Listenable.Int(SpiralModel.DELTASTYLE_MIN, SpiralModel.DELTASTYLE_MAX, SpiralModel.DELTASTYLE_ANY);
                public Listenable.Int randomSeed = new Listenable.Int(0, (1<<31)-1, 1);
            }

            public Params params = new Params();



            public int theList[/*n*/];
            public double centers[/*n*/][/*2*/]; // centers[i] is center of theList up through index i, rotated and scaled canonically
            public double weights[/*n*/]; // weights[i] is area of dual diagram of theList up through index i, rotated and scaled canonically

            SpiralModel()
            {
                init(params.n.get(),
                     params.nParts.get(),
                     params.deltaStyle.get(),
                     params.randomSeed.get());
            }

            public void init(int n,
                             int nParts,
                             int deltaStyle, // DELTASTYLE_1 or DELTASTYLE_ANY
                             int randomSeed)
            {
                this.params.n.set(n);
                this.params.nParts.set(nParts);
                this.params.deltaStyle.set(deltaStyle);
                this.params.randomSeed.set(randomSeed);

                java.util.Random rng = new java.util.Random(randomSeed);
                assert(n >= 2);
                assert(n % 2 == 0); // doesn't work with odd n
                assert(nParts >= 2); // doesn't work with only one part

                this.theList = new int[n];
                if (deltaStyle == DELTASTYLE_1)
                {
                    int maxPasses = 100;
                    int val = (nParts+1)/4*2; // somewhat arbitrary even starting point... will turn random (but still even) on second pass.
                    assert(val >= 0 && val < nParts && val%2 == 0);

                    boolean done = false;
                    FORI (iPass, maxPasses)
                    {
                        FORI (i, n)
                        {
                            if (val == 0)
                                val = 1;
                            else if (val == nParts-1)
                                val = nParts-2;
                            else if (rng.nextBoolean())
                                val += 1;
                            else
                                val -= 1;
                            if (iPass >= 1 && val == this.theList[i])
                            {
                                done = true;
                                break;
                            }
                            assert(val >= 0 && val < nParts);
                            this.theList[i] = val;
                        }
                        if (done)
                            break;
                    }
                    assert(done);
                }
                else if (deltaStyle == DELTASTYLE_ANY)
                {
                    int maxPasses = 100;


                    int val = nParts/4*2; // somewhat arbitrary even starting point... will turn random (but still even, since n is even) on second pass.
                    PRINT(nParts);
                    assert(val >= 0 && val < nParts && val%2 == 0);

                    boolean done = false;
                    int sign = -1; // initial val is biased a bit downwards, so there is guaranteed to be room upwards. so set sign initially to -1, so it will immediately switch to 1 and there will be room.
                    int nRemainingThisSign = 0;
                    FORI (iPass, maxPasses)
                    {
                        FORI (i, n)
                        {
                            if (iPass >= 1 && val == this.theList[i])
                            {
                                done = true;
                                break;
                            }
                            assert(val >= 0 && val < nParts);
                            this.theList[i] = val;

                            if (nRemainingThisSign == 0)
                            {
                                sign = -sign;
                                if (sign == -1)
                                {
                                    assert(val > 0);
                                    nRemainingThisSign = 1+rng.nextInt(val);
                                }
                                else
                                {
                                    assert(nParts-1-val > 0);
                                    nRemainingThisSign = 1+rng.nextInt(nParts-1-val);
                                }
                            }

                            val += sign;
                            --nRemainingThisSign;
                        }
                        if (done)
                            break;
                    }
                    assert(done);
                }
                else
                    assert(false);

                // sanity check-- parity of value should be same as parity of index
                FORI (i, n)
                    assert((theList[i] + i)%2 == 0);

                this.centers = new double[n][2];
                this.weights = new double[n];
                if (false)  // XXX fix
                {
                    double prevWeight = 0.;
                    double prevCenter[] = {0.,0.};
                    double thisWeight = 0.;
                    double thisCenter[] = {0.,0.};

                    boolean done = false;
                    FORI (iPass, 2)
                    {
                        FORI (i, n)
                        {
                            // Compute new weight and center
                            // from prev weight and center
                        }
                    }
                    assert(done);
                }
            }
        }; // public class SpiralModel
        public static class SpiralView
        {
            public Listenable.Double focus = new Listenable.Double(0.,0., 0.); // modulo spiralModel.params.n
            public Listenable.Int pixelsPerPart = new Listenable.Int(2, 1024, 3); // must be >= 1
            public Listenable.Boolean showRungsFlag = new Listenable.Boolean(false);
            public double focusQuantum;
            public Listenable.Double focusAnimationVelocity = new Listenable.Double(0., 0., 0.);
            public SpiralView()
            {
                this.focusQuantum = 2./3./pixelsPerPart.get(); // and needs to be kept updated
            }
        }; // public class SpiralView


        public void drawTicker(java.awt.Graphics g,
                               java.awt.Dimension gsize,
                               double gCenterX, double gCenterY, // in pixels from upper-left corner of window
                               SpiralModel spiralModel,
                               SpiralView spiralView)
        {
            //System.out.println("    in drawTicker");
            int n = spiralModel.params.n.get();
            int nParts = spiralModel.params.nParts.get();
            int pixelsPerPart = spiralView.pixelsPerPart.get();
            //PRINT(nParts);
            //PRINT(pixelsPerPart);
            //PRINT(gCenterX);
            //PRINT(gCenterY);

            assert(n > 0);
            assert(pixelsPerPart > 0);
            assert(n % 2 == 0); // whole thing doesn't work otherwise


            java.awt.Color gray128 = new java.awt.Color(128,128,128);
            java.awt.Color gray64 = new java.awt.Color(64,64,64);
            java.awt.Color gray32 = new java.awt.Color(32,32,32);


            // Given gCenterX,gCenterY,
            // figure out the "base" pixel index.
            // this is the pixel where val=0 would go
            // at an exact even integer focus
            // (val=0 is only achievable on even focus).
            // If ixBase,iyBase are both .5 mod 1,
            // then we round one down and one up-- that's the purpose of the -round(-) thing.
            // XXX TODO: this works since the inputs are all multiples of .5, but may not be the most robust way in general, should think about it more
            int ixBase = (int)Math.round(gCenterX + (nParts-1)*pixelsPerPart*.25 - .5);
            int iyBase = -(int)Math.round(-(gCenterY + (nParts-1)*pixelsPerPart*.25 - .5));
            // from now on we never use gCenterX,gCenterY again
            //PRINT(gCenterX + (nParts-1)*pixelsPerPart*.25 - .5);
            //PRINT(gCenterY + (nParts-1)*pixelsPerPart*.25 - .5);
            //PRINT(ixBase);
            //PRINT(iyBase);

            // figure out where to draw rails, i.e. bounds
            // of ticker stip.
            // this should be the same regardless of focus.
            //  1->1
            //  2->1
            //  3->2
            //  4->2
            //  5->3
            //  pixelsPerPart -> (pixelsPerPart+1)/2
            int ixLowerRail = ixBase;
            int iyLowerRail = iyBase + (pixelsPerPart+1)/2;
            int ixUpperRail = ixBase;
            int iyUpperRail = iyBase - (nParts-1)*pixelsPerPart - (pixelsPerPart+1)/2;

            {
                // draw the rails...
                // (diagonal lines lower-left to upper-right).
                g.setColor(gray128);
                int gsizeMin = MIN(gsize.width, gsize.height);
                g.drawLine(ixLowerRail-gsizeMin,iyLowerRail+gsizeMin,
                           ixLowerRail+gsizeMin,iyLowerRail-gsizeMin);
                g.drawLine(ixUpperRail-gsizeMin,iyUpperRail+gsizeMin,
                           ixUpperRail+gsizeMin,iyUpperRail-gsizeMin);
                // and the center line...
                g.setColor(gray32);
                if ((iyLowerRail-iyUpperRail)%2 == 0)
                {
                    // one diagonal line exactly halfway between rails
                    g.drawLine(ixLowerRail-gsizeMin,(iyLowerRail+iyUpperRail)/2+gsizeMin,
                               ixLowerRail+gsizeMin,(iyLowerRail+iyUpperRail)/2-gsizeMin);
                }
                else
                {
                    // two diagonal lines
                    g.drawLine(ixLowerRail-gsizeMin,(iyLowerRail+iyUpperRail-1)/2+gsizeMin,
                               ixLowerRail+gsizeMin,(iyLowerRail+iyUpperRail-1)/2-gsizeMin);
                    g.drawLine(ixLowerRail-gsizeMin,(iyLowerRail+iyUpperRail+1)/2+gsizeMin,
                               ixLowerRail+gsizeMin,(iyLowerRail+iyUpperRail+1)/2-gsizeMin);
                }
                // draw focus
                // (diagonal line upper-left to lower-right, across strip)
                g.setColor(gray32);
                // XXX TODO: draw the focus line!
            }

            if (true)
            {
                // blue for base
                g.setColor(java.awt.Color.blue);
                FORI (iPart, nParts)
                {
                    g.fillRect(ixBase,iyBase-iPart*pixelsPerPart,1,1);
                }

                // yellow for rail
                g.setColor(java.awt.Color.yellow);
                g.fillRect(ixLowerRail,iyLowerRail,1,1);
                g.fillRect(ixUpperRail,iyUpperRail,1,1);
            }


            // the two indices bounding
            // the focus
            double focus = fmod(spiralView.focus.get(), n);
            //PRINT(focus);
            int i0 = (int)Math.floor(focus);
            //PRINT(i0);
            double frac = focus - i0;
            i0 = MOD(i0, n);
            //PRINT(i0);
            int i1 = (i0+1)%n;
            int val0 = spiralModel.theList[i0];
            int val1 = spiralModel.theList[i1];
            //PRINT(val0);
            //PRINT(val1);
            //PRINT(frac);
            double val = LERP(val0,val1,frac);
            //PRINT(val);


            // Now we need to figure out
            // the exact pixel index at which to place the vertex i0.
            // Everything else will be computed exactly relative to that.
            //
            // There are two cases:
            //         increasing... focus is on a vertical segment,
            //         i.e. in the middle of a primal vertex / dual edge
            //             /     /
            //            /\i1  /
            //           /  |  /
            //          /  i0\/
            //         /     /
            //         decreasing... focus is on a horizontal segment,
            //         i.e. in the middle of a primal edge / dual vertex
            //             /     /
            //            /\    /
            //           /i0-i1/
            //          /    \/
            //         /     /

            int ix0, iy0;
            {
                // figure out how many pixels from base to i0

                double upperLeftOffset = val0*(pixelsPerPart*.5);
                double lowerLeftOffset = ABS(val-val0)*(pixelsPerPart*.5);

                // upperLeftOffset is now a multiple of .5.
                // adjust lowerLeftOffset to nearest value that's the same as upperLeftOffset mod 1.

                if ((int)upperLeftOffset == upperLeftOffset)
                    lowerLeftOffset = (int)Math.round(lowerLeftOffset);
                else
                    lowerLeftOffset = (int)Math.round(lowerLeftOffset+.5)-.5;

                double xOffset = (-upperLeftOffset - lowerLeftOffset);
                double yOffset = (-upperLeftOffset + lowerLeftOffset);
                assert((double)(int)xOffset == xOffset);
                assert((double)(int)yOffset == yOffset);

                ix0 = ixBase + (int)xOffset;
                iy0 = iyBase + (int)yOffset;
                //PRINT(ix0);
                //PRINT(iy0);
            }

            if (true)
            {
                g.setColor(new java.awt.Color(128,128,255)); // light blue
                {
                    int prevX = ix0;
                    int prevY = iy0;
                    int prevVal = spiralModel.theList[i0];
                    for (int i = (i0+1)%n; ; i = (i+1)%n)
                    {
                        int thisVal = spiralModel.theList[i];
                        int thisX, thisY;
                        if (thisVal > prevVal)
                        {
                            // vertical seg upwards
                            thisX = prevX;
                            thisY = prevY - (thisVal-prevVal) * pixelsPerPart;
                        }
                        else
                        {
                            // horizonal seg to right
                            thisY = prevY;
                            thisX = prevX + (prevVal-thisVal) * pixelsPerPart;
                        }
                        g.drawLine(prevX,prevY,thisX,thisY);
                        if (thisX >= gsize.width || thisY < 0)
                            break;
                        prevVal = thisVal;
                        prevX = thisX;
                        prevY = thisY;
                    }
                }

                g.setColor(new java.awt.Color(128,255,128)); // light green
                {
                    int prevX = ix0;
                    int prevY = iy0;
                    int prevVal = spiralModel.theList[i0];
                    for (int i = MOD(i0-1,n); ; i = MOD(i-1,n))
                    {
                        int thisVal = spiralModel.theList[i];
                        int thisX, thisY;
                        if (thisVal < prevVal)
                        {
                            // vertical seg downwards
                            thisX = prevX;
                            thisY = prevY + (prevVal-thisVal) * pixelsPerPart;
                        }
                        else
                        {
                            // horizonal seg to left
                            thisY = prevY;
                            thisX = prevX - (thisVal-prevVal) * pixelsPerPart;
                        }
                        g.drawLine(prevX,prevY,thisX,thisY);
                        if (thisX < 0 || thisY >= gsize.height)
                            break;
                        prevVal = thisVal;
                        prevX = thisX;
                        prevY = thisY;
                    }
                }
            }

            //System.out.println("    out drawTicker");
        } // drawTicker

        // Exacly one of drawPrimalFlag and drawDualFlag must be true
        public void drawSpiral(MyGraphics mg,
                               double scale,
                               SpiralModel spiralModel,
                               SpiralView spiralView,
                               boolean drawPrimalFlag,
                               boolean drawDualFlag,
                               boolean drawRungsFlag,
                               boolean antiAliasFlag)
        {
            int debugLevel = 0; // 1 = global, 2 = and some per-increment

            // have to be drawing something
            assert(drawPrimalFlag || drawDualFlag || drawRungsFlag);
            // don't draw primal and dual at same time
            assert(!drawPrimalFlag || !drawDualFlag);

            if (debugLevel >= 1) System.out.println("    in drawSpiral "+(drawPrimalFlag?"primal":"")+(drawDualFlag?"dual":"")+(drawRungsFlag?",rungs":""));

            int n = spiralModel.params.n.get();
            int nParts = spiralModel.params.nParts.get();

            // the two indices bounding
            // the focus
            double focus = fmod(spiralView.focus.get(), n);
            int i0, i1;
            if (true)
            {
                i0 = (int)Math.floor(focus);
                i0 = MOD(i0, n);
                i1 = (i0+1)%n;
            }
            else
            {
                i1 = (int)Math.ceil(focus);
                i1 = MOD(i1, n);
                i0 = MOD(i1-1,n);
            }

            double frac = focus - i0;

            int val0 = spiralModel.theList[i0];
            int val1 = spiralModel.theList[i1];
            double val = LERP(val0,val1,frac);

            if (debugLevel >= 1)
            {
                PRINT(focus);
                PRINT(i0);
                PRINT(i1);
                PRINT(frac);
                PRINT(val0);
                PRINT(val1);
                PRINT(val);
            }

            java.awt.Color gray128 = new java.awt.Color(128,128,128);
            java.awt.Color gray64 = new java.awt.Color(64,64,64);
            java.awt.Color gray32 = new java.awt.Color(32,32,32);
            java.awt.Color pink = new java.awt.Color(255,128,128);
            java.awt.Color dimPink = new java.awt.Color(128,64,64);

            // scanDir=1: the part *after* (bigger than) the focus.
            // scanDir=-1: the part *before* (smaller than) the focus.
            int scanDirs[] = {1, -1};
            FORI (iScanDir, 2)
            {
                int scanDir = scanDirs[iScanDir];
                if (debugLevel >= 1) System.out.println("        scanDir = "+scanDir);

                if (drawPrimalFlag)
                {
                    if (scanDir < 0)
                        mg.setColor(new java.awt.Color(128,255,128)); // light green
                    else
                        mg.setColor(new java.awt.Color(128,128,255)); // light blue
                }
                else
                {
                    if (scanDir < 0)
                        mg.setColor(java.awt.Color.white);
                    else
                        mg.setColor(gray64);
                }


                double dualAng = 0;
                double primalAng = Math.PI/2 * (1 - (val+.5)/nParts);
                double dualR = scale;
                double primalR = scale;

                double dualX = dualR * Math.cos(dualAng);
                double dualY = dualR * Math.sin(dualAng);
                double primalX = primalR * Math.cos(primalAng);
                double primalY = primalR * Math.sin(primalAng);

                if (debugLevel >= 1 && scanDir > 0)
                {
                    PRINT(RTOD(primalAng));
                    PRINT(RTOD(dualAng));
                    PRINT(primalX);
                    PRINT(primalY);
                }



                // Accumulate center of curvature, if scanDir  is -1
                double centerX = 0.;
                double centerY = 0.;
                double area = 0.;
                boolean centerHasStabilized = false;


                double prevPrevVal = val;
                double prevVal = val;
                for (int i = scanDir==1?i1:i0; ; i = MOD(i+scanDir,n))
                {
                    // TODO: combine straight parts, the line will look better

                    int thisVal = spiralModel.theList[i];
                    if (scanDir==1 ? thisVal < prevVal : thisVal > prevVal)
                    {
                        // primal movement, dual turn
                        if (debugLevel >= 2 && scanDir > 0) System.out.println("            primal movement, dual turn");
                        double angleDelta = (double)(prevVal-thisVal)/(double)nParts * (Math.PI*.5);
                        if (debugLevel >= 2 && scanDir > 0) PRINT(RTOD(angleDelta));
                        double nextPrimalAng = primalAng + angleDelta;
                        if (nextPrimalAng > Math.PI)
                            nextPrimalAng -= 2*Math.PI;
                        else if (nextPrimalAng < -Math.PI)
                            nextPrimalAng += 2*Math.PI;
                        if (debugLevel >= 2 && scanDir > 0) PRINT(RTOD(nextPrimalAng));
                        double nextPrimalR;
                        {
                            // use law of sines.
                            // don't think too hard about the scanDir=-1 case, in which case angleDelta is negative and the triangle is inside out... it just works.
                            double A = angleDelta;
                            double C = primalAng+Math.PI - (dualAng+Math.PI/2);
                            double B = Math.PI - (A+C);
                            double b = primalR;
                            double c = b * (Math.sin(C)/Math.sin(B));
                            nextPrimalR = c;

                            if (debugLevel >= 2 && scanDir > 0) PRINT(RTOD(primalAng));
                            if (debugLevel >= 2 && scanDir > 0) PRINT(dualAng);

                            if (debugLevel >= 2 && scanDir > 0) PRINT(RTOD(A));
                            if (debugLevel >= 2 && scanDir > 0) PRINT(RTOD(C));
                            if (debugLevel >= 2 && scanDir > 0) PRINT(RTOD(B));
                            if (debugLevel >= 2 && scanDir > 0) PRINT(b);
                            if (debugLevel >= 2 && scanDir > 0) PRINT(c);
                            if (debugLevel >= 2 && scanDir > 0) PRINT(nextPrimalR);
                        }
                        double nextPrimalX = nextPrimalR * Math.cos(nextPrimalAng);
                        double nextPrimalY = nextPrimalR * Math.sin(nextPrimalAng);
                        if (debugLevel >= 2 && scanDir > 0) PRINT(nextPrimalR);
                        if (debugLevel >= 2 && scanDir > 0) PRINT(nextPrimalX);
                        if (debugLevel >= 2 && scanDir > 0) PRINT(nextPrimalY);

                        if (drawPrimalFlag)
                        {
                            mg.drawLine(primalX, primalY,
                                        nextPrimalX, nextPrimalY,
                                        antiAliasFlag);
                            if (
                                prevPrevVal != prevVal &&
                                (thisVal>prevVal) != (prevVal>prevPrevVal))
                            {
                                if (scanDir < 0)
                                {
                                    mg.drawPoint(primalX, primalY, 5);
                                }
                                else
                                {
                                    mg.drawPoint(primalX, primalY, 3);
                                }
                            }
                            if (scanDir > 0)
                            {
                                if (SQR(nextPrimalX)+SQR(nextPrimalY)
                                   > SQR(1) + SQR(2)) // XXX should be max distance of any corner of window from origin
                                    break;
                            }
                            else
                            {
                                if (SQR(nextPrimalX)+SQR(nextPrimalY) < SQR(1e-3)
                                 && centerHasStabilized)
                                    break;
                            }
                        }
                        if (drawRungsFlag &&
                            prevPrevVal != prevVal &&
                            (thisVal>prevVal != (prevVal>prevPrevVal)))
                        {
                            java.awt.Color savedColor = mg.getColor();
                            mg.setColor(dimPink);
                            mg.drawLine(primalX, primalY,
                                        dualX, dualY,
                                        antiAliasFlag);
                            mg.setColor(savedColor);
                        }

                        primalAng = nextPrimalAng;
                        primalR = nextPrimalR;
                        primalX = nextPrimalX;
                        primalY = nextPrimalY;
                    }
                    else if (scanDir==1 ? thisVal > prevVal : thisVal < prevVal)
                    {
                        // dual movement, primal turn
                        if (debugLevel >= 2 && scanDir > 0) System.out.println("            dual movement, primal turn");
                        double angleDelta = (double)(thisVal-prevVal)/(double)nParts * (Math.PI*.5);
                        double nextDualAng = dualAng + angleDelta;
                        if (nextDualAng > Math.PI)
                            nextDualAng -= 2*Math.PI;
                        else if (nextDualAng < -Math.PI)
                            nextDualAng += 2*Math.PI;
                        double nextDualR;
                        {
                            // use law of sines.
                            // don't think too hard about the scanDir=-1 case, in which case angleDelta is negative and the triangle is inside out... it just works.
                            double A = angleDelta;
                            double C = dualAng+Math.PI - primalAng;
                            double B = Math.PI - (A+C);
                            double b = dualR;
                            double c = b * (Math.sin(C)/Math.sin(B));
                            nextDualR = c;
                        }
                        double nextDualX = nextDualR * Math.cos(nextDualAng);
                        double nextDualY = nextDualR * Math.sin(nextDualAng);

                        if (drawDualFlag)
                        {
                            mg.drawLine(dualX, dualY,
                                        nextDualX, nextDualY,
                                        antiAliasFlag);

                            if (prevVal==prevPrevVal
                             || (thisVal>prevVal) != (prevVal>prevPrevVal))
                            {
                                if (scanDir < 0)
                                {
                                    mg.drawPoint(dualX, dualY, 5);
                                    mg.drawLine(0.,0.,
                                                dualX, dualY,
                                                antiAliasFlag);
                                }
                                else
                                    mg.drawPoint(dualX, dualY, 3);
                            }

                            if (scanDir > 0)
                            {
                                if (SQR(nextDualX)+SQR(nextDualY)
                                   > SQR(1) + SQR(2)) // XXX should be max distance of any corner of window from origin
                                    break;
                            }
                            else
                            {
                                if (SQR(nextDualX)+SQR(nextDualY) < SQR(1e-3)
                                 && centerHasStabilized)
                                    break;
                            }
                        }
                        if (drawRungsFlag &&
                            (prevVal!=prevPrevVal &&
                            (thisVal>prevVal != (prevVal>prevPrevVal))))
                        {
                            java.awt.Color savedColor = mg.getColor();
                            mg.setColor(dimPink);
                            mg.drawLine(primalX, primalY,
                                        dualX, dualY,
                                        antiAliasFlag);
                            mg.setColor(savedColor);
                        }

                        if (scanDir < 0)
                        {
                            double areaIncr = twiceTriangleArea(0.,0., dualX,dualY, nextDualX,nextDualY);
                            areaIncr = ABS(areaIncr);

                            if (area+areaIncr == area)
                            {
                                centerHasStabilized = true;
                                // don't break til it's all visually small enough too
                            }
                            //if (dualY != 0.) // experimenting-- if we omit first one, should sometimes assert-fail due to center being too low. seems to work.
                            {
                                area += areaIncr;

                                centerX = LERP(centerX, primalX, areaIncr/area);
                                centerY = LERP(centerY, primalY, areaIncr/area);
                                //PRINT(areaIncr);
                                //PRINT(areaIncr*primalX);
                                //PRINT(areaIncr*primalY);
                            }
                        }

                        dualAng = nextDualAng;
                        dualR = nextDualR;
                        dualX = nextDualX;
                        dualY = nextDualY;
                    }
                    prevPrevVal = prevVal;
                    prevVal = thisVal;
                }

                if (scanDir < 0 && drawPrimalFlag)
                {
                    mg.setColor(java.awt.Color.yellow);
                    mg.drawPoint(centerX, centerY, 5);
                    if (centerY <= 0.)
                    {
                        System.out.println("HEY! centerY is "+centerY);
                    }
                    assert(centerY > 0.);
                }

            } // for iScanDir
            if (debugLevel >= 1) System.out.println("    out drawSpiral "+(drawPrimalFlag?"primal":"")+(drawDualFlag?"dual":"")+(drawRungsFlag?",rungs":""));
        } // drawSpiral


        private void accelBackward()
        {
            boolean startAnimationFlag = theSpiralView.focusAnimationVelocity.get() == 0;
            theSpiralView.focusAnimationVelocity.set(theSpiralView.focusAnimationVelocity.get() - theSpiralView.focusQuantum);
            if (startAnimationFlag)
                startTheAnimation();
        }
        private void stepBackward()
        {
            theSpiralView.focusAnimationVelocity.set(0.);
            theSpiralView.focus.set(theSpiralView.focus.get() - theSpiralView.focusQuantum);
            theSpiralView.focus.set(fmod(theSpiralView.focus.get(), theSpiralModel.params.n.get()));
            theCanvas.repaint();
        }
        private void pause()
        {
            theSpiralView.focusAnimationVelocity.set(0.);
            theCanvas.repaint();
        }
        private void stepForward()
        {
            theSpiralView.focusAnimationVelocity.set(0.);
            theSpiralView.focus.set(theSpiralView.focus.get() + theSpiralView.focusQuantum);
            theSpiralView.focus.set(fmod(theSpiralView.focus.get(), theSpiralModel.params.n.get()));
            theCanvas.repaint();
        }
        private void accelForward()
        {
            boolean startAnimationFlag = theSpiralView.focusAnimationVelocity.get() == 0;
            theSpiralView.focusAnimationVelocity.set(theSpiralView.focusAnimationVelocity.get() + theSpiralView.focusQuantum);
            if (startAnimationFlag)
                startTheAnimation();
        }

        // actually this should probably be in a listener on focusAnimationVelocity
        // I probably have the thread-safety all wrong too
        // but then again I probably have it wrong for paint as well...
        // XXX paint really needs to take a synchronized snapshot of everything it needs, I think...
        // and, acquire a lock on the big things that don't change often but that are too expensive to snapshot
        // (the model).
        private javax.swing.Timer theTimer = null;
        private void startTheAnimation()
        {
            System.out.println("in startTheAnimation");
            if (theTimer == null)
            {
                System.out.println("    creating timer");
                theTimer = new javax.swing.Timer(animSleepMS.get(), new java.awt.event.ActionListener() {
                    public void actionPerformed(java.awt.event.ActionEvent e) {
                        if (eventVerbose >= 1) System.out.println("in timer action");

                        // TODO: make a synchronizedGet() and synchronizedSet() method to facilitate this?
                        double focusAnimationVelocitySnapshot;
                        synchronized(theSpiralView.focusAnimationVelocity)
                        {
                            focusAnimationVelocitySnapshot = theSpiralView.focusAnimationVelocity.get();
                        }
                        if (focusAnimationVelocitySnapshot == 0.)
                        {
                            System.out.println("    stopping timer");
                            theTimer.stop();
                        }

                        theCanvas.repaint();
                        int animSleepMSvalue = animSleepMS.get();
                        theTimer.setDelay(MAX(animSleepMSvalue, 0)); // in case it changed

                        if (false) // can set this to true to make the timing graph show time between firings
                        {
                            double now = timeSeconds();
                            startTimes.set(startTimes.size()-1, now);
                            endTimes.set(endTimes.size()-1, now);
                        }
                        if (eventVerbose >= 1) System.out.println("out timer action");
                    }
                });
            }
            System.out.println("    starting timer");
            theTimer.start();
            System.out.println("out startTheAnimation");
        }


    //
    // App-specific variables...
    //


        public SpiralModel.Params spiralModelParams = new SpiralModel.Params(); // gui copy, flushed to model when Regenerate button pressed
        public SpiralModel theSpiralModel = new SpiralModel();
        public SpiralView theSpiralView = new SpiralView();
#if 0
        public Listenable.Int animSpeed = new Listenable.Int(0, 1000*1000, 0);
#endif
        public Listenable.Int animSleepMS = new Listenable.Int(0, 1000*1000, 11); // 11 seems to be empirical sweet spot... still speeds up for a few frames every 5 seconds or so
        public Listenable.Boolean showTimingFlag = new Listenable.Boolean(false);
        public Listenable.Boolean showNonTimingFlag = new Listenable.Boolean(true);
        public Listenable.Boolean showFocusInControlPanelFlag = new Listenable.Boolean(false); // seems like a bad idea in general
        public Listenable.Boolean showVsyncLapsesFlag = new Listenable.Boolean(false);
        public JRow focusInControlPanelRow = null;


        private java.awt.Component theCanvas = null;
        //private java.awt.Component theHelpWindow = null;
        private JFrame theMainAppletWindow = null;
        private JFrame theControlPanelWindow = null;
        private JFrame theHelpWindow = null;
        private Listenable.String windowTitle = new Listenable.String("Spiral Applet");

        private Listenable.Listener showRungsFlagListener = null;
        private Listenable.Listener focusListener = null;
        private Listenable.Listener pixelsPerPartListener = null;
        private Listenable.Listener showTimingFlagListener = null;
        private Listenable.Listener showNonTimingFlagListener = null;
        private Listenable.Listener showFocusInControlPanelListener = null;


    //
    // Applet-generic member variables...
    //
        private GraphicsAntiAliasingSetter graphicsAntiAliasingSetter;
        private int eventVerbose = 0; // can set with eventVerbose=1 on command line
        private static int nonEventVerbose = 0; // so static classes can refer to it
        private boolean antiAliasingFlag = false;
        private boolean implementAntiAliasingInHardware = true; // XXX should have a better name for this-- really mean let java runtime do it
        private boolean doubleBufferFlag = false; // TODO: swing does this for us... can get rid of it, as soon as I figure out how to do the magnifying glass without it
        private java.awt.Image backBufferImage = null;
        private MyGraphics3D mostRecentGraphics = null;
        private int nPaints = 0;


    public static class JTextFieldForString extends JValidatingTextField
    {
        private Listenable.Listener listener; // need to keep a strong ref to it for as long as I'm alive
        public JTextFieldForString(final Listenable.String s)
        {
            super(s.get());
            s.addListener(listener = new Listenable.Listener() {
                public void valueChanged()
                {
                    setText(s.get());
                }
            });
            addActionListener(new java.awt.event.ActionListener() {
                public void actionPerformed(java.awt.event.ActionEvent e)
                {
                    s.set(getText());
                }
            });
        }
    } // JTextFieldForString



    // Stolen from MC4DControlPanel.java
    public static class JTextFieldForNumber extends JValidatingTextField
    {
        private Listenable.Listener listener; // need to keep a strong ref to it for as long as I'm alive
        private Listenable.Number f;

        // override super's
        public boolean validate(String text)
        {
            try {
                // attempt to parse, ignore return value
                if (f instanceof Listenable.Int)
                    Integer.parseInt(text);
                else
                    Double.parseDouble(text);
                return true;
            } catch (Exception e) {
                return false;
            }
        }

        // common code we call in a couple of places
        private void updateText(Listenable.Number f)
        {
            if (f instanceof Listenable.Int)
                setText(""+((Listenable.Int)f).get());
            else if (f instanceof Listenable.Float)
                setText(""+((Listenable.Float)f).get());
            else
                setText(""+(float)((Listenable.Double)f).get()); // XXX ARGH! we lose precision with this (float) cast, but if we don't do it, we can get, for example, 37.092999999999996 which looks lame.  should figure out another way to prevent that.
        }

        public JTextFieldForNumber(final Listenable.Number f)
        {
            super(f instanceof Listenable.Int ? ""+((Listenable.Int)f).max() // XXX not quite right, min may be longer string than max
                   : "99.99"); // give it enough space for 99.999 (on my computer, always seems to give an extra space, which we don't need)
            this.f = f;
            updateText(f);
            f.addListener(listener = new Listenable.Listener() {
                public void valueChanged()
                {
                    updateText(f);
                }
            });
            addActionListener(new java.awt.event.ActionListener() {
                public void actionPerformed(java.awt.event.ActionEvent e)
                {
                    try
                    {
                        f.setDouble(Double.valueOf(getText()).doubleValue());
                    }
                    catch (java.lang.NumberFormatException nfe)
                    {
                        // maybe should print an error message or something
                        updateText(f);
                    }
                }
            });
        }

        public java.awt.Dimension getPreferredSize()
        {
            //System.out.println("in JTextFieldForNumber.getPreferredSize()");
            // default seems taller than necessary
            // on my computer... and in recent VMs it's even worse
            // (changed from 29 to 31).
            // Fudge it a bit...
            // XXX not sure this will look good on all systems... if it doesn't, we can just remove it
            // XXX hmm, actually makes things mess up when growing and shrinking, that's weird
            java.awt.Dimension preferredSize = super.getPreferredSize();
            //System.out.println("textfield.super.preferredSize() = "+preferredSize);
            if (true)
                preferredSize.height -= 2;

            // XXX another hack, wtf?
            if (true)
            {
                if (f instanceof Listenable.Int)
                    preferredSize.width = 55; // big enough to hold 1,000,000 comfortably-- bleah
                else
                {
                    //preferredSize.width = 100;
                    preferredSize.width = 50; // for this app, this is plenty, although it's bogus in general
                }
            }

            //System.out.println("out JTextFieldForNumber.getPreferredSize(), returning "+preferredSize);
            return preferredSize;
        }
        // weird, the following is called during horizontal shrinking
        // but not during horizontal expanding... if we don't do this too
        // then it looks wrong when shrinking.  what a hack...
        public java.awt.Dimension getMinimumSize()
        {
            //System.out.println("in JTextFieldForNumber.getMinimumSize()");
            java.awt.Dimension minimumSize = super.getMinimumSize();
            //System.out.println("textfield.super.minimumSize() = "+minimumSize);
            if (true)
                minimumSize.height -= 2;

            // XXX another hack, wtf?
            if (true)
            {
                if (f instanceof Listenable.Int)
                    minimumSize.width = 55;
                else
                    minimumSize.width = 100;
            }

            //System.out.println("out JTextFieldForNumber.getMinimumSize(), returning "+minimumSize);
            return minimumSize;
        }
    } // JTextFieldForNumber


    public static class JCheckBoxForBoolean extends JCheckBox
    {
        private Listenable.Listener listener; // need to keep a strong ref to it for as long as I'm alive
        public JCheckBoxForBoolean(String name, final Listenable.Boolean b)
        {
            super(name);
            setSelected(b.get());
            addItemListener(new java.awt.event.ItemListener() {
                public void itemStateChanged(java.awt.event.ItemEvent e)
                {
                    b.set(isSelected());
                }
            });
            b.addListener(listener = new Listenable.Listener() {
                public void valueChanged()
                {
                    setSelected(b.get());
                }
            });
        }
    } // JCheckBoxForBoolean

    public static class JSliderForFloat extends JSlider
    {
        private Listenable.Listener listener; // need to keep a strong ref to it for as long as I'm alive

        // private helper function
        private void updateThumb(Listenable.Number f)
        {
            double value = f.getDouble();
            double defaultValue = f.defaultDouble();
            double frac = (value-f.minDouble())/(f.maxDouble()-f.minDouble());

            //setValue((int)(getMinimum() + ((getMaximum()-getVisibleAmount())-getMinimum())*frac));
            setValue((int)(getMinimum() + (getMaximum()-getMinimum())*frac));
        }

        public JSliderForFloat(final Listenable.Number f)
        {
            // 3 significant digits seems reasonable...
            /*
            super(JSlider.HORIZONTAL,
                  (int)Math.round(f.minDouble()*1000),
                  (int)Math.round(f.maxDouble()*1000),
                  (int)Math.round(f.getDouble())*1000);
            */
            super(JSlider.HORIZONTAL, 0, 1000, 500);

            if (false)
            {
                PRINT(getMinimum());
                PRINT(getMaximum());
                PRINT(getValue());
            }

            setMinorTickSpacing(1);  // .001 units
            setMajorTickSpacing(10); // .01 units
            f.addListener(listener = new Listenable.Listener() {
                public void valueChanged()
                {
                    updateThumb(f);
                }
            });
            addChangeListener(new javax.swing.event.ChangeListener() {
                public void stateChanged(javax.swing.event.ChangeEvent e)
                {
                    if (false)
                    {
                        System.out.println("==================");
                        System.out.println("    min = "+getMinimum());
                        System.out.println("    max = "+getMaximum());
                        System.out.println("    max-min = "+(getMaximum()-getMinimum()));
                        System.out.println("    getValue() = "+getValue());
                        System.out.println("    getMinorTickSpacing() = "+getMinorTickSpacing());
                        System.out.println("    getMajorTickSpacing() = "+getMajorTickSpacing());
                        System.out.println("    getSize() = "+getSize());
                        System.out.println("    getPreferredSize() = "+getPreferredSize());
                    }
                    // Doing the following in double precision makes a difference;
                    // if we do it in float, we get ugly values in the textfield
                    double frac = (double)(getValue()-getMinimum())
                                / (double)(getMaximum()-getMinimum());
                    f.setDouble(f.minDouble() + frac*(f.maxDouble()-f.minDouble()));
                    // will trigger valueChanged()
                    // which will call updateThumb()
                }
            });
            updateThumb(f); // because we fucked it up in the contructor?
        }
    } // JSliderForFloat

    // nice utility, maybe move to donhatchsw
    public static void drawPixmapCentered(java.awt.Graphics g,
                                          java.awt.Dimension size,
                                          java.awt.Color asciiToColor[],
                                          String[] rows)
    {
        if (false)
        {
            // hack-- pad with the color at 0,0
            g.setColor(asciiToColor[rows[0].charAt(0)]);
            PRINT(size.width);
            PRINT(size.height);
            g.fillRect(0,0, size.width,size.height);
        }

        int x0 = (size.width - rows[0].length())/2;
        int y0 = (size.height - rows.length)/2;
        java.awt.Color prevColor = null;
        FORI (iRow, rows.length)
        {
            String row = rows[iRow];
            int nCols = row.length();
            FORI (iCol, nCols)
            {
                char c = row.charAt(iCol);
                java.awt.Color color = asciiToColor[c];
                if (color != null)
                {
                    if (color != prevColor)
                    {
                        g.setColor(color);
                        prevColor = color;
                    }
                    g.fillRect(x0+iCol, y0+iRow, 1, 1);
                }
            }
        }
    } // drawPixmapCentered


    // make it like a JLabel as much as possible, but text selectable
    private static void makeTextComponentLikeLabel(JTextComponent textComponent)
    {
        textComponent.setEditable(false);
        textComponent.setDisabledTextColor(java.awt.Color.black);
        textComponent.setBackground(null); // same as JLabel
        textComponent.setBorder(null); // same as JLabel
        textComponent.setEnabled(true); // otherwise not selectable
    }

    static JRow makeIncrementableTextFieldForInt(final Listenable.Int f, final String name, final int increment)
    {
        final java.awt.Color asciiToColor[] = new java.awt.Color[128];
        asciiToColor[' '] = null;
        asciiToColor['b'] = java.awt.Color.black;
        return new JRow() {{
            add(new JRepeatingButton("") {
                public java.awt.Dimension getPreferredSize() { return new java.awt.Dimension(11,11); }
                public java.awt.Dimension getMinimumSize()   { return new java.awt.Dimension(11,11); }
                public void paint(java.awt.Graphics g)
                {
                    super.paint(g);
                    drawPixmapCentered(g, getSize(), asciiToColor,
                                       new String[] {
                                          "bbb bbb",
                                       });
                }
            {
                addActionListener(new java.awt.event.ActionListener() {
                    public void actionPerformed(java.awt.event.ActionEvent e)
                    {
                        f.set(f.get()-increment);
                    }
                });
                setToolTipText("<html>decrement "+name+"</html>");
            }});
            add(new JTextFieldForNumber(f));
            add(new JRepeatingButton("") {
                public java.awt.Dimension getPreferredSize() { return new java.awt.Dimension(11,11); }
                public java.awt.Dimension getMinimumSize()   { return new java.awt.Dimension(11,11); }
                public void paint(java.awt.Graphics g)
                {
                    super.paint(g);
                    drawPixmapCentered(g, getSize(), asciiToColor,
                                       new String[] {
                                          " b   b ",
                                          "bbb bbb",
                                          " b   b ",
                                       });
                }
            {
                addActionListener(new java.awt.event.ActionListener() {
                    public void actionPerformed(java.awt.event.ActionEvent e)
                    {
                        f.set(f.get()+increment);
                    }
                });
                setToolTipText("<html>increment "+name+"</html>");
            }});
        }};
    } // makeIncrementableTextFieldForNumber




    private static java.lang.reflect.Method nanoTimeMethod = null;
    {
        try {
            nanoTimeMethod = System.class.getMethod("nanoTime", new Class[]{});
        }
        catch (NoSuchMethodException e) {System.out.println("no such method exception!");}
    }
    // System.nanoTime().
    // don't call this unless you know nanoTimeMethod != null.
    private static long System_nanoTime()
    {
        try {
            // object allocation here is a bummer.
            // maybe better to compile using javac >= 1.4
            // but with flag saying create class files for earlier jvm?
            Object answer = nanoTimeMethod.invoke(null, new Object[]{});
            return ((Long)answer).longValue();
        }
        catch (IllegalAccessException e) {assert(false); return 0L;}
        catch (java.lang.reflect.InvocationTargetException e) {assert(false); return 0L;}
    }

    // Time in seconds from when we initialize the times,
    // using System.nanoTime() if it exists (jvm >= 1.4),
    // otherwise System.currentTimeMillis().
    private static double timeSeconds()
    {
        boolean useNanoTime = (nanoTimeMethod != null);
        if (useNanoTime)
            return (double)(System_nanoTime() - nanos0) / 1e9;
        else
            return (double)(System.currentTimeMillis() - millis0) / 1e3;
    }

    private static long millis0 = System.currentTimeMillis();
    private static long nanos0 = (nanoTimeMethod!=null ? System_nanoTime() : 0L);




    //
    // Main...
    //
    public static void main(final String args[])
    {
        if (false) // turn this on to get a crude little timing test
        {
            if (nanoTimeMethod != null)
            {
                FORI (ii,100)
                {
                    {
                        long m0 = System.currentTimeMillis();
                        long n0 = System_nanoTime();
                        FORI (i, 999)
                            System.currentTimeMillis();
                        long m1 = System.currentTimeMillis();
                        long n1 = System_nanoTime();
                        System.out.println("1000 m's and 1 n: "+(m1-m0)+" m");
                        System.out.println("1000 m's and 1 n: "+(n1-n0)+" n");
                    }
                    {
                        long n0 = System_nanoTime();
                        long m0 = System.currentTimeMillis();
                        FORI (i, 999)
                            System.currentTimeMillis();
                        long n1 = System_nanoTime();
                        long m1 = System.currentTimeMillis();
                        System.out.println("1000 m's and 1 n: "+(m1-m0)+" m");
                        System.out.println("1000 m's and 1 n: "+(n1-n0)+" n");
                    }
                }
                FORI (ii,100)
                {
                    {
                        long m0 = System.currentTimeMillis();
                        long n0 = System_nanoTime();
                        FORI (i, 999)
                            System_nanoTime();
                        long m1 = System.currentTimeMillis();
                        long n1 = System_nanoTime();
                        System.out.println("1 m and 1000 n's: "+(m1-m0)+" m");
                        System.out.println("1 m and 1000 n's: "+(n1-n0)+" n");
                    }
                    {
                        long n0 = System_nanoTime();
                        long m0 = System.currentTimeMillis();
                        FORI (i, 999)
                            System_nanoTime();
                        long n1 = System_nanoTime();
                        long m1 = System.currentTimeMillis();
                        System.out.println("1 m and 1000 n's: "+(m1-m0)+" m");
                        System.out.println("1 m and 1000 n's: "+(n1-n0)+" n");
                    }
                }

                System.out.println();
                System.exit(0);
            }
        }
        if (false)
        {
            // http://stackoverflow.com/questions/12805373/java-modulo-operator
            // surprising!
            PRINT(fmod(5.59, 2));
            PRINT(5.59 % 2); // 1.5899999999999999
            PRINT(5.59 - 2); // 3.59
            PRINT(5.59 - 4); // 1.5899999999999999
            PRINT(5.59 - 2 - 2); // 1.5899999999999999
            PRINT(5.59); // 5.59
            PRINT(3.59); // 3.59
            PRINT(1.59); // 1.59
        }

        System.out.println("in main");
        System.out.println("    java "+System.getProperty("java.version"));


        final SpiralApplet applet = new SpiralApplet();

        final JFrame frame = new JFrame(applet.windowTitle.get());

        // TODO: what was I thinking?  can't use 1.2 any more?? need to use reflection to see whether I can do this
        //frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); // supposedly exists since java 1.4, but I can see starting in 1.3, weird
        frame.getContentPane().add(applet);

        //dumpComponentHierarchy(frame, 0, 0, 1);

        // the following seems to be necessary, or getParameter() will crash, at least in 1.4.  Want to send params from command line anyway.
        applet.setStub(new java.applet.AppletStub() {
             public void appletResize(int width, int height)
                 { /* should resize frame, but a SpiralApplet never asks to be resized */ }
             public java.applet.AppletContext getAppletContext() { return null;}
             public java.net.URL getCodeBase() { return null; }
             public java.net.URL getDocumentBase() { return null; }
             public String getParameter(String name)
             {
                 // case insensitive... and unfortunately there's no
                 // startsWithIgnoreCase
                 String prefix = name.toLowerCase() + "=";
                 int i;
                 FOR (i, args.length)
                     if (args[i].toLowerCase().startsWith(prefix))
                         return args[i].substring(prefix.length());
                 return null;
             }
             public boolean isActive() { return true; }
        });

        applet.init();
        applet.start();

        frame.setLocation(10, 10);
        frame.setSize(601,600);

        frame.setVisible(true);

        applet.theMainAppletWindow = frame;


        // for benefit of any debugging function that wants to loop over frames...
        applet.theControlPanelWindow.setName("control panel window");
        applet.theMainAppletWindow.setName("main applet window");
        applet.theHelpWindow.setName("help");


        // why can't we get here in any toolkit ever?
        System.out.println("out main");
    } // main

} // class SpiralApplet
