/*
    Notes:
        Uses System.nanoTime which requires java >= 1.4

    BUG: on assert fail in paint, displayed line number is too small by a few lines I think
    BUG: ending criteria isn't quite right-- should end when *all* contributing things have gone off screen or become tiny, need to clean up logic for that
    BUG: as soon as a tooltip is shown spilling over edge of window, performance went down, forevermore??

    TODO: make everything area (not twice-area) based
    TODO: non-rotating mode
    TODO: delta mode approximating arbitrary slopes
    TODO: saturation slider
    TODO: keystrokes to change orientation
    TODO: smooth out animation when going very slowly
    TODO: gui for scale
    TODO: allow dragging ticker
    TODO: allow dragging points on spiral? hmm
    todo: check out LWJGL for consistent frame rate?
    TODO: maybe JavaFX? she says it works well for vsync: http://www.java-gaming.org/index.php?topic=27763.0.  ah good, it's included in jdk 7.
    TODO: use javax.swing.Timer instead of my own custom thread
          WHOA! as soon as I switched to a timer, I'm getting consistent timings! nice 60fps. wtf?
          well except every 5 seconds or so, it gives far faster for a few frames in a row. argh!
          sleeping for 11 ms seems to be a sweet spot.  screwy.
          and a few days later, it's not happening any more... it's going full speed again, even with the timer.  wtf??
          but then a few minutes later, it's throttled again.  weird weird weird.
          actually maybe when non-throttled, I'd been running it for a while?
    TODO: allow saving/restoring window positions, but in a discoverable non-evil way
    TODO: can we automatically detect missing @Override's?  the web says not using javac, but Eclipse can do it I think
*/

#include "macros.h"

// So can compile in pre-1.4,
// we use these instead of java.awt.event.MouseEvent.BUTTON1 etc.
#define java_awt_event_MouseEvent_BUTTON1 1
#define java_awt_event_MouseEvent_BUTTON2 2
#define java_awt_event_MouseEvent_BUTTON3 3

import com.donhatchsw.util.Arrays;
import com.donhatchsw.util.MyMath;
import com.donhatchsw.util.VecMath;
//import com.donhatchsw.util.SortStuff;
import com.donhatchsw.util.Listenable;
import com.donhatchsw.compat.ArrayList;
//import com.donhatchsw.compat.IntArrayList;
//import com.donhatchsw.compat.DoubleArrayList;

import com.donhatchsw.awt.ColLayout;
import com.donhatchsw.awt.JRow;
import com.donhatchsw.awt.JCol;
import com.donhatchsw.awt.JTablePanel;

import javax.swing.ButtonGroup;
import javax.swing.JFrame;
import javax.swing.JPanel;
import javax.swing.JApplet;
import javax.swing.JLabel;
import javax.swing.JButton;
import javax.swing.JRadioButton;
import javax.swing.text.JTextComponent;
import javax.swing.JTextField;
import javax.swing.JTextArea;
import javax.swing.JToggleButton;
import javax.swing.JScrollPane;
import javax.swing.JSeparator;
import javax.swing.JSlider;
import javax.swing.JMenuBar;
import javax.swing.JMenu;
import javax.swing.JMenuItem;
//import javax.swing.JComboBox;
import javax.swing.JCheckBox;


public class SpiralApplet
    extends JApplet
{
    //
    // Utilities for applet stuff...
    //
        private String getParameterString(String paramName,
                                       String defaultValue)
        {
            String paramValueString = getParameter(paramName);
            if (paramValueString != null)
                return paramValueString;
            else
                return defaultValue;
        }
        private int getParameterInt(String paramName,
                                    int defaultValue)
        {
            String paramValueString = getParameter(paramName);
            if (paramValueString != null)
            {
                try
                {
                    return Integer.decode(paramValueString).intValue();
                }
                catch (NumberFormatException e)
                {
                    return 0;
                }
            }
            else
                return defaultValue;
        }
        private double getParameterDouble(String paramName,
                                          double defaultValue)
        {
            String paramValueString = getParameter(paramName);
            if (paramValueString != null)
            {
                try
                {
                    return Double.parseDouble(paramValueString);
                }
                catch (NumberFormatException e)
                {
                    return 0;
                }
            }
            else
                return defaultValue;
        }
        private boolean getParameterBoolean(String paramName,
                                            boolean defaultValue)
        {
            String paramValueString = getParameter(paramName);
            if (paramValueString != null)
            {
                // Too simplistic, only honors case-sensitive "true"
                //return Boolean.valueOf(paramValueString).booleanValue();

                try
                {
                    int n = Integer.decode(paramValueString).intValue();
                    return n != 0;
                }
                catch (NumberFormatException e)
                {
                    if (paramValueString.equalsIgnoreCase("true")
                     || paramValueString.equalsIgnoreCase("yes")
                     || paramValueString.equalsIgnoreCase("t")
                     || paramValueString.equalsIgnoreCase("y"))
                        return true;
                    return false;
                }
            }
            else
                return defaultValue;
        }

        // ButtonGroup doesn't support *at most* one checked.
        // Implement one that does.
        private static class ButtonGroupThatAllowsNone
        {
            private ArrayList buttons = new ArrayList();
            private ArrayList actionListeners = new ArrayList();
            public void add(final JToggleButton button) // checkbox or radio button
            {
                java.awt.event.ActionListener actionListener = new java.awt.event.ActionListener() {
                    @Override
                    public void actionPerformed(java.awt.event.ActionEvent e)
                    {
                        if (button.isSelected())
                        {
                            // then deselect everyone else
                            int nButtons = buttons.size();
                            for (int i = 0; i < nButtons; ++i)
                            {
                                JToggleButton otherButton = (JToggleButton)buttons.get(i);
                                if (otherButton != button)
                                    if (otherButton.isSelected())
                                        otherButton.setSelected(false);
                            }
                        }
                    }
                };
                button.addActionListener(actionListener);
                buttons.add(button);
                actionListeners.add(actionListener);
            }
        }; // class ButtonGroupThatAllowsNone
        // That was fun, let's make another that enforces
        // that the selection is a prefix of the set of buttons.
        private static class PrefixButtonGroup
        {
            private ArrayList buttons = new ArrayList();
            private ArrayList actionListeners = new ArrayList();
            public void add(final JToggleButton button) // checkbox or radio button
            {
                java.awt.event.ActionListener actionListener = new java.awt.event.ActionListener() {
                    @Override
                    public void actionPerformed(java.awt.event.ActionEvent e)
                    {
                        int nButtons = buttons.size();
                        if (button.isSelected())
                        {
                            // then select everyone before me
                            FORI (i, nButtons)
                            {
                                JToggleButton otherButton = (JToggleButton)buttons.get(i);
                                if (otherButton == button)
                                    break;
                                if (!otherButton.isSelected())
                                    otherButton.setSelected(true);
                            }
                        }
                        else
                        {
                            // deselect everyone after me
                            FORIDOWN(i, nButtons)
                            {
                                JToggleButton otherButton = (JToggleButton)buttons.get(i);
                                if (otherButton == button)
                                    break;
                                if (otherButton.isSelected())
                                    otherButton.setSelected(false);
                            }
                        }
                    }
                };
                button.addActionListener(actionListener);
                buttons.add(button);
                actionListeners.add(actionListener);
            }
        } // PrefixButtonGroup

        // http://tech-eureka.blogspot.com/2010/12/how-to-implement-repeating-swing.html
        private static class JRepeatingButton extends JButton
        {
            public JRepeatingButton(String text)
            {
                super(text);
            }
            public void addActionListener(final java.awt.event.ActionListener actionListener)
            {
                addMouseListener(new java.awt.event.MouseAdapter() {
                    private javax.swing.Timer repeatTimer = null;
                    private java.awt.event.ActionEvent synthesizedActionEvent = null;
                    @Override
                    public void mousePressed(java.awt.event.MouseEvent mouseEvent)
                    {
                        synthesizedActionEvent = new java.awt.event.ActionEvent(
                            JRepeatingButton.this,
                            java.awt.event.ActionEvent.ACTION_PERFORMED,
                            JRepeatingButton.this.getText(),
                            mouseEvent.getModifiers());
                        // the ctor that takes "when" introduced some time in (1.3, 1.6]
                        // so don't use it, so we can compile using 1.3
                        actionListener.actionPerformed(synthesizedActionEvent); // initial execution

                        repeatTimer = new javax.swing.Timer(100, new java.awt.event.ActionListener() {
                            @Override
                            public void actionPerformed(java.awt.event.ActionEvent timerActionEvent)
                            {
                                actionListener.actionPerformed(synthesizedActionEvent);
                            }
                        });
                        repeatTimer.setInitialDelay(500);
                        repeatTimer.start();
                    }
                    @Override
                    public void mouseReleased(java.awt.event.MouseEvent arg0)
                    {
                        repeatTimer.stop();
                        repeatTimer = null;
                        synthesizedActionEvent = null;
                    }
                });
            }
        } // JRepeatingButton

        // A textfield that turns green or red when editing and not yet committed.
        // Esc reverts.
        private static class JValidatingTextField extends JTextField
        {
            // subclass can override this
            public boolean validate(String text)
            {
                return true; // it's all good by default
            }

            private String committedText;
            public JValidatingTextField(String text)
            {
                super(text);
                committedText = getText();

                getDocument().addDocumentListener(new javax.swing.event.DocumentListener() {
                    private void anyUpdate(javax.swing.event.DocumentEvent e)
                    {
                        if (isEditable()) // use this as hint-- if not editable, probably makeTextComponentLikeLabel was called
                        {
                            if (!getText().equals(committedText)) // TODO: == doesn't work here?  I forget the difference
                            {
                                if (validate(getText()))
                                {
                                    // TODO: if value semantically equals committed value, turn white instead.  hmm, can build this into validate() by having it return a value (Object), maybe?
                                    setBackground(new java.awt.Color(192,255,192)); // light green
                                }
                                else
                                    setBackground(new java.awt.Color(255,192,192)); // pink
                            }
                            else
                                setBackground(java.awt.Color.white);
                        }
                    }
                    @Override
                    public void insertUpdate(javax.swing.event.DocumentEvent e)  {anyUpdate(e);}
                    @Override
                    public void removeUpdate(javax.swing.event.DocumentEvent e)  {anyUpdate(e);}
                    @Override
                    public void changedUpdate(javax.swing.event.DocumentEvent e) {anyUpdate(e);}
                });
                addKeyListener(new java.awt.event.KeyAdapter() {
                    @Override
                    public void keyPressed(java.awt.event.KeyEvent e)
                    {
                        if (e.getKeyCode() == java.awt.event.KeyEvent.VK_ESCAPE)
                        {
                            setText(committedText);
                        }
                    }
                });
                addActionListener(new java.awt.event.ActionListener() {
                    @Override
                    public void actionPerformed(java.awt.event.ActionEvent e)
                    {
                        if (validate(getText()))
                        {
                            committedText = getText();
                            setBackground(java.awt.Color.white);
                        }
                    }
                });
            }
            public void setText(String text)
            {
                super.setText(text);
                if (isEditable()) // use this as hint-- if not editable, probably makeTextComponentLikeLabel was called
                {
                    if (validate(getText()))
                    {
                        committedText = getText();
                        setBackground(java.awt.Color.white);
                    }
                }
            }
        } // JValidatingTextField


        private static class SpiralAppletControlPanel
            extends JPanel
        {
            public SpiralAppletControlPanel(final SpiralApplet applet)
            {
                java.awt.Container contentPane = this;

                contentPane.setLayout(new ColLayout());

                // used as "fill" argument to add()
                final java.awt.GridBagConstraints stretchx = new java.awt.GridBagConstraints(){{fill=HORIZONTAL;weightx=1.;}};
                final java.awt.GridBagConstraints stretchy = new java.awt.GridBagConstraints(){{fill=VERTICAL;weighty=1.;}};
                final java.awt.GridBagConstraints stretchxy = new java.awt.GridBagConstraints(){{fill=BOTH;weightx=weighty=1.;}};
                final java.awt.GridBagConstraints rightjustify = new java.awt.GridBagConstraints(){{anchor=EAST;}};
                final java.awt.GridBagConstraints centerjustify = new java.awt.GridBagConstraints(){{anchor=CENTER;}};

                // used as arg to setMargin()
                final java.awt.Insets nomargin = new java.awt.Insets(0,0,0,0);


                final java.awt.Color asciiToColor[] = new java.awt.Color[128];
                asciiToColor[' '] = null;
                asciiToColor['b'] = java.awt.Color.black;
                asciiToColor['g'] = new java.awt.Color(128,128,128); // 50% gray
                asciiToColor['r'] = java.awt.Color.red;

                /*
                contentPane.add(new JSeparator(), stretchx);
                contentPane.add(new JLabel("File/Edit"));
                add(new JRow() {{
                    add(new JLabel("        ")); // indent a bit
                    add(new JCol() {{
                        // ...
                    }});
                }});
                */
                contentPane.add(new JSeparator(), stretchx);
                contentPane.add(new JLabel("Model"));
                add(new JRow() {{
                    add(new JLabel("        ")); // indent a bit
                    add(new JCol() {{
                        add(new JTablePanel() {{
                            {
                                final String toolTipText = "period";
                                add(new JLabel("Period:") {{
                                    setToolTipText(toolTipText);
                                }});
                                add(makeIncrementableTextFieldForInt(applet.spiralModelParams.n, toolTipText, 2));
                                add(new JLabel(" "));
                                add(new JTextFieldForNumber(applet.theSpiralModel.params.n) {{
                                    makeTextComponentLikeLabel(this);
                                    setToolTipText(toolTipText);
                                }});
                            }
                            advanceRow();
                            {
                                final String toolTipText = "number of parts into which to break 90 degrees";
                                add(new JLabel("Number of parts:") {{
                                    setToolTipText(toolTipText);
                                }});
                                add(makeIncrementableTextFieldForInt(applet.spiralModelParams.nParts, toolTipText, 1));
                                add(new JLabel(" "));
                                add(new JTextFieldForNumber(applet.theSpiralModel.params.nParts) {{
                                    makeTextComponentLikeLabel(this);
                                    setToolTipText(toolTipText);
                                }});
                            }
                            advanceRow();
                            {
                                final String toolTipText = "seed";
                                add(new JLabel("Random seed:") {{
                                    setToolTipText(toolTipText);
                                }});

                                add(makeIncrementableTextFieldForInt(applet.spiralModelParams.randomSeed, toolTipText, 1));
                                add(new JLabel(" "));
                                add(new JTextFieldForNumber(applet.theSpiralModel.params.randomSeed) {{
                                    makeTextComponentLikeLabel(this);
                                    setToolTipText(toolTipText);
                                }});
                            }
                        }});
                        add(new JRow() {
                            private ButtonGroup buttonGroup = new ButtonGroup();
                        {
                            add(new JLabel("Delta style:"));
                            add(new JLabel("  "));
                            add(new JRadioButton("<html>&plusmn;1</html>", applet.spiralModelParams.deltaStyle.get()==SpiralModel.DELTASTYLE_1) {{
                                setMargin(nomargin);
                                buttonGroup.add(this);
                                addActionListener(new java.awt.event.ActionListener() {
                                    @Override
                                    public void actionPerformed(java.awt.event.ActionEvent e)
                                    {
                                        applet.spiralModelParams.deltaStyle.set(SpiralModel.DELTASTYLE_1);
                                        // no need to repaint
                                    }
                                });
                            }});
                            add(new JRadioButton("Any", applet.spiralModelParams.deltaStyle.get()==SpiralModel.DELTASTYLE_ANY) {{
                                setMargin(nomargin);
                                buttonGroup.add(this);
                                addActionListener(new java.awt.event.ActionListener() {
                                    @Override
                                    public void actionPerformed(java.awt.event.ActionEvent e)
                                    {
                                        applet.spiralModelParams.deltaStyle.set(SpiralModel.DELTASTYLE_ANY);
                                        // no need to repaint
                                    }
                                });
                            }});
                            add(new JRadioButton("<html>&plusmn;1 wrap</html>", applet.spiralModelParams.deltaStyle.get()==SpiralModel.DELTASTYLE_1_WRAP) {{
                                setMargin(nomargin);
                                buttonGroup.add(this);
                                addActionListener(new java.awt.event.ActionListener() {
                                    @Override
                                    public void actionPerformed(java.awt.event.ActionEvent e)
                                    {
                                        applet.spiralModelParams.deltaStyle.set(SpiralModel.DELTASTYLE_1_WRAP);
                                        // no need to repaint
                                    }
                                });
                            }});
                        }});

                        add(new JButton("Regenerate") {{
                            setMargin(nomargin);
                            // XXX TODO: red if params out of date
                            addActionListener(new java.awt.event.ActionListener() {
                                @Override
                                public void actionPerformed(java.awt.event.ActionEvent e)
                                {
                                    applet.theSpiralModel.init(applet.spiralModelParams.n.get(), applet.spiralModelParams.nParts.get(), applet.spiralModelParams.deltaStyle.get(), applet.spiralModelParams.randomSeed.get());

                                    applet.theSpiralView.focus.modEquals(
                                        applet.theSpiralModel.params.n.get(), 1);

                                    applet.theCanvas.repaint();
                                }
                            });
                        }});
                    }});
                }});
                contentPane.add(new JSeparator(), stretchx);
                contentPane.add(new JLabel("View"));
                add(new JRow() {{
                    add(new JLabel("        ")); // indent a bit
                    add(new JCol() {{
                        add(new JRow() {{
                            add(new JButton("reset focus to") {{
                                setMargin(nomargin);
                                addActionListener(new java.awt.event.ActionListener() {
                                    @Override
                                    public void actionPerformed(java.awt.event.ActionEvent e)
                                    {
                                        applet.theSpiralView.focus.set(applet.theSpiralView.resetFocusTo.get(),1);
                                        applet.theCanvas.repaint();
                                    }
                                });
                            }}, centerjustify);
                            add(new JTextFieldForNumber(applet.theSpiralView.resetFocusTo));
                        }});
                        add(new JRow() {{
                            add(new JRepeatingButton("") {
                                @Override
                                public java.awt.Dimension getPreferredSize() { return new java.awt.Dimension(20,20); }
                                @Override
                                public java.awt.Dimension getMinimumSize()   { return new java.awt.Dimension(20,20); }
                                @Override
                                public void paint(java.awt.Graphics g)
                                {
                                    super.paint(g);
                                    drawPixmapCentered(g, getSize(), asciiToColor,
                                                       new String[] {
                                                          "   b  b",
                                                          "  bb bb",
                                                          " bbbbbb",
                                                          "bbbbbbb",
                                                          " bbbbbb",
                                                          "  bb bb",
                                                          "   b  b",
                                                       });
                                }
                            {
                                addActionListener(new java.awt.event.ActionListener() {
                                    @Override
                                    public void actionPerformed(java.awt.event.ActionEvent e)
                                    {
                                        applet.accelBackward();
                                    }
                                });
                                setToolTipText("<html>accelerate backward<br>(shift-left-arrow key)</html>");
                            }}, stretchxy);
                            add(new JRepeatingButton("") {
                                @Override
                                public java.awt.Dimension getPreferredSize() { return new java.awt.Dimension(20,20); }
                                @Override
                                public java.awt.Dimension getMinimumSize()   { return new java.awt.Dimension(20,20); }
                                @Override
                                public void paint(java.awt.Graphics g)
                                {
                                    super.paint(g);
                                    drawPixmapCentered(g, getSize(), asciiToColor,
                                                       new String[] {
                                                          "   b bb",
                                                          "  bb bb",
                                                          " bbb bb",
                                                          "bbbb bb",
                                                          " bbb bb",
                                                          "  bb bb",
                                                          "   b bb",
                                                       });
                                }
                            {
                                addActionListener(new java.awt.event.ActionListener() {
                                    @Override
                                    public void actionPerformed(java.awt.event.ActionEvent e)
                                    {
                                        applet.stepBackward();
                                    }
                                });
                                setToolTipText("<html>step backward<br>(left-arrow key)</html>");
                            }}, stretchxy);
                            add(new JRepeatingButton("") {
                                @Override
                                public java.awt.Dimension getPreferredSize() { return new java.awt.Dimension(20,20); }
                                @Override
                                public java.awt.Dimension getMinimumSize()   { return new java.awt.Dimension(20,20); }
                                @Override
                                public void paint(java.awt.Graphics g)
                                {
                                    super.paint(g);
                                    drawPixmapCentered(g, getSize(), asciiToColor,
                                                       new String[] {
                                                          "bbb bbb",
                                                          "bbb bbb",
                                                          "bbb bbb",
                                                          "bbb bbb",
                                                          "bbb bbb",
                                                          "bbb bbb",
                                                          "bbb bbb",
                                                       });
                                }
                            {
                                addActionListener(new java.awt.event.ActionListener() {
                                    @Override
                                    public void actionPerformed(java.awt.event.ActionEvent e)
                                    {
                                        applet.pause();
                                    }
                                });
                                setToolTipText("<html>stop<br>(space key)</html>");
                            }}, stretchxy);
                            add(new JRepeatingButton("") {
                                @Override
                                public java.awt.Dimension getPreferredSize() { return new java.awt.Dimension(20,20); }
                                @Override
                                public java.awt.Dimension getMinimumSize()   { return new java.awt.Dimension(20,20); }
                                @Override
                                public void paint(java.awt.Graphics g)
                                {
                                    super.paint(g);
                                    drawPixmapCentered(g, getSize(), asciiToColor,
                                                       new String[] {
                                                          "bb b   ",
                                                          "bb bb  ",
                                                          "bb bbb ",
                                                          "bb bbbb",
                                                          "bb bbb ",
                                                          "bb bb  ",
                                                          "bb b   ",
                                                       });
                                }
                            {
                                addActionListener(new java.awt.event.ActionListener() {
                                    @Override
                                    public void actionPerformed(java.awt.event.ActionEvent e)
                                    {
                                        applet.stepForward();
                                    }
                                });
                                setToolTipText("<html>step forward<br>(right-arrow key)</html>");
                            }}, stretchxy);
                            add(new JRepeatingButton("") {
                                @Override
                                public java.awt.Dimension getPreferredSize() { return new java.awt.Dimension(20,20); }
                                @Override
                                public java.awt.Dimension getMinimumSize()   { return new java.awt.Dimension(20,20); }
                                @Override
                                public void paint(java.awt.Graphics g)
                                {
                                    super.paint(g);
                                    drawPixmapCentered(g, getSize(), asciiToColor,
                                                       new String[] {
                                                          "b  b   ",
                                                          "bb bb  ",
                                                          "bbbbbb ",
                                                          "bbbbbbb",
                                                          "bbbbbb ",
                                                          "bb bb  ",
                                                          "b  b   ",
                                                       });
                                }
                            {
                                addActionListener(new java.awt.event.ActionListener() {
                                    @Override
                                    public void actionPerformed(java.awt.event.ActionEvent e)
                                    {
                                        applet.accelForward();
                                    }
                                });
                                setToolTipText("<html>accelerate forward<br>(shift-right-arrow key)</html>");
                            }}, stretchxy);
                        }});
                    }});
                    add(new JLabel("    "));
                    add(new JCol() {{
                        add(new JTablePanel() {{
                            add(new JLabel("Anim sleep ms:"));
                            add(makeIncrementableTextFieldForInt(applet.animSleepMS, "number of milliseconds to sleep after each vsync pulse before calling repaint()", 1));
                            advanceRow();
                            add(new JLabel("Pixels per part:"));
                            add(makeIncrementableTextFieldForInt(applet.theSpiralView.pixelsPerPart, "pixels per part in ticker and stats plots", 1));
                            advanceRow();
                            add(new JLabel("Time quanta per part:"));
                            add(makeIncrementableTextFieldForInt(applet.theSpiralView.quantaPerPart, "time quanta per part", 1));
                        }});
                        add(new JRow() {{
                            add(new JCheckBoxForBoolean("show rungs", applet.theSpiralView.showRungsFlag) {{
                                setMargin(nomargin);
                            }});
                            add(new JCheckBoxForBoolean("pastels", applet.theSpiralView.pastelsFlag) {{
                                setMargin(nomargin);
                            }});
                        }});
                    }});
                    add(new JLabel("    "));
                    add(new JRepeatingButton("") {
                        @Override
                        public java.awt.Dimension getPreferredSize() { return new java.awt.Dimension(45,45); }
                        @Override
                        public java.awt.Dimension getMinimumSize()   { return getPreferredSize(); }
                        @Override
                        public void paint(java.awt.Graphics g)
                        {
                            if (debug) OUT("                    in orientation button paint");
                            super.paint(g);
                            // note the following is padded by 1 pixel on all sides,
                            // to allow for highlighting to change color there
                            String rows[] = new String[] {
                                "                                     ",
                                "                 b   b               ",
                                "                 gg gg               ",
                                "            b     b b    b           ",
                                "            b     gbg    b           ",
                                "        bg  b      b     b  gb       ",
                                "         gbgb            bgbg        ",
                                "           gb            bg          ",
                                "     b                          b    ",
                                "     gg                        gg    ",
                                "      b                        b     ",
                                "      gg                      gg     ",
                                "   bbbbb                      bbbbb  ",
                                "                                     ",
                                "                                     ",
                                "                                     ",
                                " bg                               gb ",
                                "  gbg                           gbg  ",
                                "    bb                         bb    ",
                                "  gbg                           gbg  ",
                                " bg                               gb ",
                                "                                     ",
                                "                                     ",
                                "                                     ",
                                "   bbbbb                      bbbbb  ",
                                "      gg                      gg     ",
                                "      b                        b     ",
                                "     gg                        gg    ",
                                "     b                          b    ",
                                "           gb            bg          ",
                                "         gbgb            bgbg        ",
                                "        bg  b      b     b  gb       ",
                                "            b     gbg    b           ",
                                "            b     b b    b           ",
                                "                 gg gg               ",
                                "                 b   b               ",
                                "                                     ",
                            };
                            // convert the whole thing to char array
                            char chars[][] = new char[rows.length][];
                            FORI (iRow, rows.length)
                                chars[iRow] = rows[iRow].toCharArray();
                            java.awt.Color fudgedAsciiToColor[] = (java.awt.Color[])Arrays.copy(asciiToColor,1);

                            {

                                // find which little icon is in the given direction
                                // and highlight it.
                                // holy moly!

                                java.awt.Dimension gsize = getSize();

                                int orientationNumbersToHighlight[] = new int[2];
                                int nToHighlight = 0;
                                if (applet.theSpiralView.orientationNumber.get() != -1)
                                    orientationNumbersToHighlight[nToHighlight++] = applet.theSpiralView.orientationNumber.get();
                                if (this.spiralOrientationNumber != -1
                                 && this.spiralOrientationNumber != applet.theSpiralView.orientationNumber.get())
                                    orientationNumbersToHighlight[nToHighlight++] = this.spiralOrientationNumber;
                                //PRINT(nToHighlight);
                                //PRINTARRAY(orientationNumbersToHighlight);
                                FORI (iToHighlight, nToHighlight)
                                {
                                    int orientationNumberToHighlight = orientationNumbersToHighlight[iToHighlight];
                                    double angle = orientationNumberToHighlight*(2*Math.PI/12);
                                    char highlightChar = "0123456789!?".charAt(orientationNumberToHighlight);
                                    fudgedAsciiToColor[highlightChar] = java.awt.Color.getHSBColor((float)(angle/(2*Math.PI)), 1.f, 1.f);
                                    int center = (rows.length+1)/2;


                                    double cos = Math.cos(angle);
                                    double sin = Math.sin(angle);
                                    assert(rows.length == rows[0].length());

                                    int seedRow = -1, seedCol = -1;
                                    boolean foundSeed = false;
                                    FORI (i, center)
                                    {
                                        seedCol = (int)Math.round(center + cos*(1+i));
                                        seedRow = (int)Math.round(center - sin*(1+i));
                                        if (rows[seedRow].charAt(seedCol) != ' ')
                                        {
                                            foundSeed = true;
                                            break;
                                        }
                                    }
                                    assert(foundSeed);

                                    // seed fill, setting outline to highlight char
                                    {
                                        boolean isSeen[][] = new boolean[rows.length][rows.length]; // false initially
                                        int seen[][] = new int[rows.length*rows.length][2];
                                        int nSeen = 0;
                                        seen[nSeen][0] = seedRow;
                                        seen[nSeen][1] = seedCol;
                                        nSeen++;
                                        FORI (iSeen, nSeen) // while nSeen is growing
                                        {
                                            int row0 = seen[iSeen][0];
                                            int col0 = seen[iSeen][1];
                                            if (chars[row0][col0] == ' ')
                                            {
                                                // don't proceed to neighbors, but change color
                                                chars[row0][col0] = highlightChar;
                                            }
                                            else
                                            {
                                                // don't proceed to neighbors, but change color
                                                for (int drow = -1; drow <= 1; drow++)
                                                for (int dcol = -1; dcol <= 1; dcol++)
                                                {
                                                    if (drow==0 && dcol==0) continue;
                                                    int row1 = row0+drow;
                                                    int col1 = col0+dcol;
                                                    if (!INRANGE(0 <=, row1, < rows.length)
                                                     || !INRANGE(0 <=, col1, < rows.length))
                                                        assert(false); // shouldn't happen
                                                    if (isSeen[row1][col1]) continue;
                                                    isSeen[row1][col1] = true;
                                                    seen[nSeen][0] = row1;
                                                    seen[nSeen][1] = col1;
                                                    nSeen++;
                                                }
                                            }
                                        }

                                        if (false) // can change to true for debugging
                                        {
                                            fudgedAsciiToColor['w'] = java.awt.Color.white;
                                            chars[seedRow][seedCol] = 'w';
                                        }
                                    }
                                }
                            }
                            // convert the whole thing back to Strings
                            FORI (iRow, rows.length)
                                rows[iRow] = new String(chars[iRow]);
                            drawPixmapCentered(g, getSize(), fudgedAsciiToColor, rows);
                            if (debug) OUT("                    out orientation button paint");
                        } // paint
                        private void updateSpiralOrientationNumber(int mouseX, int mouseY)
                        {
                            java.awt.Dimension gsize = getSize();
                            double angle = Math.atan2(-(mouseY-(gsize.height*.5)),
                                                        mouseX-(gsize.width*.5));
                            spiralOrientationNumber = (int)Math.round(angle*(12/(2*Math.PI)));
                            spiralOrientationNumber = MOD(spiralOrientationNumber,12);
                        }
                        // keep track of state...
                        boolean pressed = false;
                        boolean entered = false;
                        boolean debug = false;
                        int spiralOrientationNumber = -1; // gets set during paint

                    {
                        addMouseMotionListener(new java.awt.event.MouseAdapter() {
                            @Override
                            public void mouseMoved(java.awt.event.MouseEvent mouseEvent)
                            {
                                if (debug) OUT("        in mouseMoved");
                                updateSpiralOrientationNumber(mouseEvent.getX(), mouseEvent.getY());
                                repaint();
                                if (debug) OUT("        out mouseMoved");
                            }
                            @Override
                            public void mouseDragged(java.awt.event.MouseEvent mouseEvent)
                            {
                                if (debug) OUT("                in mouseDragged");
                                updateSpiralOrientationNumber(mouseEvent.getX(), mouseEvent.getY());
                                applet.theSpiralView.orientationNumber.set(spiralOrientationNumber);
                                repaint();
                                if (debug) OUT("                out mouseDragged");
                            }
                        });
                        // apparently we don't get a repaint when rollover ends,
                        // and we need one to remove the highlighting, so...
                        addMouseListener(new java.awt.event.MouseAdapter() {
                            @Override
                            public void mouseEntered(java.awt.event.MouseEvent mouseEvent)
                            {
                                if (debug) OUT("    in mouseEntered");
                                entered = true;
                                updateSpiralOrientationNumber(mouseEvent.getX(), mouseEvent.getY());
                                repaint();
                                if (debug) OUT("    out mouseEntered");
                            }
                            @Override
                            public void mouseExited(java.awt.event.MouseEvent mouseEvent)
                            {
                                if (debug) OUT("    in mouseExited");
                                entered = false;
                                if (pressed)
                                    updateSpiralOrientationNumber(mouseEvent.getX(), mouseEvent.getY());
                                else
                                    spiralOrientationNumber = -1;
                                spiralOrientationNumber = -1;
                                repaint();
                                if (debug) OUT("    out mouseExited");
                            }
                            @Override
                            public void mousePressed(java.awt.event.MouseEvent mouseEvent)
                            {
                                if (debug) OUT("            in mousePressed");
                                pressed = true;
                                updateSpiralOrientationNumber(mouseEvent.getX(), mouseEvent.getY());
                                applet.theSpiralView.orientationNumber.set(spiralOrientationNumber);
                                repaint();
                                if (debug) OUT("            out mousePressed");
                            }
                            @Override
                            public void mouseReleased(java.awt.event.MouseEvent mouseEvent)
                            {
                                if (debug) OUT("            in mouseReleased");
                                pressed = false;
                                if (entered)
                                    updateSpiralOrientationNumber(mouseEvent.getX(), mouseEvent.getY());
                                else
                                    spiralOrientationNumber = -1;
                                repaint();
                                if (debug) OUT("            out mouseReleased");
                            }
                        });
                        addActionListener(new java.awt.event.ActionListener() {
                            @Override
                            public void actionPerformed(java.awt.event.ActionEvent e)
                            {
                                // note, this is a repeating button
                                // so we'll get events as long as the button is down. cool!
                                // that means the user can drag around and change the orientation that way.
                                if (spiralOrientationNumber != -1)
                                    applet.theSpiralView.orientationNumber.set(spiralOrientationNumber);
                            }
                        });
                        setToolTipText("<html>spiral orientation</html>");
                        //setRolloverEnabled(false);
                    }});
                }}); // view contents row
                contentPane.add(new JSeparator(), stretchx);
                contentPane.add(new JLabel("Debug"));
                add(new JRow() {{
                    add(new JLabel("        ")); // indent a bit
                    add(new JCol() {{
                        add(new JCheckBoxForBoolean("show timing", applet.showTimingFlag) {{
                            setMargin(nomargin);
                        }});
                        add(new JCheckBoxForBoolean("show model ticker", applet.showTickerFlag) {{
                            setMargin(nomargin);
                        }});
                        add(new JCheckBoxForBoolean("show model spiral", applet.showSpiralFlag) {{
                            setMargin(nomargin);
                        }});
                        add(new JRow() {{
                            add(new JCheckBoxForBoolean("show model stats", applet.showStatsFlag) {{
                                setMargin(nomargin);
                            }});
                            add(makeIncrementableTextFieldForInt(applet.theSpiralView.focusAngleDegrees, "focus angle for stats plot", 5));
                        }});
                        add(new JCheckBoxForBoolean("print vsync lapses", applet.showVsyncLapsesFlag) {{
                            setMargin(nomargin);
                            setToolTipText("<html>if this is set, print whenever vsync lapse seems to be happening (assumes mostly 60hz framerate)</html>");
                        }});
                        add(new JRow() {{
                            add(new JButton("Dump window positions and sizes") {{
                                setMargin(nomargin);
                                addActionListener(new java.awt.event.ActionListener() {
                                    @Override
                                    public void actionPerformed(java.awt.event.ActionEvent e)
                                    {
                                        System.out.println("----------------");
                                        System.out.println("      main applet: "+applet.theMainAppletWindow.getWidth()+"x"+applet.theMainAppletWindow.getHeight()+"+"+applet.theMainAppletWindow.getX()+"+"+applet.theMainAppletWindow.getY()+"");
                                        System.out.println("    control panel: "+applet.theControlPanelWindow.getWidth()+"x"+applet.theControlPanelWindow.getHeight()+"+"+applet.theControlPanelWindow.getX()+"+"+applet.theControlPanelWindow.getY()+"");
                                        System.out.println("             help: "+applet.theHelpWindow.getWidth()+"x"+applet.theHelpWindow.getHeight()+"+"+applet.theHelpWindow.getX()+"+"+applet.theHelpWindow.getY()+"");
                                        System.out.println("----------------");
                                    }
                                });
                            }});
                        }});
                        add(new JRow() {{


                            add(new JLabel("Window title:"));
                            add(new JTextFieldForString(applet.windowTitle) {
                                @Override
                                public java.awt.Dimension getPreferredSize()
                                {
                                    java.awt.Dimension superSize = super.getPreferredSize();
                                    // TODO: who owns it? can I tweak it and return it?
                                    return new java.awt.Dimension(200, superSize.height);
                                }
                                // weird, getPreferredSize seems adequate when returning 100... but when returning 200, it turns to zero!? unless we also provide getMinimumSize
                                @Override
                                public java.awt.Dimension getMinimumSize()
                                {
                                    return getPreferredSize();
                                }
                            });
                        }});
                    }});
                }});
                contentPane.add(new JSeparator(), stretchx);

                //randomlyColorize(this);

            } // SpiralAppletControlPanel ctor
        } // class SpiralAppletControlPanel

    //
    // Implementing Applet methods...
    //
        public SpiralApplet()
        {
            java.awt.Container contentPane = getContentPane();

            contentPane.setLayout(new ColLayout());

            // used as "fill" argument to add()
            final java.awt.GridBagConstraints stretchxy = new java.awt.GridBagConstraints(){{fill=BOTH;weightx=weighty=1.;}};

            contentPane.add(theCanvas = new TheCanvas() {}, stretchxy);


            //
            // Make the menu bar
            //
            if (true)
            {
                // http://www.isr.umd.edu/~austin/ence688r.d/java-swing/menu.d/DemoMenuItem.java
                JMenuBar menuBar = new JMenuBar();

                menuBar.setBorderPainted(false); // true is default. false makes it blend into the background a tiny bit more, which is good.

                this.setJMenuBar(menuBar);

                JMenu fileMenu = new JMenu("File", true);
                menuBar.add(fileMenu);

                JMenu editMenu = new JMenu("Edit", true);
                menuBar.add(editMenu);

                JMenu windowsMenu = new JMenu("Windows", true);
                menuBar.add(windowsMenu);
                windowsMenu.add(new JMenuItem("Control Panel") {{
                    addActionListener(new java.awt.event.ActionListener() {
                        @Override
                        public void actionPerformed(java.awt.event.ActionEvent e)
                        {
                            theControlPanelWindow.setState(JFrame.NORMAL); // not iconified
                            theControlPanelWindow.setVisible(true); // also brings it to front, apparently
                        }
                    });
                }});

                JMenu helpMenu = new JMenu("Help", true);
                menuBar.add(helpMenu);
                helpMenu.add(new JMenuItem("Help") {{
                    addActionListener(new java.awt.event.ActionListener() {
                        @Override
                        public void actionPerformed(java.awt.event.ActionEvent e)
                        {
                            help();
                        }
                    });
                }});
                helpMenu.add(new JMenuItem("About...") {{
                    // TODO: do me
                }});
            }

            //randomlyColorize(this);

            //
            // Make the control panel window
            //
            if (true)
            {
                theControlPanelWindow = new JFrame(windowTitle + " Control Panel");
                // no need for setDefaultCloseOperation
                // since the default is HIDE_ON_CLOSE which is what we want


                final boolean useScrollPane = false; // can set this to true if it gets big enough to warrant it

                final int preferredWidth = 600; // XXX big enough so tooltip doesn't spill out, since that causes perf problems forevermore
                final int preferredHeight = 400;


                java.awt.Component controlPanel = new SpiralAppletControlPanel(this) {
                    @Override
                    public java.awt.Dimension getPreferredSize()
                    {
                        if (useScrollPane)
                            return new java.awt.Dimension(preferredWidth, preferredHeight);
                        else
                            return super.getPreferredSize();
                    }
                    @Override
                    public java.awt.Dimension getMinimumSize()
                    {
                        if (useScrollPane)
                            return new java.awt.Dimension(preferredWidth, preferredHeight);
                        else
                            return super.getMinimumSize();
                    }
                };
                if (useScrollPane)
                    controlPanel = new JScrollPane(controlPanel);
                theControlPanelWindow.getContentPane().add(controlPanel);

                theControlPanelWindow.setLocation(730, 10);
                theControlPanelWindow.setSize(preferredWidth+34, preferredHeight); // empirical-- will be wrong on another machine, no doubt XXX TODO: can we compute a good preferred size? pack() or something? just want to pack width, not height, I think?
                theControlPanelWindow.setVisible(true);
            }


            //
            // Make the help window
            //
            {
                theHelpWindow = new JFrame("SpiralApplet Help");
                // no need for setDefaultCloseOperation
                // since the default is HIDE_ON_CLOSE which is what we want

                // TODO: figure out how to make it scroll in response to arrow keys

                if (true)
                {
                    // Use a JTextArea made to look like a label so text will be selectable
                    String text = "";
                    FORI (i, helpMessage.length)
                        text += "  " + helpMessage[i] + "  \n";
                    theHelpWindow.getContentPane().add(
                        new JScrollPane(
                            new JTextArea(text) {{
                                // make it like a JLabel as much as possible, but text selectable
                                this.setEditable(false);
                                this.setDisabledTextColor(java.awt.Color.black);
                                this.setBackground(null); // same as JLabel
                                this.setBorder(null); // same as JLabel
                            }}
                        ) {{
                            // if we don't do the following, it will screw up
                            // and pick a width that forces a horizontal scrollbar... lame!
                            this.setVerticalScrollBarPolicy(JScrollPane.VERTICAL_SCROLLBAR_ALWAYS);
                        }}
                    );
                }
                else
                {
                    // Use a JLabel -- text not selectable :-(
                    String htmlHelpMessage = "<html><pre>";
                    FORI (i, helpMessage.length)
                        htmlHelpMessage += helpMessage[i] + "  \n";
                    htmlHelpMessage += "</pre></html>";

                    theHelpWindow.getContentPane().add(new JScrollPane(new JLabel(htmlHelpMessage)) {{

                        // if we don't do the following, it will screw up
                        // and pick a width that forces a horizontal scrollbar... lame!
                        this.setVerticalScrollBarPolicy(JScrollPane.VERTICAL_SCROLLBAR_ALWAYS);
                    }});
                }

                theHelpWindow.setLocation(210,30); // XXX do I really want this?  can I center it instead? doing it so the help window doesn't end up in same place as main window.
                theHelpWindow.pack(); // so that getWidth() will be the preferred width
                theHelpWindow.setSize(theHelpWindow.getWidth(),700); // XXX heuristic for my screen
                //theHelpWindow.setVisible(true); // uncomment when debugging
            }
        } // SpiralApplet ctor

        static final String helpMessage[] = {
            "===================================================================",
            "Mouse:",
            "Keys:",
            "===================================================================",
        }; // helpMessage

        private void help()
        {
            theHelpWindow.setState(java.awt.Frame.NORMAL); // not ICONTIFIED
            theHelpWindow.setVisible(true);
            theHelpWindow.toFront();

            if (true)
            {
                FORI (i, helpMessage.length)
                    System.out.println(helpMessage[i]);
            }
        } // help

        // classNameAncestors
        private static String classNameAncestors(Class classs)
        {
            String text = classs.getName();

            if (text.indexOf("java.lang.") == 0)
                text = text.substring(10);
            if (text.indexOf("java.awt.") == 0)
                text = text.substring(9);
            if (text.indexOf("javax.swing.J") == 0)
                text = text.substring(12);

            //if (text.indexOf('$') != -1)
            if (classs.getSuperclass() != null)
                text += " > " + classNameAncestors(classs.getSuperclass());
            return text;
        } // classNameAncestors
        private static void dumpComponentHierarchy(java.awt.Component component, int depth, int iChildInParent, int nChildrenInParent)
        {
            FORI (i, depth) System.out.print(" ");

            System.out.print(iChildInParent+"/"+nChildrenInParent+" ");
            System.out.println(classNameAncestors(component.getClass()));

            if (component instanceof java.awt.Container)
            {
                java.awt.Container C = (java.awt.Container)component;
                int n = C.getComponentCount();
                for (int iChild = 0; iChild < n; ++iChild)
                {
                    //FORI (iIndent, depth) System.out.print(" "); System.out.println(iChild+"/"+n);
                    dumpComponentHierarchy(C.getComponent(iChild), depth+1, iChild, n);
                }
                if (n > 0)
                {
                    //FORI (iIndent, depth) System.out.print(" "); System.out.println(n+"/"+n);
                }
            }
        } // dumpComponentHierarchy

        private static void randomlyColorize(java.awt.Component c)
        {
            c.setBackground(new java.awt.Color((float)Math.random(),
                                               (float)Math.random(),
                                               (float)Math.random()));
            c.setForeground(new java.awt.Color((float)Math.random(),
                                               (float)Math.random(),
                                               (float)Math.random()));
            if (c instanceof java.awt.Container)
            {
                java.awt.Container C = (java.awt.Container)c;
                int n = C.getComponentCount();
                for (int i = 0; i < n; ++i)
                    randomlyColorize(C.getComponent(i));
            }
        } // randomlyColorize

        @Override
        public void init()
        {
            eventVerbose = getParameterInt("EventVerbose", eventVerbose);
            if (eventVerbose >= 1) System.out.println("in init");

            graphicsAntiAliasingSetter = new GraphicsAntiAliasingSetter();

            theSpiralView.pixelsPerPart.addListener(pixelsPerPartListener = new Listenable.Listener() {
                @Override
                public void valueChanged()
                {
                    if (theSpiralView.pixelsPerPart.get() <= 0)
                    {
                        // reject!
                        System.out.println("rejecting change to pixelsPerPart!");
                        theSpiralView.pixelsPerPart.set(1);
                        return; // we just got called recursively; our work is done
                    }

                    theCanvas.repaint();
                }
            });
            theSpiralView.quantaPerPart.addListener(quantaPerPartListener = new Listenable.Listener() {
                @Override
                public void valueChanged()
                {
                    if (theSpiralView.quantaPerPart.get() <= 0)
                    {
                        // reject!
                        System.out.println("rejecting change to quantaPerPart!");
                        theSpiralView.quantaPerPart.set(1);
                        return; // we just got called recursively; our work is done
                    }

                    // XXX should this be in SpiralView? hmm
                    // XXX needs to be synchronized
                    theSpiralView.focusAnimationVelocity.divEquals(theSpiralView.focusQuantum);
                    theSpiralView.focusQuantum.set(1,theSpiralView.quantaPerPart.get()); // focusQuantum = 1/quantaPerPart
                    theSpiralView.focusAnimationVelocity.timesEquals(theSpiralView.focusQuantum);

                    // round focus to a multiple of focusQuantum.
                    // this makes sure focus hits integer boundaries,
                    // and prevents out-of-control rational denominators.
                    if (theSpiralView.focusQuantum.d % theSpiralView.focus.d != 0)
                    {
                        //System.out.println("rounding focus to multiple of focusQuantum!");
                        //PRINT(theSpiralView.focus);
                        //PRINT(theSpiralView.focusQuantum);
                        theSpiralView.focus.generalRoundEquals(theSpiralView.focusQuantum);
                        //PRINT(theSpiralView.focus);
                        //OUT("");
                    }


                    theCanvas.repaint(); // because focus may have changed
                }
            });


            // add this after all others, so that we don't repaint
            // until other processing stabilizes
            repaintWhenValueChanged = new Listenable.Listener() {
                @Override
                public void valueChanged()
                {
                    theCanvas.repaint();
                }
            };
            showTimingFlag.addListener(repaintWhenValueChanged);
            showTickerFlag.addListener(repaintWhenValueChanged);
            showSpiralFlag.addListener(repaintWhenValueChanged);
            showStatsFlag.addListener(repaintWhenValueChanged);
            theSpiralView.showRungsFlag.addListener(repaintWhenValueChanged);
            theSpiralView.pastelsFlag.addListener(repaintWhenValueChanged);
            theSpiralView.focusAngleDegrees.addListener(repaintWhenValueChanged);
            theSpiralView.orientationNumber.addListener(repaintWhenValueChanged);


            if (eventVerbose >= 1) System.out.println("out init");
        } // init

        @Override
        public void start()
        {
            if (eventVerbose >= 1) System.out.println("in start");
            if (eventVerbose >= 1) System.out.println("out start");
        }
        @Override
        public void stop()
        {
            if (eventVerbose >= 1) System.out.println("in stop");
            if (eventVerbose >= 1) System.out.println("out stop");
        }
        @Override
        public void destroy()
        {
            if (eventVerbose >= 1) System.out.println("in destroy");
            if (eventVerbose >= 1) System.out.println("out destroy");
        }

        //
        // Button behavor changed incompatibly between Java 1.1 and 1.4
        // (not sure exactly what version it changed in though).
        // (I think it was 1.4 since that's when getButton() was added
        // to MouseEvent).
        //
        private static int getButton(java.awt.event.MouseEvent e)
        {
            // gag me! we can't even query the java spec version number
            // since System.getProperty() throws a security exception
            // in netscape!
            // so use empirical evidence...
            int mods = e.getModifiers();
#if 0 // can't seem to get this to work under IE at all, so don't try for now, it will just be wrong under 1.4
            boolean is_1_4_or_greater = ((mods & ~0x1fff) != 0);
            if (is_1_4_or_greater)
            {
                try
                {
                    return e.getButton();
                }
                catch (NoSuchMethodError err)
                {
                    // this only happens in IE, not netscape. fall through...
                }
            }
#endif

            if ((mods & java.awt.event.InputEvent.ALT_MASK) != 0)
                return java_awt_event_MouseEvent_BUTTON2;
            if ((mods & java.awt.event.InputEvent.META_MASK) != 0)
                return java_awt_event_MouseEvent_BUTTON3;
            return java_awt_event_MouseEvent_BUTTON1;
        } // getButton

        private class TheCanvas
            extends JPanel
            implements java.awt.event.MouseListener,
                       java.awt.event.MouseMotionListener,
                       java.awt.event.KeyListener
        {
            TheCanvas()
            {
                // hmm, double buffering doesn't seem to make much difference, on my laptop??
                super(true); // double buffered
                //super(false); // not double buffered
                //PRINT(isDoubleBuffered());

                // Specify an "event listener" object
                // to respond to events.
                // (>= Java 1.1 event model).
                this.addMouseListener(this);
                this.addMouseMotionListener(this);
                this.addKeyListener(this);
            }

            //
            // MouseListener and MouseMotionListener methods...
            //
            @Override
            public void mousePressed(java.awt.event.MouseEvent e)
            {
                if (eventVerbose >= 1) System.out.println("in mousePressed: "+e);
                if (eventVerbose >= 1)
                {
                    if (getButton(e) == java_awt_event_MouseEvent_BUTTON1)
                        System.out.println("    (left mouse)");
                    if (getButton(e) == java_awt_event_MouseEvent_BUTTON2)
                        System.out.println("    (middle mouse)");
                    if (getButton(e) == java_awt_event_MouseEvent_BUTTON3)
                        System.out.println("    (right mouse)");
                }

                theCanvas.repaint();

                if (eventVerbose >= 1) System.out.println("out mousePressed: "+e);
            } // mousePressed
            @Override
            public void mouseReleased(java.awt.event.MouseEvent e)
            {
                if (eventVerbose >= 1) System.out.println("in mouseReleased: "+e);

                theCanvas.repaint();

                if (eventVerbose >= 1) System.out.println("out mouseReleased: "+e);
            } // mouseReleased
            @Override
            public void mouseEntered(java.awt.event.MouseEvent e)
            {
                if (eventVerbose >= 1) System.out.println("in mouseEntered: "+e);
                // steal keyboard focus!
                //System.out.println("Requesting focus!");
                requestFocus(); // hey it works! (javac 1.3, runtime 1.6)  XXX what does "it works" mean?
                if (eventVerbose >= 1) System.out.println("out mouseEntered: "+e);
            }
            @Override
            public void mouseExited(java.awt.event.MouseEvent e)
            {
                if (eventVerbose >= 1) System.out.println("in mouseExited: "+e);
                if (eventVerbose >= 1) System.out.println("out mouseExited: "+e);
            }
            @Override
            public void mouseClicked(java.awt.event.MouseEvent e)
            {
                if (eventVerbose >= 1) System.out.println("in mouseClicked: "+e);
                if (eventVerbose >= 1) System.out.println("out mouseClicked: "+e);
            }
            @Override
            public void mouseDragged(java.awt.event.MouseEvent e)
            {
                if (eventVerbose >= 2) System.out.println("  in mouseDragged: "+e);

                theCanvas.repaint();

                if (eventVerbose >= 2) System.out.println("  out mouseDragged: "+e);
            } // mouseDragged
            @Override
            public void mouseMoved(java.awt.event.MouseEvent e)
            {
                if (eventVerbose >= 3) System.out.println("    in mouseMoved: "+e);

                if (eventVerbose >= 3) System.out.println("    out mouseMoved: "+e);
            } // mouseMoved

            //
            // KeyListener methods...
            //
            @Override
            public void keyPressed(java.awt.event.KeyEvent e)
            {
                if (eventVerbose >= 1) System.out.println("in keyPressed: "+e);

                switch(e.getKeyCode())
                {
                    case java.awt.event.KeyEvent.VK_UP:
                    case java.awt.event.KeyEvent.VK_DOWN:
                        pause();
                        break;
                    case java.awt.event.KeyEvent.VK_LEFT:
                        if (e.isShiftDown())
                        {
                            accelBackward();
                        }
                        else
                        {
                            stepBackward();
                        }
                        break;

                    case java.awt.event.KeyEvent.VK_RIGHT:
                        if (e.isShiftDown())
                        {
                            accelForward();
                        }
                        else
                        {
                            stepForward();
                        }
                        break;
                    default:
                        // don't print anything, or we'll print too much (e.g. Shift, and any keys we handle in keyTyped())
                        //System.out.println("Unknown keycode "+java.awt.event.KeyEvent.getKeyText(e.getKeyCode())+" ("+e.getKeyCode()+")");
                        break;
                }
                if (eventVerbose >= 1) System.out.println("out keyPressed: "+e);
            } // keyPressed
            @Override
            public void keyReleased(java.awt.event.KeyEvent e)
            {
                if (eventVerbose >= 1) System.out.println("in keyReleased: "+e);
                switch(e.getKeyCode())
                {
                    default:
                        break;
                }
                if (eventVerbose >= 1) System.out.println("out keyReleased: "+e);
            } // keyReleased
            @Override
            public void keyTyped(java.awt.event.KeyEvent e)
            {
                if (eventVerbose >= 1) System.out.println("in keyTyped: "+e);
                char c = e.getKeyChar();

                // In java 1.6, apparently ctrl-letter
                // started coming out as just the letter
                // (with ke.isControlDown() true).
                // Detect this and change it to the old behavior...
                // XXX need to do something else, or nothing at all here, for old javas (1.1) in which isControlDown doesn't exist... or else just stop trying to support 1.1 at all
                if (c >= 'a' && c <= 'z' && e.isControlDown())
                {
                    c -= ('a'-1);
                }

    #define CTRL(lowerCaseLetter) ((lowerCaseLetter)-'a' + 1)
                switch (c)
                {
                    case ' ':
                    {
                        pause();
                        break;
                    }
                    case '\n':
                    {
                        theCanvas.repaint();
                        break;
                    }
                    case CTRL('q'): // quit
                    {
                        System.out.println("Aww.");
                        System.exit(1);
                    }
                    default:
                        System.out.println("Unknown key '"+c+"'("+(int)e.getKeyChar()+") typed");
                        break;
                }
                if (eventVerbose >= 1) System.out.println("out keyTyped: "+e);
            } // keyTyped






#if 0 // no longer works in 1.7, and emits deprecation warning, so fuck it
            //
            // Make it so we get keyboard focus on startup,
            // without having to click first.  Thanks, Melinda!
            // The state of things seems to be:
            //      - Buttons and TextFields are apparently "focus traversable"
            //        by default.  Canvases and Applets aren't,
            //        implying (not obvious) that you need to click to type
            //        when the app starts,
            //        which is almost never the desired behavior.
            //        You can change this by overriding isFocusTraversable(),
            //        which we do below.
            //      - Other approaches using requestFocus():
            //        A Canvas calling requestFocus() doesn't seem to do
            //        anything.  An Applet calling requestFocus() doesn't
            //        do anything during init(), but I think it works
            //        if you put it in the mouseEntered handler or something,
            //        though this can lead to various unpredictabilities.
            //
            @Override
            public boolean isFocusTraversable()
            {
                return true;
            }
#endif



            double lastStartTimePrinted = 0.;
            int lastNPaintsPrinted = 0;


            // PAINT/DISPLAY/DRAW
            @Override
            public void paintComponent(java.awt.Graphics g)
            {
                //try { Thread.sleep(50); } catch (InterruptedException e) {}
                java.awt.Dimension size = getSize();

                timingGraph.recordPaintStartTime(size.width+3);


                if (eventVerbose >= 1) System.out.println("in paint");


                if (showVsyncLapsesFlag.get())
                {
                    // Try to print out an idea of how frequent the lapses in vsync
                    // are happening
                    int sampleSize = 10;
                    if (timingGraph.startTimes.size() >= sampleSize+1
                     && nPaints >= lastNPaintsPrinted + 100
                     && (timingGraph.startTimes.get(timingGraph.startTimes.size()-1)-timingGraph.startTimes.get(timingGraph.startTimes.size()-1-sampleSize))/sampleSize < .01666*3/4.)
                    {
                        if (lastStartTimePrinted == 0.)
                            System.out.println("Hey! low frame time");
                        else
                            System.out.println("Hey! low frame time after "+(timingGraph.startTimes.get(timingGraph.startTimes.size()-1)-lastStartTimePrinted)+" secs");
                        lastNPaintsPrinted = nPaints;
                        lastStartTimePrinted = timingGraph.startTimes.get(timingGraph.startTimes.size()-1);
                    }
                }
                else
                {
                    lastStartTimePrinted = 0L;
                    lastNPaintsPrinted = 0;
                }

                // TODO: need to synchronize this I think
                theSpiralView.focus.plusEquals(theSpiralView.focusAnimationVelocity);
                theSpiralView.focus.modEquals(theSpiralModel.params.n.get(), 1);


                if (implementAntiAliasingInHardware)
                {
                    graphicsAntiAliasingSetter.setAntiAliasing(g,
                                                               antiAliasingFlag,
                                                               //1
                                                               eventVerbose
                                                               );
                }


                //
                // Clear to black...
                //
                g.setColor(java.awt.Color.black);
                g.fillRect(0,0, size.width,size.height);


                double pixelsPerMilli = 4.;
                if (showTimingFlag.get())
                {
                    timingGraph.preDraw(g,size,pixelsPerMilli);
                }

                int nItersPrimal=0, nItersDual=0;
                if (showTickerFlag.get())
                {
                    // I used to like to draw it centered in the window,
                    // but now I think I like to draw it with the lower edge
                    // centered.
                    double offset = (theSpiralModel.params.nParts.get()
                                  * theSpiralView.pixelsPerPart.get()
                                  * .25)
                                  * 1.5;
                    drawTicker(g,
                               size,
                               size.width/2.-offset,
                               size.height/2.-offset,
                               theSpiralModel,
                               theSpiralView,
                               theSpiralView.pastelsFlag.get());
                }
                if (showSpiralFlag.get())
                {
                    // for drawing the spirals
                    double spiralScale = .95;
                    double minSize = (double)MIN(size.width, size.height);
                    MyGraphics mg = new MyGraphics(g, size,
                        -size.width/minSize,size.width/minSize,
                        -size.height/minSize,size.height/minSize);
                    mg.scale(spiralScale,spiralScale);


                    if (true)
                    {
                        // draw dual spiral
                        nItersDual = drawSpiral(mg,
                                   theSpiralModel,
                                   theSpiralView,
                                   false, // drawPrimalFlag
                                   true, // drawDualFlag
                                   false, // drawRungsFlag
                                   theSpiralView.orientationNumber.get(),
                                   theSpiralView.pastelsFlag.get(),
                                   antiAliasingFlag);
                    }
                    if (true)
                    {
                        // draw primal spiral
                        nItersPrimal = drawSpiral(mg,
                                   theSpiralModel,
                                   theSpiralView,
                                   true, // drawPrimalFlag
                                   false, // drawDualFlag
                                   theSpiralView.showRungsFlag.get(), // drawRungsFlag
                                   theSpiralView.orientationNumber.get(),
                                   theSpiralView.pastelsFlag.get(),
                                   antiAliasingFlag);
                    }
                }
                if (showStatsFlag.get())
                {
                    double primalMinusDualFocusAngle = DTOR(theSpiralView.focusAngleDegrees.get());
                    drawStats(g,
                              size,
                              theSpiralModel,
                              theSpiralView,
                              primalMinusDualFocusAngle);
                }




                nPaints++;
                g.setColor(java.awt.Color.white);
                g.drawString(""+nPaints+" paints",
                              size.width - 75,
                              20);

                g.drawString("focus: "+theSpiralView.focus,
                             10,
                             20);



                if (showTimingFlag.get())
                {
                    g.drawString("dual iterations: "+nItersDual,
                                 10,
                                 60);
                    g.drawString("primal iterations: "+nItersPrimal,
                                 10,
                                 80);
                    timingGraph.draw(g,
                                     size,
                                     pixelsPerMilli);
                }



                if (!showStatsFlag.get()
                 && !showTimingFlag.get())
                {
                    // draw dot at exact center of window,
                    // for debugging.
                    g.setColor(java.awt.Color.red);
                    // 1 -> 0..1
                    // 2 -> 0..2
                    // 3 -> 1..2
                    // 4 -> 1..3
                    // 5 -> 2..3
                    // 6 -> 2..4
                    int x0 = (size.width-1)/2;
                    int x1 = (size.width+2)/2;
                    int y0 = (size.height-1)/2;
                    int y1 = (size.height+2)/2;
                    g.fillRect(x0,y0,
                               x1-x0,y1-y0);
                }



                // swing swaps buffers for us

                if (eventVerbose >= 1) System.out.println("out paint");

                timingGraph.recordPaintEndTime(size.width+3);
            } // paint

        } // class TheCanvas








        public TimingGraph timingGraph = new TimingGraph();

        // Calculate the angle C, opposite side c,
        // given side lengths a, b, c,
        // using c^2 = a^2 + b^2 - 2*a*b*cos(C)
        private static double triangleAngle(double a, double b, double c)
        {
            return Math.acos((a*a + b*b - c*c) / (2*a*b));
        }

        // Find vertex v2 that completes the triangle with given edge lengths,
        // such that v0,v1,v2 are CCW.
        private static double[] completeTriangle(double v0[],
                                                 double v1[],
                                                 double dist12,
                                                 double dist20)
        {
            // Make sure has only 2 entries
            v0 = new double[]{v0[0],v0[1]};
            v1 = new double[]{v1[0],v1[1]};
            double ang0 = triangleAngle(VecMath.dist(v0,v1), dist20, dist12);
            double dir01[] = VecMath.normalize(VecMath.vmv(v1,v0));
            double v2[] = VecMath.sxvpsxvpsxv(
                1.,                    v0,
                dist20*Math.cos(ang0), dir01,
                dist20*Math.sin(ang0), VecMath.xv2(dir01));
            return v2;
        } // completeTriangle

        private static double twiceTriangleArea(double x0, double y0,
                                                double x1, double y1,
                                                double x2, double y2)
        {
            return (x1-x0)*(y2-y0) - (x2-x0)*(y1-y0);
        }
        private static double twiceTriangleArea(double v0[],
                                           double v1[],
                                           double v2[])
        {
            return twiceTriangleArea(v0[0], v0[1],
                                     v1[0], v1[1],
                                     v2[0], v2[1]);
        }
        static void rotate(double x, double y, double theta, double answer[/*2*/])
        {
            double c = Math.cos(theta);
            double s = Math.sin(theta);
            answer[0] = x*c - y*s;
            answer[1] = x*s + y*c;
        }


        // "33.0" -> "33"
        // "0.25" -> ".25"
        // "0.30000000000000004" -> ".3"
        // "0.19999999999999996" -> "2"
        private static String doubleToStringNice(double x)
        {
            //System.out.println("    in doubleToStringNice("+x+")");
            if (x == 0)
            {
                //System.out.println("    out doubleToStringNice("+x+"), returning '0' trivially");
                return "0"; // avoid dealing with stuff like "-0.0"
            }
            if (x < 0)
            {
                String answer = "-" + doubleToStringNice(-x);
                //System.out.println("    out doubleToStringNice("+x+"), returning minus something");
                return answer;
            }

            String s = ""+x;

            assert(!s.startsWith("-"));

            int decimalPointIndex = s.indexOf('.');
            if (decimalPointIndex != -1)
            {
                // number of 9's should be one more than number of 0's
                int ninesIndex = s.indexOf("9999999", decimalPointIndex); // 7 9's
                if (ninesIndex != -1)
                {
                    double fudge = .0000002; // 7 digits
                    FORI (i, ninesIndex-(decimalPointIndex+1))
                        fudge *= .1;
                    x += fudge;
                    String answer = doubleToStringNice(x + fudge);
                    //System.out.println("    out doubleToStringNice("+x+"), returning"+answer);
                    return answer;
                }

                int zerosIndex = s.indexOf("000000", decimalPointIndex); // 6 0's
                if (zerosIndex != -1)
                {
                    if (zerosIndex-1 == decimalPointIndex)
                        s = s.substring(0, zerosIndex-1);
                    else
                        s = s.substring(0, zerosIndex);
                }

                // must do the following in order, so we don't remove the string entirely
                if (s.endsWith(".0"))
                    s = s.substring(0,s.length()-2); // remove the ".0" entirely
                if (s.startsWith("0."))
                    s = s.substring(1); // change the "0." to just "."
            }
            assert(s.length() >= 1);
            //System.out.println("    out doubleToStringNice("+x+"), returning "+s);
            return s;
        } // doubleToStringNice















        public static class SpiralModel
        {
            public static final int DELTASTYLE_MIN = 0;
            public static final int DELTASTYLE_1 = 0;
            public static final int DELTASTYLE_ANY = 1;
            public static final int DELTASTYLE_1_WRAP = 2;
            public static final int DELTASTYLE_MAX = 2;


            public static class Params
            {
                // XXX same thing in applet... should this be a little subclass?
                public Listenable.Int n = new Listenable.Int(2, 1000*1000*1000, 100*1000); // must be positive multiple of 2
                public Listenable.Int nParts = new Listenable.Int(1, 1000*1000*1000, 90); // must be >= 2
                public Listenable.Int deltaStyle = new Listenable.Int(SpiralModel.DELTASTYLE_MIN, SpiralModel.DELTASTYLE_MAX, SpiralModel.DELTASTYLE_ANY);
                public Listenable.Int randomSeed = new Listenable.Int(0, (1<<31)-1, 1);
            }

            public Params params = new Params();



            public int theList[/*n*/];
            public double centers[/*n*/][/*2*/]; // centers[i] is center of theList up through index i, rotated and scaled canonically
            public double weights[/*n*/]; // weights[i] is area of dual diagram of theList up through index i, rotated and scaled canonically

            SpiralModel()
            {
                init(params.n.get(),
                     params.nParts.get(),
                     params.deltaStyle.get(),
                     params.randomSeed.get());
            }

            public void init(int n,
                             int nParts,
                             int deltaStyle, // DELTASTYLE_1 or DELTASTYLE_ANY or DELTASTYLE_1_WRAP
                             int randomSeed)
            {
                this.params.n.set(n);
                this.params.nParts.set(nParts);
                this.params.deltaStyle.set(deltaStyle);
                this.params.randomSeed.set(randomSeed);

                java.util.Random rng = new java.util.Random(randomSeed);
                assert(n >= 2);
                assert(n % 2 == 0); // doesn't work with odd n
                assert(nParts >= 2); // doesn't work with only one part

                this.theList = new int[n];
                if (deltaStyle == DELTASTYLE_1)
                {
                    int maxPasses = 100;
                    int val = nParts/4*2; // somewhat arbitrary even starting point... will turn random (but still even, since n is even) on second pass.

                    boolean done = false;
                    FORI (iPass, maxPasses)
                    {
                        FORI (i, n)
                        {
                            if (iPass >= 1 && val == this.theList[i])
                            {
                                done = true;
                                break;
                            }
                            assert(val >= 0 && val < nParts);
                            this.theList[i] = val;

                            if (val == 0)
                                val = 1;
                            else if (val == nParts-1)
                                val = nParts-2;
                            else if (rng.nextBoolean())
                                val += 1;
                            else
                                val -= 1;
                        }
                        if (done)
                            break;
                    }
                    assert(done);
                }
                else if (deltaStyle == DELTASTYLE_ANY
                      || deltaStyle == DELTASTYLE_1_WRAP)
                {
                    int maxPasses = 100;


                    int val = nParts/4*2; // somewhat arbitrary even starting point... will turn random (but still even, since n is even) on second pass.
                    if (deltaStyle == DELTASTYLE_1_WRAP)
                    {
                        val = 0; // so it will likely cross over near beginning, so what it's doing will be more obvious at beginning
                    }
                    PRINT(nParts);
                    assert(val >= 0 && val < nParts && val%2 == 0);

                    boolean done = false;
                    int sign = -1; // initial val is biased a bit downwards, so there is guaranteed to be room upwards. so set sign initially to -1, so it will immediately switch to 1 and there will be room.
                    int nRemainingThisSign = 0;
                    FORI (iPass, maxPasses)
                    {
                        FORI (i, n)
                        {
                            if (iPass >= 1 && val == this.theList[i])
                            {
                                done = true;
                                break;
                            }
                            assert(val >= 0 && val < nParts);
                            this.theList[i] = val;

                            if (nRemainingThisSign == 0)
                            {
                                if (deltaStyle == DELTASTYLE_ANY)
                                {
                                    sign = -sign;
                                    if (sign == -1)
                                    {
                                        assert(val > 0);
                                        nRemainingThisSign = 1+rng.nextInt(val);
                                    }
                                    else
                                    {
                                        assert(nParts-1-val > 0);
                                        nRemainingThisSign = 1+rng.nextInt(nParts-1-val);
                                    }
                                }
                                else // DELTASTYLE_1_WRAP
                                {
                                    sign = rng.nextBoolean() ? 1 : -1;
                                    nRemainingThisSign = 1;
                                    if (sign==-1)
                                    {
                                        if (val == 0)
                                        {
                                            sign = 1;
                                            nRemainingThisSign = nParts-1;
                                        }
                                    }
                                    else
                                    {
                                        if (val == nParts-1)
                                        {
                                            sign = -1;
                                            nRemainingThisSign = nParts-1;
                                        }
                                    }
                                }
                            }

                            val += sign;
                            --nRemainingThisSign;
                        }
                        if (done)
                            break;
                    }
                    assert(done);
                }
                else
                    assert(false);

                // sanity check-- parity of value should be same as parity of index
                FORI (i, n)
                {
                    assert((theList[i] + i)%2 == 0);
                }

                this.centers = new double[n][2];
                this.weights = new double[n];
                if (true)
                {
                    // compute all cumulative centers and weights

                    double prevWeight = 0.;
                    double prevCenter[] = {0.,0.};
                    double thisWeight = 0.;
                    double thisCenter[] = {0.,0.};

                    boolean done = false;

                    double prevVal = theList[n-1];

                    int maxPasses = 2 + 10000/n; // really should be, roughly, one complete pass plus some fixed number of iterations
                    double scratch[] = new double[3];
                    PRINT(maxPasses);
                    FORI (iPass, maxPasses)
                    {
                        FORI (i, n)
                        {
                            // Compute new weight and center
                            // from prev weight and center

                            // val is (proportional to) primalAng-dualAng.
                            // when val increases, it means primalAng is increasing
                            // (i.e. Priscilla is moving, Dudley is turning)
                            // when val decreases, it means dualAng is increasing
                            // (i.e. Dudley is moving, Priscilla is turning)
                            // but, we always keep it canonicalized so that dualAng is 0.
                            double val = theList[i];
                            double prevPrimalAng = Math.PI/2 * ((prevVal+.5)/nParts);
                            double primalAng = Math.PI/2 * ((val+.5)/nParts);
                            if (primalAng > prevPrimalAng)
                            {
                                updateCenterAndWeightWhenPriscillaMoved(
                                        prevCenter[0], prevCenter[1], prevWeight,
                                        prevPrimalAng,
                                        primalAng,
                                        scratch);
                                thisCenter[0] = scratch[0];
                                thisCenter[1] = scratch[1];
                                thisWeight = scratch[2];
                            }
                            else
                            {
                                updateCenterAndWeightWhenDudleyMoved(
                                        prevCenter[0], prevCenter[1], prevWeight,
                                        prevPrimalAng,
                                        primalAng,
                                        scratch);
                                thisCenter[0] = scratch[0];
                                thisCenter[1] = scratch[1];
                                thisWeight = scratch[2];

                            }

                            if (done)
                            {
                                assert(VecMath.equalsExactly(this.centers[i], thisCenter));
                                assert(this.weights[i] == thisWeight);
                            }
                            else if (iPass > 0
                                  && VecMath.equalsExactly(this.centers[i], thisCenter)
                                  && this.weights[i] == thisWeight)
                            {
                                System.out.println("centers and weights stabilized at iPass="+iPass+" i="+i+"/n="+n);
                                done = true;
                            }
                            else
                            {
                                VecMath.copyvec(this.centers[i], thisCenter);
                                this.weights[i] = thisWeight;
                            }

                            prevCenter[0] = thisCenter[0];
                            prevCenter[1] = thisCenter[1];
                            prevWeight = thisWeight;
                            prevVal = val;
                        }
                    }
                    assert(done);
                }

                // sanity check-- all centers should have strictly positive y coord.
                FORI (i, n)
                {
                    // theorem says center has positive y coord
                    if (!(centers[i][1] > 0.))
                    {
                        System.out.println("Oh no! centers["+i+"] = "+centers[i][1]+" <= 0!");
                    }
                    double primalAng = (theList[i]+.5)/nParts*(Math.PI*.5);

                    // theorem says |areaBasedMoment| <= sin(2*primalAng)/4
                    if (!(VecMath.norm(centers[i])*(weights[i]*.5) < Math.sin(2*primalAng)/4))
                    {
                        System.out.println("Oh no! centers["+i+"] = "+centers[i][1]+" has length "+VecMath.norm(centers[i])*(weights[i]*.5)+" >= "+Math.sin(2*primalAng)/4+"!");
                    }
                }
            } // init
        }; // public class SpiralModel
        public static class SpiralView
        {
            public Listenable.Int resetFocusTo = new Listenable.Int(0,0, 636);
            public Rational focus = new Rational(resetFocusTo.get(),1); // always modulo spiralModel.params.n
            public Listenable.Int pixelsPerPart = new Listenable.Int(2, 1024, 2); // must be >= 1
            public Listenable.Int quantaPerPart = new Listenable.Int(2, 1024, 1); // must be >= 1
            public Listenable.Boolean showRungsFlag = new Listenable.Boolean(false);
            public Listenable.Boolean pastelsFlag = new Listenable.Boolean(false);
            public Rational focusQuantum = new Rational(1,quantaPerPart.get());
            public Rational focusAnimationVelocity = new Rational(0,1);
            public Listenable.Double focusAngleDegrees = new Listenable.Double(0.,90.,45.);
            public Listenable.Int orientationNumber = new Listenable.Int(0,12, 1);
            public SpiralView()
            {}
        }; // public class SpiralView



        public static void updateCenterAndWeightWhenPriscillaMoved(
                double oldCenterX,
                double oldCenterY,
                double oldWeight,
                double oldPrimalMinusDualAng,
                double newPrimalMinusDualAng,
                double newCenterAndWeight[])
        {
            assumpt(newPrimalMinusDualAng >= oldPrimalMinusDualAng);
            // primalAng is increasing. (assuming newPrimalMinusDual > oldPrimalMinusDual).
            // this shrinks the canonical representation of the primal,
            // thereby shrinking the center accordingly.
            // nothing happens to the weight,
            // nor to the direction from origin to center.
            double shrink = Math.cos(newPrimalMinusDualAng)
                          / Math.cos(oldPrimalMinusDualAng);
            assert(shrink <= 1.);
            double newCenterX = shrink * oldCenterX;
            double newCenterY = shrink * oldCenterY;
            double newWeight = oldWeight;
            newCenterAndWeight[0] = newCenterX;
            newCenterAndWeight[1] = newCenterY;
            newCenterAndWeight[2] = newWeight;
        } // updateCenterAndWeightWhenPriscillaMoved

        public static void updateCenterAndWeightWhenDudleyMoved(
                double oldCenterX,
                double oldCenterY,
                double oldWeight,
                double oldPrimalMinusDualAng,
                double newPrimalMinusDualAng,
                double newCenterAndWeight[])
        {
            double oldMomentX = oldWeight * oldCenterX;
            double oldMomentY = oldWeight * oldCenterY;

            assumpt(newPrimalMinusDualAng <= oldPrimalMinusDualAng);
            // dualAng is increasing... (assuming newPrimalMinusDual < oldPrimalMinusDual).
            // decrease primalAng to compensate,
            // so dualAng ends up zero.
            // the formula for shrink is magic, worked out on paper
            double shrink = Math.sin(newPrimalMinusDualAng)
                          / Math.sin(oldPrimalMinusDualAng);
            assert(shrink <= 1.);

            // angle to rotate previous picture by (rotate CW, so it's negative)
            double t = newPrimalMinusDualAng-oldPrimalMinusDualAng;
            assert(t <= 0.);
            double ct = Math.cos(t);
            double st = Math.sin(t);

            // old moment in new space is old moment shrunk by shrink^2 and rotated
            double oldMomentInNewSpaceX = SQR(shrink) * (oldMomentX * ct - oldMomentY * st);
            double oldMomentInNewSpaceY = SQR(shrink) * (oldMomentX * st + oldMomentY * ct);

            // worked this out on paper
            double weightIncrInNewSpace = shrink*Math.sin(oldPrimalMinusDualAng-newPrimalMinusDualAng);
            assert(weightIncrInNewSpace >= 0.);

            double newMomentX = oldMomentInNewSpaceX + weightIncrInNewSpace * Math.cos(newPrimalMinusDualAng);
            double newMomentY = oldMomentInNewSpaceY + weightIncrInNewSpace * Math.sin(newPrimalMinusDualAng);
            double newWeight = SQR(shrink)*oldWeight + weightIncrInNewSpace;
            if (newWeight == 0.)
            {
                // it's a bit unfortunate to lose the center but oh well
                newCenterAndWeight[0] = 0.;
                newCenterAndWeight[1] = 0.;
                newCenterAndWeight[2] = 0.;
            }
            else
            {
                newCenterAndWeight[0] = newMomentX / newWeight;
                newCenterAndWeight[1] = newMomentY / newWeight;
                newCenterAndWeight[2] = newWeight;
                //PRINTVEC(newCenterAndWeight);
            }
        } // updateCenterAndWeightWhenDudleyMoved

        // DEBUGGING-- sanity check that two dudleys is the same as the cumulative dudley.
        // yes, this does appear to be working correctly
        // (when I substitute this for the normal one, the prints
        // indicate that the two answers are the same)
        public static void updateCenterAndWeightWhenDudleyMoved2(
                double oldCenterX,
                double oldCenterY,
                double oldWeight,
                double oldPrimalMinusDualAng,
                double newPrimalMinusDualAng,
                double newCenterAndWeight[])
        {
            System.out.println("in dudley moved 2");
            double midPrimalMinusDualAng = LERP(oldPrimalMinusDualAng, newPrimalMinusDualAng, .654321);
            double midCenterAndWeight[] = newCenterAndWeight; // use it as scratch
            updateCenterAndWeightWhenDudleyMoved(
                oldCenterX,
                oldCenterY,
                oldWeight,
                oldPrimalMinusDualAng,
                midPrimalMinusDualAng,
                midCenterAndWeight);
            PRINTVEC(midCenterAndWeight);
            updateCenterAndWeightWhenDudleyMoved(
                midCenterAndWeight[0],
                midCenterAndWeight[1],
                midCenterAndWeight[2],
                midPrimalMinusDualAng,
                newPrimalMinusDualAng,
                newCenterAndWeight);
            PRINTVEC(newCenterAndWeight);
            updateCenterAndWeightWhenDudleyMoved(
                oldCenterX,
                oldCenterY,
                oldWeight,
                oldPrimalMinusDualAng,
                newPrimalMinusDualAng,
                newCenterAndWeight);
            PRINTVEC(newCenterAndWeight);
            System.out.println("in dudley moved 2");
        }

        // Actually we know which one moved (assuming spiraling outward).
        public static void updateCenterAndWeightWhenSomeoneMoved(
                double oldCenterX,
                double oldCenterY,
                double oldWeight,
                double oldPrimalMinusDualAng,
                double newPrimalMinusDualAng,
                double newCenterAndWeight[])
        {
            if (newPrimalMinusDualAng >= oldPrimalMinusDualAng)
                updateCenterAndWeightWhenPriscillaMoved(
                    oldCenterX,
                    oldCenterY,
                    oldWeight,
                    oldPrimalMinusDualAng,
                    newPrimalMinusDualAng,
                    newCenterAndWeight);
            else
                updateCenterAndWeightWhenDudleyMoved(
                    oldCenterX,
                    oldCenterY,
                    oldWeight,
                    oldPrimalMinusDualAng,
                    newPrimalMinusDualAng,
                    newCenterAndWeight);
        } // updateCenterAndWeightWhenSomeoneMoved



        //
        // I think this should be the workhorse that everyone uses--
        // It can subsume most of the above, I think.
        //
        // Given initial and final primal and dual points (in polar coords r,theta),
        // compute the moment and twiceArea of the logarithmic spiral.
        // Parametrizing by t from 0 to 1:
        //     primal_r(t) = primal_r0 * pow(primal_r1/primal_r0, t)
        //     primal_theta(t) = primal_theta0 + (primal_theta1-primal_theta0) * t
        // and analogously for dual_r and dual_theta.
        //
        // TwiceArea is:
        //     (dual_theta1-dual_theta0) * Integral[t=0..1] dual_r^2 dt
        // Moment is:
        //     (dual_theta1-dual_theta0) * Integral[t=0..1] <primal_x,primal_y> * dual_r^2 dt
        // where:
        //     primal_x(t) = primal_r(t) * cos primal_theta(t)
        //     primal_y(t) = primal_r(t) * sin primal_theta(t)
        //
        // In other words,
        //      Moment x = (dual_theta1-dual_theta0) * Integral[t=0..1] (primal_r * cos(primal_theta) * dual_r^2) dt
        //      Moment y = (dual_theta1-dual_theta0) * Integral[t=0..1] (primal_r * sin(primal_theta) * dual_r^2) dt
        //     TwiceArea = (dual_theta1-dual_theta0) * Integral[t=0..1] dual_r^2 dt
        //
        // Expanding the integral for TwiceArea:
        //     TwiceArea = (dual_theta1-dual_theta0) * Integral[t=0..1] dual_r^2 dt
        //               = (dual_theta1-dual_theta0) * Integral[t=0..1] (dual_r0*pow(dual_r1/dual_r0, t))^2 dt
        //               = (dual_theta1-dual_theta0) * dual_r0^2 * Integral[t=0..1] pow(dual_r1^2/dual_r0^2, t) dt
        // (using fact that Integral a^t dt = a^t / log(a))
        //               = (dual_theta1-dual_theta0) * dual_r0^2 * [pow(dual_r1^2/dual_r0^2,t)|0..1] / log(dual_r1^2/dual_r0^2)
        //               = (dual_theta1-dual_theta0) * dual_r0^2 * (dual_r1^2/dual_r0^2 - 1) / log(dual_r1^2/dual_r0^2)
        // Note that if dual_r1/dual_r1 is 1, that becomes 0/0,
        // but we can use the robust log1p_over_x function in MyMath for this
        // (see my "right way to calculate stuff" page).
        //
        // Expanding the integral for moment y:
        //      Moment y = (dual_theta1-dual_theta0) * Integral[t=0..1] (primal_r * sin(primal_theta) * dual_r^2) dt
        //               = (dual_theta1-dual_theta0) * primal_r0 * dual_r0^2 Integral[t=0..1] (primal_r1/primal_r0 * sin(primal_theta) * dual_r^2) dt
        //      XXX YOU ARE HERE
        // WOOPS! this isn't right at all! the right answer should include straight lines, this will do spirals instead, that's not right!
        //        
        public static void spiralMomentAndTwiceArea(
            double primal_r0, double primal_theta0,
            double dual_r0,   double dual_theta0,
            double primal_r1, double primal_theta1,
            double dual_r1,   double dual_theta1,
            double answerMomentAndTwiceArea[/*3*/])
        {
            // deltas... (geometric for r's, arithmetic for theta's)
            double primal_dr = primal_r1/primal_r0;
            double primal_dtheta = primal_theta1-primal_theta0;
            double dual_dr = dual_r1/dual_r0;
            double dual_dtheta = dual_theta1-dual_theta0; // dual_theta's are otherwise unused
            assumpt(false); // XXX implement me!
            //double twiceArea = dual_dtheta * SQR(dual_r0) / MyMath.log1p_over_x(SQR(dual_dr)-1);   XXX implement in MyMath!
        } // spiralMomentAndTwiceArea


                        



        // for the drawStats function
        public static interface DataFetcher
        {
            public int nData();
            public void getDatum(int i, double putDatumHere[/*2*/]);
        } // abstract class DataFetcher

        // more general drawStats, takes an arbitrary iteration and bounds
        public static void drawOnePlot(java.awt.Graphics g,
                                       java.awt.Dimension gsize,

                                     // called like this:
                                     //     2,100,1, gx0,gx1, 1,100,2,  "left label", "right label",
                                     //     2,100,1, gy0,gy1, 1,100,2,  "bottom label", "top label",

                                     int gX0OuterFrameWidth, int gX0LabelWidth, int gX0InnerFrameWidth, // in pixels
                                     int gX0, int gX1, // in pixels-- may be in either order
                                     int gX1InnerFrameWidth, int gX1LabelWidth, int gX1OuterFrameWidth, // in pixels
                                     String gX0Label, String gX1Label,

                                     int gY0OuterFrameWidth, int gY0LabelWidth, int gY0InnerFrameWidth, // in pixels
                                     int gY0, int gY1, // in pixels-- may be in either order
                                     int gY1InnerFrameWidth, int gY1LabelWidth, int gY1OuterFrameWidth, // in pixels
                                     String gY0Label, String gY1Label,

                                     double x0, double x1, // values to put at gX0,gX1
                                     double y0, double y1, // values to put at gY0,gY1
                                     int nMajorX, int nMajorY, // for major grid lines

                                     java.awt.Color outerFrameColor,
                                     java.awt.Color innerFrameColor,
                                     java.awt.Color majorGridColor,
                                     java.awt.Color labelColor,
                                     java.awt.Color boundsColor,
                                     java.awt.Color dataColor,

                                     DataFetcher possibleBoundsFetcher,
                                     DataFetcher dataFetcher)

        {
            assumpt(gX0 < gX1);
            assumpt(gY0 != gY1);
            if (gY0 > gY1)
            {
                int temp;
                SWAP(gY0OuterFrameWidth, gY1OuterFrameWidth, temp);
                SWAP(gY0LabelWidth, gY1LabelWidth, temp);
                SWAP(gY0InnerFrameWidth, gY1InnerFrameWidth, temp);
                SWAP(gY0, gY1, temp);
                double tempDouble;
                SWAP(y0, y1, tempDouble);
                String tempString;
                SWAP(gY0Label, gY1Label, tempString);
            }
            assert(gY0 < gY1);


            // make a MyGraphics, without changing coords,
            // for nice string positioning,
            // and also for positioning points in double precision
            MyGraphics mg = new MyGraphics(g, gsize, 0, gsize.width,
                                                     gsize.height, 0); // wtf? that was unexpected, actually



            //  +-----------------+ - gY0000
            //  |   outer frame   |
            //  |+---------------+| - gY000
            //  ||               ||
            //  || +-----------+ || - gY00
            //  || |inner frame| ||
            //  || |+---------+| || - gY0
            //  || ||         || ||
            //  || |+---------+| || - gY1
            //  || +-----------+ || - gY11
            //  ||               ||
            //  |+---------------+| - gY111
            //  +-----------------+ - gY1111

            int gX00 = gX0-gX0InnerFrameWidth;
            int gX000 = gX00-gX0LabelWidth;
            int gX0000 = gX000-gX0OuterFrameWidth;
            int gX11 = gX1+gX1InnerFrameWidth;
            int gX111 = gX11+gX1LabelWidth;
            int gX1111 = gX111+gX1OuterFrameWidth;

            int gY00 = gY0-gY0InnerFrameWidth;
            int gY000 = gY00-gY0LabelWidth;
            int gY0000 = gY000-gY0OuterFrameWidth;
            int gY11 = gY1+gY1InnerFrameWidth;
            int gY111 = gY11+gY1LabelWidth;
            int gY1111 = gY111+gY1OuterFrameWidth;

            if (true)
            {
                // draw outer frame
                g.setColor(outerFrameColor);
                g.fillRect(gX0000,gY0000, gX1111-gX0000,gY000-gY0000); // top
                g.fillRect(gX0000,gY111, gX1111-gX0000,gY1111-gY111); // bottom
                g.fillRect(gX0000,gY000, gX000-gX0000,gY111-gY000); // left
                g.fillRect(gX111,gY000, gX1111-gX111,gY111-gY000); // right

                // draw inner frame
                g.setColor(innerFrameColor);
                g.fillRect(gX00,gY00, gX11-gX00,gY0-gY00); // top
                g.fillRect(gX00,gY1, gX11-gX00,gY11-gY1); // bottom
                g.fillRect(gX00,gY0, gX0-gX00,gY1-gY0); // left
                g.fillRect(gX1,gY0, gX11-gX1,gY1-gY0); // right
            }

                
            // draw major grid lines (after frames, to make sure bounds are right)
            g.setColor(majorGridColor);
            FORI (iMajorX, nMajorX+1)
            {
                int gX = (int)LERP(gX0,gX1-1,(double)iMajorX/(double)nMajorX);
                g.fillRect(gX,gY0,
                           1,gY1-gY0);
                double x = LERP(x0,x1,(double)iMajorX/(double)nMajorX);
                String labelText = doubleToStringNice(x);
                mg.drawString(labelText,
                             gX, gY11+5,
                             -0., -1.,
                             null);
            }
            FORI (iMajorY, nMajorY+1)
            {
                int gY = (int)LERP(gY0,gY1-1,(double)iMajorY/(double)nMajorY);
                g.fillRect(gX0,gY,
                           gX1-gX0,1);
                double y = LERP(y0,y1,(double)iMajorY/(double)nMajorY);
                String labelText = doubleToStringNice(y);
                mg.drawString(labelText,
                             gX00-5, gY,
                             1., 0.,
                             null);
            }

            // draw labels
            g.setColor(labelColor);

            if (gX0Label != null)
                mg.drawString(gX0Label,
                              gX00-5-12-5, // XXX 12 is hard coded estimate of left tic label width
                              (gY0+gY1)/2,
                              1., 0.,
                              null);
            if (gX1Label != null)
                mg.drawString(gX1Label,
                              gX11+5+0+5, // XXX 0 is hard coded estimate of right tic label width
                              (gY0+gY1)/2,
                              -1., 0.,
                              null);
            if (gY0Label != null)
            {
                assumpt(false); // XXX implement me!
            }
            if (gY1Label != null)
                mg.drawString(gY1Label,
                              (gX0+gX1)/2,
                              gY11+5+8+10, // XXX 8 is hard coded estimate of bottom tic label height
                              0.,-1.,
                              null);

            // draw bounds
            g.setColor(boundsColor);
            {
                int n = possibleBoundsFetcher.nData();
                double datum[] = new double[2];
                FORI (i, n)
                {
                    possibleBoundsFetcher.getDatum(i, datum);
                    double x = datum[0];
                    double y = datum[1];
                    double gX = LERP(gX0+.5,gX1-.5, (x-x0)/(x1-x0));
                    double gY = LERP(gY0+.5,gY1-.5, (y-y0)/(y1-y0));
                    mg.drawPoint(gX,gY,3,3);
                    //mg.drawPoint(gX,gY,2,2);
                    //mg.drawPoint(gX,gY,1,2);
                    //mg.drawPoint(gX,gY,1,1);
                }
            }
            // draw data
            g.setColor(dataColor);
            {
                int n = dataFetcher.nData();
                double datum[] = new double[2];
                FORI (i, n)
                {
                    dataFetcher.getDatum(i, datum);
                    double x = datum[0];
                    double y = datum[1];
                    double gX = LERP(gX0+.5,gX1-.5, (x-x0)/(x1-x0));
                    double gY = LERP(gY0+.5,gY1-.5, (y-y0)/(y1-y0));
                    mg.drawPoint(gX,gY,1);
                }
            }

        } // drawOnePlot

        public static void drawStats(java.awt.Graphics g,
                                     java.awt.Dimension gsize,
                                     final SpiralModel spiralModel,
                                     SpiralView spiralView,
                                     final double focusPrimalAngleMinusDualAngle)
        {
            java.awt.Color gray64 = new java.awt.Color(64,64,64);

            // momentAng-dualAng vs. primalAng-dualAng graph
            {
                int nParts = spiralModel.params.nParts.get();
                int pixelsPerPart = spiralView.pixelsPerPart.get();
                int pixelsInPlot = nParts * pixelsPerPart + 1;


                // these bounds include inner frame
                int x0 = (gsize.width-pixelsInPlot)/2;
                int x1 = x0 + pixelsInPlot;
                int y1 = gsize.height/2 - 60;
                int y0 = y1 - pixelsInPlot;

                drawOnePlot(
                    g,
                    gsize,
                    1,145,2, x0,x1, 2,3,1, "momentAng-dualAng", null, // left to right
                    1,50,2,  y1,y0, 2,3,1, "primalAng-dualAng", null, // bottom to top

                    0., 90., // values to put at x bounds
                    0., 90., // values to put at y bounds

                    9,9, // nMajor x,y

                    java.awt.Color.blue, // outerFrameColor
                    java.awt.Color.white, // innerFrameColor
                    gray64, // majorGridColor
                    gray64, // labelColor
                    java.awt.Color.green, // boundsColor
                    java.awt.Color.red, // dataColor
                    new DataFetcher() { // possibleBoundsFetcher
                        // XXX this is actually pretty screwy--- we end up drawing a bounds point for every data point, even if there are a zillion data points and not that many pixels
                        public int nData()
                        {
                            return spiralModel.params.n.get();
                        }
                        public void getDatum(int i, double putDatumHere[/*2*/])
                        {
                            int val = spiralModel.theList[i];
                            double center[] = spiralModel.centers[i];
                            double weight = spiralModel.weights[i];
                            double primalAng = (val+.5)/spiralModel.params.nParts.get() * (Math.PI*.5);
                            double maybeTopMomentAng = primalAng;
                            putDatumHere[0] = RTOD(primalAng);
                            putDatumHere[1] = RTOD(maybeTopMomentAng);
                        }
                    },
                    new DataFetcher() { // dataFetcher
                        public int nData()
                        {
                            return spiralModel.params.n.get();
                        }
                        public void getDatum(int i, double putDatumHere[/*2*/])
                        {
                            int val = spiralModel.theList[i];
                            double center[] = spiralModel.centers[i];
                            double weight = spiralModel.weights[i];
                            double primalAng = (val+.5)/spiralModel.params.nParts.get() * (Math.PI*.5);
                            double momentAng = Math.atan2(center[1],center[0]);
                            putDatumHere[0] = RTOD(primalAng);
                            putDatumHere[1] = RTOD(momentAng);
                        }
                    }
                );
            }


            // |areaBasedMoment|/(primalR*dualR^2) vs. primalAng-dualAng graph
            {
                int nParts = spiralModel.params.nParts.get();
                int pixelsPerPart = spiralView.pixelsPerPart.get();
                int pixelsInPlot = nParts * pixelsPerPart + 1;

                // these bounds include inner frame
                int x0 = (gsize.width-pixelsInPlot)/2;
                int x1 = x0 + pixelsInPlot;
                int y0 = gsize.height/2 + 10;
                int y1 = gsize.height - 50;

                drawOnePlot(
                    g,
                    gsize,
                    1,145,2, x0,x1, 2,3,1, "|areaBasedMoment| / (primalR*dualR^2)", null, // left to right
                    1,50,2,  y1,y0, 2,3,1, "primalAng-dualAng", null, // bottom to top

                    0., 90., // values to put at x bounds
                    0., .25, // values to put at y bounds

                    9,10, // nMajor x,y

                    java.awt.Color.blue, // outerFrameColor
                    java.awt.Color.white, // innerFrameColor
                    gray64, // majorGridColor
                    gray64, // labelColor
                    java.awt.Color.green, // boundsColor
                    java.awt.Color.red, // dataColor
                    new DataFetcher() { // possibleBoundsFetcher
                        public int nData()
                        {
                            return spiralModel.params.n.get();
                        }
                        public void getDatum(int i, double putDatumHere[/*2*/])
                        {
                            int val = spiralModel.theList[i];
                            double center[] = spiralModel.centers[i];
                            double weight = spiralModel.weights[i];
                            double primalAng = (val+.5)/spiralModel.params.nParts.get() * (Math.PI*.5);
                            double twiceAreaBasedMomentMag = MyMath.hypot(center[1],center[0]) * weight;
                            double areaBasedMomentMag = .5 * twiceAreaBasedMomentMag;
                            double maxAreaBasedMomentMag = Math.sin(2*primalAng)/4; // i.e. tri area / 2

                            assert(areaBasedMomentMag < maxAreaBasedMomentMag);

                            putDatumHere[0] = RTOD(primalAng);
                            putDatumHere[1] = maxAreaBasedMomentMag;
                        }
                    },
                    new DataFetcher() { // dataFetcher
                        public int nData()
                        {
                            return spiralModel.params.n.get();
                        }
                        public void getDatum(int i, double putDatumHere[/*2*/])
                        {
                            int val = spiralModel.theList[i];
                            double center[] = spiralModel.centers[i];
                            double weight = spiralModel.weights[i];
                            double primalAng = (val+.5)/spiralModel.params.nParts.get() * (Math.PI*.5);
                            double twiceAreaBasedMomentMag = MyMath.hypot(center[1],center[0]) * weight;
                            double areaBasedMomentMag = .5 * twiceAreaBasedMomentMag;
                            putDatumHere[0] = RTOD(primalAng);
                            putDatumHere[1] = areaBasedMomentMag;
                        }
                    }
                );
            }

            // all angle-based moments x vs. y, scatter plot
            {
                int nParts = spiralModel.params.nParts.get();
                int pixelsPerPart = spiralView.pixelsPerPart.get();
                int pixelsInPlot = nParts * pixelsPerPart + 1;

                // these bounds include inner frame
                int y0 = 0 + 50;
                int y1 = gsize.height/2 - 10;
                int x0 = (gsize.width+pixelsInPlot)/2 + 10;
                int x1 = x0 + (y1-y0); // so it's square
                x0 += 30;
                y1 -= 30;

                drawOnePlot(
                    g,
                    gsize,
                    1,3,2,  x0,x1, 2,100,1, null, "y", // left to right
                    1,50,2, y1,y0, 2,3,1,   "x", null, // bottom to top

                    0., .25, // values to put at x bounds
                    0., .25, // values to put at y bounds

                    10,10, // nMajor x,y

                    java.awt.Color.blue, // outerFrameColor
                    java.awt.Color.white, // innerFrameColor
                    gray64, // majorGridColor
                    gray64, // labelColor
                    java.awt.Color.green, // boundsColor
                    java.awt.Color.red, // dataColor
                    new DataFetcher() { // possibleBoundsFetcher
                        public int nData()
                        {
                            return 2*90;
                        }
                        public void getDatum(int i, double putDatumHere[/*2*/])
                        {
                            if (i >= 90)
                            {
                                // more refined inner arc
                                i -= 90;
                                double angle = (i+.5)/90*(Math.PI/2);
                                double rMax = Math.cos(angle)*Math.sin(angle)/2;
                                if (false)
                                {
                                    rMax *= Math.cos(angle);
                                }
                                double xMax = Math.cos(angle)*rMax;
                                double yMax = Math.sin(angle)*rMax;

                                putDatumHere[0] = xMax;
                                putDatumHere[1] = yMax;
                            }
                            else
                            {
                                // outer circular arc
                                double worstFocusPrimalAngleMinusDualAngle = Math.PI/4;
                                double maxAreaBasedMomentMag = Math.sin(2*worstFocusPrimalAngleMinusDualAngle)/4; // i.e. tri area / 2
                                double angle = (i+.5)/90*(Math.PI/2);
                                double xMax = maxAreaBasedMomentMag * Math.cos(angle);
                                double yMax = maxAreaBasedMomentMag * Math.sin(angle);

                                putDatumHere[0] = xMax;
                                putDatumHere[1] = yMax;
                            }
                        }
                    },
                    new DataFetcher() { // dataFetcher
                        public int nData()
                        {
                            return spiralModel.params.n.get();
                        }
                        public void getDatum(int i, double putDatumHere[/*2*/])
                        {
                            int val = spiralModel.theList[i];
                            double center[] = spiralModel.centers[i];
                            double weight = spiralModel.weights[i];
                            double area = weight * .5;
                            double primalAng = (val+.5)/spiralModel.params.nParts.get() * (Math.PI*.5);

                            double areaBasedMomentX = center[0]*area;
                            double areaBasedMomentY = center[1]*area;

                            if (false)
                            {
                                // what if we divide by supposed upper bound, for this moment angle?
                                double angle = Math.atan2(center[1],center[0]);
                                double rMax = Math.cos(angle)*Math.sin(angle)/2;
                                areaBasedMomentX /= rMax;
                                areaBasedMomentY /= rMax;

                                // but then we need to scale down so it's still in the picture I think?
                                // i.e. multiply by .25
                                areaBasedMomentX /= 4;
                                areaBasedMomentY /= 4;
                            }

                            putDatumHere[0] = areaBasedMomentX;
                            putDatumHere[1] = areaBasedMomentY;
                        }
                    }
                );

            }

            // angle-based moments x vs. y, scatter plot,
            // only at the given focus angle
            {
                int nParts = spiralModel.params.nParts.get();
                int pixelsPerPart = spiralView.pixelsPerPart.get();
                int pixelsInPlot = nParts * pixelsPerPart + 1;

                // these bounds include inner frame
                int y0 = gsize.height/2 + 10;
                int y1 = gsize.height - 50;
                int x0 = (gsize.width+pixelsInPlot)/2 + 10;
                int x1 = x0 + (y1-y0); // so it's square

                drawOnePlot(
                    g,
                    gsize,
                    1,3,2,  x0,x1, 2,100,1, null, "y", // left to right
                    1,50,2, y1,y0, 2,3,1,   "x", null, // bottom to top

                    0., .25, // values to put at x bounds
                    0., .25, // values to put at y bounds

                    10,10, // nMajor x,y

                    java.awt.Color.blue, // outerFrameColor
                    java.awt.Color.white, // innerFrameColor
                    gray64, // majorGridColor
                    gray64, // labelColor
                    java.awt.Color.green, // boundsColor
                    java.awt.Color.red, // dataColor
                    new DataFetcher() { // possibleBoundsFetcher
                        public int nData()
                        {
                            return 4*90;
                        }
                        public void getDatum(int ii, double putDatumHere[/*2*/])
                        {
                            int iPicture = ii / 90;
                            int i = ii % 90;
                            if (iPicture == 0)
                            {
                                // outer circular arc
                                double maxAreaBasedMomentMag = Math.sin(2*focusPrimalAngleMinusDualAngle)/4; // i.e. tri area / 2
                                double angle = (i+.5)/90*(Math.PI/2);
                                double xMax = maxAreaBasedMomentMag * Math.cos(angle);
                                double yMax = maxAreaBasedMomentMag * Math.sin(angle);

                                putDatumHere[0] = xMax;
                                putDatumHere[1] = yMax;
                            }
                            else if (iPicture == 1)
                            {
                                // more refined inner arc
                                double angle = (i+.5)/90*(Math.PI/2);
                                double rMax = Math.cos(angle)*Math.sin(angle)/2;
                                double xMax = Math.cos(angle)*rMax;
                                double yMax = Math.sin(angle)*rMax;

                                putDatumHere[0] = xMax;
                                putDatumHere[1] = yMax;
                            }
                            else if (iPicture == 2)
                            {
                                // another inner arc somewhere else (not interesting)
                                double cosFocusAngle = Math.cos(focusPrimalAngleMinusDualAngle);
                                double maxAreaBasedMomentMag = cosFocusAngle / 4;
                                double angle = (i+.5)/90*(Math.PI/2);
                                double xMax = maxAreaBasedMomentMag * Math.cos(angle);
                                double yMax = maxAreaBasedMomentMag * Math.sin(angle);

                                putDatumHere[0] = xMax;
                                putDatumHere[1] = yMax;
                            }
                            else if (iPicture == 3)
                            {
                                // another funky estimate-- this one is a circle
                                // tangent the x axis at the origin,
                                // that seems to meet the original circle at the right place.
                                // still not right though.
                                double maxAreaBasedMomentMag = Math.sin(2*focusPrimalAngleMinusDualAngle)/4; // i.e. tri area / 2
                                double R = maxAreaBasedMomentMag / (2*Math.sin(focusPrimalAngleMinusDualAngle));
                                double t = LERP(-Math.PI*.5, Math.PI*.5, (i+.5)/90);
                                double xMax = Math.cos(t)*R;
                                double yMax = Math.sin(t)*R + R;

                                putDatumHere[0] = xMax;
                                putDatumHere[1] = yMax;
                            }
                            else
                                assert(false);
                        }
                    },
                    new DataFetcher() { // dataFetcher
                        public int nData()
                        {
                            return spiralModel.params.n.get();
                        }
                        double scratch[] = new double[3];
                        public void getDatum(int i, double putDatumHere[/*2*/])
                        {
                            int val = spiralModel.theList[i];
                            double primalAng = (val+.5)/spiralModel.params.nParts.get() * (Math.PI*.5);

                            double center[] = spiralModel.centers[i];
                            double weight = spiralModel.weights[i];

                            if (focusPrimalAngleMinusDualAngle > primalAng)
                                updateCenterAndWeightWhenPriscillaMoved(
                                    center[0], center[1], weight, primalAng,
                                    focusPrimalAngleMinusDualAngle,
                                    scratch);
                            else
                                updateCenterAndWeightWhenDudleyMoved(
                                    center[0], center[1], weight, primalAng,
                                    focusPrimalAngleMinusDualAngle,
                                    scratch);

                            double newCenterX = scratch[0];
                            double newCenterY = scratch[1];
                            double newWeight = scratch[2];
                            double newArea = newWeight * .5;
                            putDatumHere[0] = newCenterX * newArea;
                            putDatumHere[1] = newCenterY * newArea;
                        }
                    }
                );

            }
        } // drawStats

        public static void drawTicker(java.awt.Graphics g,
                                      java.awt.Dimension gsize,
                                      double gCenterX, double gCenterY, // in pixels from upper-left corner of window
                                      SpiralModel spiralModel,
                                      SpiralView spiralView,
                                      boolean pastelsFlag)
        {
            //System.out.println("    in drawTicker");
            int n = spiralModel.params.n.get();
            int nParts = spiralModel.params.nParts.get();
            int pixelsPerPart = spiralView.pixelsPerPart.get();
            //PRINT(nParts);
            //PRINT(pixelsPerPart);
            //PRINT(gCenterX);
            //PRINT(gCenterY);

            assert(n > 0);
            assert(pixelsPerPart > 0);
            assert(n % 2 == 0); // whole thing doesn't work otherwise


            java.awt.Color gray128 = new java.awt.Color(128,128,128);
            java.awt.Color gray64 = new java.awt.Color(64,64,64);
            java.awt.Color gray32 = new java.awt.Color(32,32,32);

            java.awt.Color pastels[] = new java.awt.Color[2*nParts+1];
            FORI(iPastel, 2*nParts+1)
                pastels[iPastel] = java.awt.Color.getHSBColor((float)iPastel/(float)(2*nParts), .5f, 1.f);


            // Given gCenterX,gCenterY,
            // figure out the "base" pixel index.
            // this is the pixel where val=0 would go
            // at an exact even integer focus
            // (val=0 is only achievable on even focus).
            // If ixBase,iyBase are both .5 mod 1,
            // then we round one down and one up-- that's the purpose of the -round(-) thing.
            // XXX TODO: this works since the inputs are all multiples of .5, but may not be the most robust way in general, should think about it more
            int ixBase = (int)Math.round(gCenterX + (nParts-1)*pixelsPerPart*.25 - .5);
            int iyBase = -(int)Math.round(-(gCenterY + (nParts-1)*pixelsPerPart*.25 - .5));
            // from now on we never use gCenterX,gCenterY again
            //PRINT(gCenterX + (nParts-1)*pixelsPerPart*.25 - .5);
            //PRINT(gCenterY + (nParts-1)*pixelsPerPart*.25 - .5);
            //PRINT(ixBase);
            //PRINT(iyBase);

            // figure out where to draw rails, i.e. bounds
            // of ticker strip.
            // this should be the same regardless of focus.
            //  1->1
            //  2->1
            //  3->2
            //  4->2
            //  5->3
            //  pixelsPerPart -> (pixelsPerPart+1)/2
            int ixLowerRail = ixBase;
            int iyLowerRail = iyBase + (pixelsPerPart+1)/2;
            int ixUpperRail = ixBase;
            int iyUpperRail = iyBase - (nParts-1)*pixelsPerPart - (pixelsPerPart+1)/2;

            {
                // draw the rails...
                // (diagonal lines lower-left to upper-right).
                g.setColor(gray128);
                int gsizeMin = MIN(gsize.width, gsize.height);
                g.drawLine(ixLowerRail-gsizeMin,iyLowerRail+gsizeMin,
                           ixLowerRail+gsizeMin,iyLowerRail-gsizeMin);
                g.drawLine(ixUpperRail-gsizeMin,iyUpperRail+gsizeMin,
                           ixUpperRail+gsizeMin,iyUpperRail-gsizeMin);
                // and the center line...
                g.setColor(gray32);
                if ((iyLowerRail-iyUpperRail)%2 == 0)
                {
                    // one diagonal line exactly halfway between rails
                    g.drawLine(ixLowerRail-gsizeMin,(iyLowerRail+iyUpperRail)/2+gsizeMin,
                               ixLowerRail+gsizeMin,(iyLowerRail+iyUpperRail)/2-gsizeMin);
                }
                else
                {
                    // two diagonal lines
                    g.drawLine(ixLowerRail-gsizeMin,(iyLowerRail+iyUpperRail-1)/2+gsizeMin,
                               ixLowerRail+gsizeMin,(iyLowerRail+iyUpperRail-1)/2-gsizeMin);
                    g.drawLine(ixLowerRail-gsizeMin,(iyLowerRail+iyUpperRail+1)/2+gsizeMin,
                               ixLowerRail+gsizeMin,(iyLowerRail+iyUpperRail+1)/2-gsizeMin);
                }
                // draw focus
                // (diagonal line upper-left to lower-right, across strip)
                g.setColor(gray128);
                if (pixelsPerPart%2 == 0)
                    FORI (iPart, nParts)
                        g.fillRect(ixBase-iPart*pixelsPerPart/2,
                                   iyBase-iPart*pixelsPerPart/2,1,1);
                else
                    FORI (iPart, nParts)
                    {
                        if (iPart%2==0)
                        {
                            g.setColor(gray128);
                            g.fillRect(ixBase-iPart*pixelsPerPart/2,
                                       iyBase-iPart*pixelsPerPart/2,1,1);
                        }
                        else
                        {
                            g.setColor(gray64);
                            g.fillRect(ixBase-(iPart*pixelsPerPart+1)/2,
                                       iyBase-(iPart*pixelsPerPart-1)/2,1,1);
                            g.fillRect(ixBase-(iPart*pixelsPerPart-1)/2,
                                       iyBase-(iPart*pixelsPerPart+1)/2,1,1);
                        }
                    }
            }

            if (false) // can change to true for debugging
            {
                if (false)
                {
                    // blue for base
                    g.setColor(java.awt.Color.blue);
                    FORI (iPart, nParts)
                        g.fillRect(ixBase,iyBase-iPart*pixelsPerPart,1,1);
                }

                if (true)
                {
                    // yellow for rail
                    g.setColor(java.awt.Color.yellow);
                    g.fillRect(ixLowerRail,iyLowerRail,1,1);
                    g.fillRect(ixUpperRail,iyUpperRail,1,1);
                }
            }


            // the two indices bounding
            // the focus
            spiralView.focus.modEquals(n,1); // make sure
            Rational focus = spiralView.focus;
            //PRINT(focus);
            int i0 = focus.floor();
            //PRINT(i0);
            Rational frac = focus.minus(i0,1); // frac = focus - i0, before modding i0 by n
            i0 = MOD(i0, n);
            //PRINT(i0);
            int i1 = (i0+1)%n;
            int val0 = spiralModel.theList[i0];
            int val1 = spiralModel.theList[i1];
            //PRINT(val0);
            //PRINT(val1);
            //PRINT(frac);
            Rational val = new Rational(val0,1).lerpEquals(val1,1, frac.n,frac.d); // val = lerp(val0,val1,frac)
            //PRINT(val);


            // Now we need to figure out
            // the exact pixel index at which to place the vertex i0.
            // Everything else will be computed exactly relative to that.
            //
            // There are two cases:
            //         increasing... focus is on a vertical segment,
            //         i.e. in the middle of a primal edge / dual vertex
            //             /     /
            //            /\i1  /
            //           /  |  /
            //          /  i0\/
            //         /     /
            //         decreasing... focus is on a horizontal segment,
            //         i.e. in the middle of a primal vertex / dual edge
            //             /     /
            //            /\    /
            //           /i0-i1/
            //          /    \/
            //         /     /

            int ix0, iy0;
            {
                // figure out how many pixels from base to i0

                Rational upperLeftOffset = new Rational(val0*pixelsPerPart, 2);
                Rational lowerLeftOffset = val.minus(val0,1).abs().times(pixelsPerPart,2);
                //PRINT(upperLeftOffset);
                //PRINT(lowerLeftOffset);

                // upperLeftOffset is now a multiple of .5.
                // adjust lowerLeftOffset to nearest Value that's the same as upperLeftOffset mod 1.

                if (upperLeftOffset.d == 1) // i.e. if it's an integer
                    lowerLeftOffset.roundEquals();
                else
                    lowerLeftOffset.plusEquals(1,2).roundEquals().minusEquals(1,2); // round to nearest thing that's .5 mod 1
                //PRINT(lowerLeftOffset);

                //double xOffset = (-upperLeftOffset - lowerLeftOffset);
                //double yOffset = (-upperLeftOffset + lowerLeftOffset);
                //assert((double)(int)xOffset == xOffset);
                //assert((double)(int)yOffset == yOffset);

                Rational xOffset = upperLeftOffset.times(-1,1).minus(lowerLeftOffset);
                Rational yOffset = upperLeftOffset.times(-1,1).plus(lowerLeftOffset);
                //PRINT(xOffset);
                //PRINT(yOffset);
                assert(xOffset.d == 1);
                assert(yOffset.d == 1);


                ix0 = ixBase + xOffset.n;
                iy0 = iyBase + yOffset.n;
                //PRINT(ix0);
                //PRINT(iy0);
            }

            if (true)
            {
                g.setColor(new java.awt.Color(128,128,255)); // light blue
                {
                    int prevX = ix0;
                    int prevY = iy0;
                    int prevVal = spiralModel.theList[i0];
                    for (int i = (i0+1)%n; ; i = (i+1)%n)
                    {
                        int thisVal = spiralModel.theList[i];
                        int thisX, thisY;
                        if (thisVal > prevVal)
                        {
                            // vertical seg upwards
                            thisX = prevX;
                            thisY = prevY - (thisVal-prevVal) * pixelsPerPart;
                        }
                        else
                        {
                            // horizonal seg to right
                            thisY = prevY;
                            thisX = prevX + (prevVal-thisVal) * pixelsPerPart;
                        }
                        if (pastelsFlag)
                            g.setColor(pastels[(int)(prevVal)+thisVal+1]);
                        g.drawLine(prevX,prevY,thisX,thisY);
                        if (thisX >= gsize.width || thisY < 0)
                            break;
                        prevVal = thisVal;
                        prevX = thisX;
                        prevY = thisY;
                    }
                }

                g.setColor(new java.awt.Color(128,255,128)); // light green
                {
                    int prevX = ix0;
                    int prevY = iy0;
                    int prevVal = spiralModel.theList[i0];
                    for (int i = MOD(i0-1,n); ; i = MOD(i-1,n))
                    {
                        int thisVal = spiralModel.theList[i];
                        int thisX, thisY;
                        if (thisVal < prevVal)
                        {
                            // vertical seg downwards
                            thisX = prevX;
                            thisY = prevY + (prevVal-thisVal) * pixelsPerPart;
                        }
                        else
                        {
                            // horizonal seg to left
                            thisY = prevY;
                            thisX = prevX - (thisVal-prevVal) * pixelsPerPart;
                        }
                        if (pastelsFlag)
                            g.setColor(pastels[(int)(prevVal)+thisVal+1]);
                        g.drawLine(prevX,prevY,thisX,thisY);
                        if (thisX < 0 || thisY >= gsize.height)
                            break;
                        prevVal = thisVal;
                        prevX = thisX;
                        prevY = thisY;
                    }
                }
            }

            //System.out.println("    out drawTicker");
        } // drawTicker

        // returns number of inner loop iterations.
        public static int drawSpiral(MyGraphics mg,
                                     SpiralModel spiralModel,
                                     SpiralView spiralView,
                                     boolean drawPrimalFlag,
                                     boolean drawDualFlag,
                                     boolean drawRungsFlag,
                                     int orientationNumber,
                                     boolean pastelsFlag,
                                     boolean antiAliasFlag)
        {
            int debugLevel = 0; // 1 = global, 2 = and some per-increment

            // have to be drawing something
            assert(drawPrimalFlag || drawDualFlag || drawRungsFlag);
            // don't draw primal and dual at same time
            assert(!drawPrimalFlag || !drawDualFlag);

            if (debugLevel >= 1) System.out.println("    in drawSpiral "+(drawPrimalFlag?"primal":"")+(drawDualFlag?"dual":"")+(drawRungsFlag?",rungs":""));

            int n = spiralModel.params.n.get();
            int nParts = spiralModel.params.nParts.get();

            // the two indices bounding
            // the focus
            spiralView.focus.modEquals(n,1); // make sure
            Rational focus = spiralView.focus;
            if (debugLevel >= 1) PRINT(focus);
            int i0 = focus.floor();
            if (debugLevel >= 1) PRINT(i0);
            Rational frac = focus.minus(i0,1); // frac = focus - i0, before modding i0 by n
            i0 = MOD(i0, n);
            if (debugLevel >= 1) PRINT(i0);
            int i1 = (i0+1)%n;
            int val0 = spiralModel.theList[i0];
            int val1 = spiralModel.theList[i1];
            if (debugLevel >= 1) PRINT(val0);
            if (debugLevel >= 1) PRINT(val1);
            if (debugLevel >= 1) PRINT(frac);
            double val = LERP(val0,val1,frac.toDouble()); // XXX TODO: use rational arithmetic all the way through... maybe? actually might not be necessary in this function
            if (debugLevel >= 1) PRINT(val);

            if (debugLevel >= 1)
            {
                PRINT(focus);
                PRINT(i0);
                PRINT(i1);
                PRINT(frac);
                PRINT(val0);
                PRINT(val1);
                PRINT(val);
            }

            java.awt.Color gray128 = new java.awt.Color(128,128,128);
            java.awt.Color gray64 = new java.awt.Color(64,64,64);
            java.awt.Color gray32 = new java.awt.Color(32,32,32);
            java.awt.Color pink = new java.awt.Color(255,128,128);
            java.awt.Color dimPink = new java.awt.Color(128,64,64);

            java.awt.Color pastels[] = new java.awt.Color[2*nParts+1];
            FORI(iPastel, 2*nParts+1)
                pastels[iPastel] = java.awt.Color.getHSBColor((float)iPastel/(float)(2*nParts), .5f, 1.f);

            int returnValue = 0;


            // fudge using orientationNumber-- orientationNumber=1 means don't rotate
            double orientationAngleFudge = (orientationNumber-1)/12.*(2*Math.PI); // naive
            {
                double primalAng = Math.PI/2 * ((val+.5)/nParts);
                switch (orientationNumber % 3)
                {
                    case 0:
                        // rotate bisector to x axis
                        orientationAngleFudge = -primalAng*.5;
                        break;
                    case 1:
                        // rotate dual angle (0) to x axis-- already there
                        orientationAngleFudge = 0.;
                        break;
                    case 2:
                        // rotate primal to y axis
                        orientationAngleFudge = Math.PI*.5 - primalAng;
                        break;
                    default:
                        assert(false);
                }
                orientationAngleFudge += (orientationNumber/3) * (Math.PI*.5);
            }
            double sinOrientationAngleFudge = Math.sin(orientationAngleFudge);
            double cosOrientationAngleFudge = Math.cos(orientationAngleFudge);


            if (drawPrimalFlag)
            {
                if (pastelsFlag)
                    mg.setColor(pastels[(int)(2*val+1)]);
                else
                    mg.setColor(java.awt.Color.cyan);
                double primalAng = Math.PI/2 * ((val+.5)/nParts) + orientationAngleFudge;
                mg.drawLine(0.,0.,Math.cos(primalAng),Math.sin(primalAng),antiAliasFlag);
            }




            // scanDir=1: the part *after* (bigger than) the focus.
            // scanDir=-1: the part *before* (smaller than) the focus.
            int scanDirs[] = {1, -1};
            FORI (iScanDir, 2)
            {
                int scanDir = scanDirs[iScanDir];
                if (debugLevel >= 1) System.out.println("        scanDir = "+scanDir);

                if (drawPrimalFlag)
                {
                    if (scanDir < 0)
                        mg.setColor(new java.awt.Color(128,255,128)); // light green
                    else
                        mg.setColor(new java.awt.Color(128,128,255)); // light blue
                }
                else
                {
                    if (scanDir < 0)
                        mg.setColor(java.awt.Color.white);
                    else
                        mg.setColor(gray64);
                }


                double dualAng = 0 + orientationAngleFudge;
                double primalAng = Math.PI/2 * ((val+.5)/nParts) + orientationAngleFudge;


                double dualR = 1.;
                double primalR = 1.;

                double dualX = dualR * Math.cos(dualAng);
                double dualY = dualR * Math.sin(dualAng);
                double primalX = primalR * Math.cos(primalAng);
                double primalY = primalR * Math.sin(primalAng);

                if (debugLevel >= 1 && scanDir > 0)
                {
                    PRINT(RTOD(primalAng));
                    PRINT(RTOD(dualAng));
                    PRINT(primalX);
                    PRINT(primalY);
                }



                // Accumulate and draw center of curvature, if scanDir  is -1
                double centerX = 0.;
                double centerY = 0.;
                double twiceArea = 0.;
                boolean centerHasStabilized = false;


                double prevPrevVal = val;
                double prevVal = val;
                for (int i = scanDir==1?i1:i0; ; i = MOD(i+scanDir,n))
                {
                    returnValue++;

                    // TODO: combine straight parts, the line will look better

                    int thisVal = spiralModel.theList[i];
                    if (scanDir==1 ? thisVal > prevVal : thisVal < prevVal)
                    {
                        // primal movement, dual turn
                        if (debugLevel >= 2 && scanDir > 0) System.out.println("            primal movement, dual turn");
                        double angleDelta = (double)(thisVal-prevVal)/(double)nParts * (Math.PI*.5);
                        if (debugLevel >= 2 && scanDir > 0) PRINT(RTOD(angleDelta));
                        double nextPrimalAng = primalAng + angleDelta;
                        if (nextPrimalAng > Math.PI)
                            nextPrimalAng -= 2*Math.PI;
                        else if (nextPrimalAng < -Math.PI)
                            nextPrimalAng += 2*Math.PI;
                        if (debugLevel >= 2 && scanDir > 0) PRINT(RTOD(nextPrimalAng));
                        double nextPrimalR = primalR * Math.cos(primalAng-dualAng)
                                                     / Math.cos(nextPrimalAng-dualAng);
                        double nextPrimalX = nextPrimalR * Math.cos(nextPrimalAng);
                        double nextPrimalY = nextPrimalR * Math.sin(nextPrimalAng);
                        if (debugLevel >= 2 && scanDir > 0) PRINT(nextPrimalR);
                        if (debugLevel >= 2 && scanDir > 0) PRINT(nextPrimalX);
                        if (debugLevel >= 2 && scanDir > 0) PRINT(nextPrimalY);

                        if (pastelsFlag)
                            mg.setColor(pastels[(int)(prevVal)+thisVal+1]);
                        if (drawPrimalFlag)
                        {
                            mg.drawLine(primalX, primalY,
                                        nextPrimalX, nextPrimalY,
                                        antiAliasFlag);
                            if (
                                prevPrevVal != prevVal &&
                                (thisVal<prevVal) != (prevVal<prevPrevVal))
                            {
                                // draw point at larger-index endpoint of the line
                                if (scanDir < 0)
                                {
                                    mg.drawPoint(primalX, primalY, 5);
                                }
                                else
                                {
                                    mg.drawPoint(primalX, primalY, 3);
                                }
                            }
                            if (scanDir > 0)
                            {
                                if (SQR(nextPrimalX)+SQR(nextPrimalY)
                                   > SQR(1) + SQR(2)) // XXX should be max distance of any corner of window from origin
                                    break;
                            }
                            else
                            {
                                if (SQR(nextPrimalX)+SQR(nextPrimalY) < SQR(1e-3)
                                 && centerHasStabilized)
                                    break;
                            }
                        }
                        if (drawRungsFlag &&
                            prevPrevVal != prevVal &&
                            (thisVal<prevVal != (prevVal<prevPrevVal)))
                        {
                            java.awt.Color savedColor = mg.getColor();
                            if (pastelsFlag)
                                mg.setColor(savedColor.darker().darker());
                            else
                                mg.setColor(dimPink);
                            mg.drawLine(primalX, primalY,
                                        dualX, dualY,
                                        antiAliasFlag);
                            mg.setColor(savedColor);
                        }

                        primalAng = nextPrimalAng;
                        primalR = nextPrimalR;
                        primalX = nextPrimalX;
                        primalY = nextPrimalY;
                    }
                    else if (scanDir==1 ? thisVal < prevVal : thisVal > prevVal)
                    {
                        // dual movement, primal turn
                        if (debugLevel >= 2 && scanDir > 0) System.out.println("            dual movement, primal turn");
                        double angleDelta = (double)(prevVal-thisVal)/(double)nParts * (Math.PI*.5);
                        double nextDualAng = dualAng + angleDelta;
                        if (nextDualAng > Math.PI)
                            nextDualAng -= 2*Math.PI;
                        else if (nextDualAng < -Math.PI)
                            nextDualAng += 2*Math.PI;
                        // worked this out on paper.
                        // don't think too hard about the scanDir=-1 case, in which case angleDelta is negative and the triangle is inside out... it just works.
                        double nextDualR= dualR * Math.sin(primalAng-dualAng)
                                                / Math.sin(primalAng-nextDualAng);
                        double nextDualX = nextDualR * Math.cos(nextDualAng);
                        double nextDualY = nextDualR * Math.sin(nextDualAng);

                        if (drawDualFlag)
                        {
                            if (pastelsFlag)
                                mg.setColor(pastels[(int)(prevVal)+thisVal+1]);
                            mg.drawLine(dualX, dualY,
                                        nextDualX, nextDualY,
                                        antiAliasFlag);

                            if (prevVal==prevPrevVal
                             || (thisVal<prevVal) != (prevVal<prevPrevVal))
                            {
                                if (scanDir < 0)
                                {
                                    mg.drawPoint(dualX, dualY, 5);
                                    mg.drawLine(0.,0.,
                                                dualX, dualY,
                                                antiAliasFlag);
                                }
                                else
                                    mg.drawPoint(dualX, dualY, 3);
                            }

                            if (scanDir > 0)
                            {
                                if (SQR(nextDualX)+SQR(nextDualY)
                                   > SQR(1) + SQR(2)) // XXX should be max distance of any corner of window from origin
                                    break;
                            }
                            else
                            {
                                if (SQR(nextDualX)+SQR(nextDualY) < SQR(1e-3)
                                 && centerHasStabilized)
                                    break;
                            }
                        }
                        if (drawRungsFlag &&
                            (prevVal!=prevPrevVal &&
                            (thisVal<prevVal != (prevVal<prevPrevVal))))
                        {
                            java.awt.Color savedColor = mg.getColor();
                            if (pastelsFlag)
                                mg.setColor(savedColor.darker().darker());
                            else
                                mg.setColor(dimPink);
                            mg.drawLine(primalX, primalY,
                                        dualX, dualY,
                                        antiAliasFlag);
                            mg.setColor(savedColor);
                        }

                        if (scanDir < 0)
                        {
                            double twiceAreaIncr = twiceTriangleArea(0.,0., dualX,dualY, nextDualX,nextDualY);
                            assert(twiceAreaIncr <= 0.); // area triangle is negative since scanning backwards
                            twiceAreaIncr = ABS(twiceAreaIncr);

                            if (twiceArea+twiceAreaIncr == twiceArea)
                            {
                                centerHasStabilized = true;
                                // don't break til it's all visually small enough too
                            }
                            //if (dualY != 0.) // experimenting-- if we omit first one, should sometimes assert-fail due to center being too low. seems to work.
                            {
                                twiceArea += twiceAreaIncr;

                                centerX = LERP(centerX, primalX, twiceAreaIncr/twiceArea);
                                centerY = LERP(centerY, primalY, twiceAreaIncr/twiceArea);
                                //PRINT(twiceAreaIncr);
                                //PRINT(twiceAreaIncr*primalX);
                                //PRINT(twiceAreaIncr*primalY);
                            }
                        }

                        dualAng = nextDualAng;
                        dualR = nextDualR;
                        dualX = nextDualX;
                        dualY = nextDualY;
                    }

                    if (drawDualFlag // actually maybe should be another flag for this?
                     && scanDir < 0)
                    {
                        // actually just want normalized, but we'll divide by dualR later instead
                        double m[][] = {
                            {dualX,dualY},
                            {-dualY,dualX},
                        };
                        double center[] = VecMath.vxm(spiralModel.centers[i], m);
                        VecMath.vxs(center, center, primalR/dualR); // divide by dualR because we should never have multiplied by it
                        //VecMath.vxs(center, center, 2.); // XXX I don't understand this
                        java.awt.Color savedColor = mg.getColor();
                        mg.setColor(java.awt.Color.yellow);

                        boolean big = (spiralModel.theList[i] > spiralModel.theList[(i+1)%n])
                                 && !(spiralModel.theList[MOD(i-1,n)] > spiralModel.theList[i]);
                        mg.drawPoint(center[0], center[1], big?3:1);
                        mg.setColor(savedColor);
                    }

                    prevPrevVal = prevVal;
                    prevVal = thisVal;
                }

                if (scanDir < 0 && drawPrimalFlag)
                {
                    mg.setColor(java.awt.Color.yellow);
                    mg.drawPoint(centerX, centerY, 5);
                    {
                        double centerYinCanonicalOrientation = -centerX*sinOrientationAngleFudge + centerY*cosOrientationAngleFudge;
                        if (centerYinCanonicalOrientation <= 0.)
                        {
                            System.out.println("HEY! centerY is "+centerY);
                        }
                        //assert(centerYinCanonicalOrientation > 0.);
                    }

                    {
                        double initialPrimalAng = (val+.5)/nParts*(Math.PI*.5); // dualAng is 0

                        if (pastelsFlag)
                            mg.setColor(pastels[(int)(2*val+1)]);
                        else
                            mg.setColor(gray128);

                        mg.drawThickArc(-1.,-1.,   // bounding box corner
                                        2., 2., // diameter
                                        0.+orientationAngleFudge, // startRadians
                                        initialPrimalAng, // arcRadians
                                        1., // thickness in pixels
                                        antiAliasFlag);

                        // Part of the theorem I'm trying to prove
                        // says that:
                        //      |moment| <= |p| |d|^2 sin(2 t) / 4   
                        // i.e. |center| <= |p| |d|^2 sin(2 t) / (4*area)
                        // i.e. |center| <= |p| |d|^2 sin(2 t) / (2*twiceArea)
                        // I.e. it's in a certain pie slice, bounded by two rays
                        // and an arc.  Draw that arc.
                        double arcRadius = Math.sin(2*initialPrimalAng) / (2*twiceArea);
                        mg.setColor(java.awt.Color.yellow);
                        mg.drawThickArc(-arcRadius,-arcRadius,
                                        2*arcRadius,2*arcRadius,
                                        0.+orientationAngleFudge, // startRadians
                                        initialPrimalAng, // arcRadians
                                        1., // thickness in pixels
                                        antiAliasFlag);


                        // well hell, that actually wasn't very interesting.
                        // let's actually do the actual moment and arc too, in magenta.
                        // (scaled so max possible is 1).
                        if (pastelsFlag)
                            mg.setColor(pastels[(int)(2*val+1)]);
                        else
                            mg.setColor(java.awt.Color.magenta);
                        arcRadius = Math.sin(2*initialPrimalAng);
                        mg.drawPoint(centerX*(2*twiceArea),centerY*(2*twiceArea),
                                     5);
                        mg.drawThickArc(-arcRadius,-arcRadius,
                                        2*arcRadius,2*arcRadius,
                                        0.+orientationAngleFudge, // startRadians
                                        initialPrimalAng, // arcRadians
                                        1., // thickness in pixels
                                        antiAliasFlag);

                        {
                            // Getting more interesting!
                            // this is actually visualizing what happens during the lemma.
                            // Let's get even more sophisticated--
                            // for every possible *next* value (from initialPrimalAng),
                            // show the moment of it.
                            double scratch[] = new double[3];
                            double c = cosOrientationAngleFudge;
                            double s = sinOrientationAngleFudge;
                            double centerXinCanonicalOrientation =  centerX*c + centerY*s;
                            double centerYinCanonicalOrientation = -centerX*s + centerY*c;
                            FORIDOWN (speculativeNextVal, nParts)
                            {
                                double speculativeNextPrimalAng = (speculativeNextVal+.5)/nParts*(Math.PI*.5);

                                updateCenterAndWeightWhenSomeoneMoved(
                                    centerXinCanonicalOrientation,
                                    centerYinCanonicalOrientation,
                                    twiceArea,
                                    initialPrimalAng,
                                    speculativeNextPrimalAng,
                                    scratch);
                                double speculativeNextCenterXinCanonicalOrientation = scratch[0];
                                double speculativeNextCenterYinCanonicalOrientation = scratch[1];
                                double speculativeNextTwiceArea = scratch[2];
                                double speculativeNextCenterX = speculativeNextCenterXinCanonicalOrientation*c - speculativeNextCenterYinCanonicalOrientation*s;
                                double speculativeNextCenterY = speculativeNextCenterXinCanonicalOrientation*s + speculativeNextCenterYinCanonicalOrientation*c;

                                {
                                    // oh no! it's only right now if dudly is on an axis
                                    // (i.e. orientationNumber mod 3 is 1).
                                    // handle fudge for the other two cases...
                                    double t = 0.;
                                    switch(orientationNumber % 3)
                                    {
                                        case 0:
                                            // we kept dudley fixed;
                                            // want to keep avg fixed instead.
                                            // rotate answer by ((oldP-oldD)-(newP-newD))/2.
                                            t = (initialPrimalAng-speculativeNextPrimalAng)*.5;
                                            break;
                                        case 1:
                                            // it's right already
                                            t = 0.;
                                            break;
                                        case 2:
                                        {
                                            // we kept dudley fixed;
                                            // want to keep priscilla fixed instead.
                                            // rotate answer by ((oldP-oldD)-(newP-newD)).
                                            t = initialPrimalAng-speculativeNextPrimalAng;
                                            break;
                                        }
                                        default:
                                            assert(false);
                                    }
                                    rotate(speculativeNextCenterX,
                                           speculativeNextCenterY,
                                           t,
                                           scratch);
                                    speculativeNextCenterX = scratch[0];
                                    speculativeNextCenterY = scratch[1];
                                }



                                if (false)
                                {
                                    // sanity check:
                                    // when priscilla moving (i.e. primal angle increasing),
                                    // the values in the upward trail should stay constant.
                                    // when dudley moving (i.e. primal angle decreasing),
                                    // the values in the downward trail should stay constant.

                                    //if (speculativeNextPrimalAng >= initialPrimalAng)
                                    if (speculativeNextPrimalAng <= initialPrimalAng)
                                    {
                                        System.out.print("    "+doubleToStringNice(RTOD(initialPrimalAng))+" -> "+doubleToStringNice(RTOD(speculativeNextPrimalAng))+":");
                                        System.out.println(" "+speculativeNextCenterX*speculativeNextTwiceArea
                                                           +" "
                                                           +speculativeNextCenterY*speculativeNextTwiceArea
                                                           +" "
                                                           +speculativeNextTwiceArea);
                                    }
                                }

                                if (pastelsFlag)
                                    mg.setColor(pastels[speculativeNextVal*2+1]);
                                mg.drawPoint(speculativeNextCenterX*(2*speculativeNextTwiceArea),
                                             speculativeNextCenterY*(2*speculativeNextTwiceArea),
                                             pastelsFlag ? 3 : 1);
                            }
                            if (false)
                                OUT("-------------------");
                        }
                    }
                }

            } // for iScanDir

            if (debugLevel >= 1) System.out.println("    out drawSpiral "+(drawPrimalFlag?"primal":"")+(drawDualFlag?"dual":"")+(drawRungsFlag?",rungs":""));
            return returnValue;
        } // drawSpiral


        private void accelBackward()
        {
            boolean startAnimationFlag = theSpiralView.focusAnimationVelocity.n == 0;
            theSpiralView.focusAnimationVelocity.minusEquals(theSpiralView.focusQuantum);
            if (startAnimationFlag)
                startTheAnimation();
        }
        private void stepBackward()
        {
            theSpiralView.focusAnimationVelocity.set(0,1);
            theSpiralView.focus.minusEquals(theSpiralView.focusQuantum);
            theSpiralView.focus.modEquals(theSpiralModel.params.n.get(), 1);
            theCanvas.repaint();
        }
        private void pause()
        {
            theSpiralView.focusAnimationVelocity.set(0,1);
            theCanvas.repaint();
        }
        private void stepForward()
        {
            theSpiralView.focusAnimationVelocity.set(0,1);
            theSpiralView.focus.plusEquals(theSpiralView.focusQuantum);
            theSpiralView.focus.modEquals(theSpiralModel.params.n.get(), 1);
            theCanvas.repaint();
        }
        private void accelForward()
        {
            boolean startAnimationFlag = theSpiralView.focusAnimationVelocity.n == 0;
            theSpiralView.focusAnimationVelocity.plusEquals(theSpiralView.focusQuantum);
            if (startAnimationFlag)
                startTheAnimation();
        }

        // actually this should probably be in a listener on focusAnimationVelocity
        // I probably have the thread-safety all wrong too
        // but then again I probably have it wrong for paint as well...
        // XXX paint really needs to take a synchronized snapshot of everything it needs, I think...
        // and, acquire a lock on the big things that don't change often but that are too expensive to snapshot
        // (the model).
        private javax.swing.Timer theTimer = null;
        javafx.animation.AnimationTimer theAnimationTimer = null;
        private void startTheAnimation()
        {
            System.out.println("in startTheAnimation");
            if (!useJavaFX)
            {
                if (theTimer == null)
                {
                    System.out.println("    creating timer");
                    theTimer = new javax.swing.Timer(animSleepMS.get(), new java.awt.event.ActionListener() {
                        @Override
                        public void actionPerformed(java.awt.event.ActionEvent e) {
                            if (eventVerbose >= 1) System.out.println("in timer action");

                            // TODO: make a synchronizedGet() and synchronizedSet() method to facilitate this?
                            boolean focusAnimationVelocityIsZero;
                            synchronized(theSpiralView.focusAnimationVelocity)
                            {
                                focusAnimationVelocityIsZero = (theSpiralView.focusAnimationVelocity.n == 0);
                            }
                            if (focusAnimationVelocityIsZero)
                            {
                                System.out.println("    stopping timer");
                                theTimer.stop();
                            }

                            theCanvas.repaint();
                            int animSleepMSvalue = animSleepMS.get();
                            if (animSleepMSvalue >= 0)
                                theTimer.setDelay(animSleepMSvalue);

                            if (false) // can set this to true to make the timing graph show time between firings
                            {
                                double now = timingGraph.timeSeconds();
                                timingGraph.startTimes.set(timingGraph.startTimes.size()-1, now);
                                timingGraph.endTimes.set(timingGraph.endTimes.size()-1, now);
                            }
                            if (eventVerbose >= 1) System.out.println("out timer action");
                        }
                    });
                }
                System.out.println("    starting timer");
                theTimer.start();
            }
            if (useJavaFX)
            {
                if (theAnimationTimer == null)
                {
                    // interesting, see http://www.javamex.com/tutorials/threads/sleep.shtml for issues and bugs
                    System.out.println("    creating javafx animation timer");
                    theAnimationTimer = new javafx.animation.AnimationTimer() {
                        public void handle(long nanos)
                        {
                            if (eventVerbose >= 1) System.out.println("in timer action");

                            // TODO: make a synchronizedGet() and synchronizedSet() method to facilitate this?
                            boolean focusAnimationVelocityIsZero;
                            synchronized(theSpiralView.focusAnimationVelocity)
                            {
                                focusAnimationVelocityIsZero = (theSpiralView.focusAnimationVelocity.n == 0);
                            }
                            if (focusAnimationVelocityIsZero)
                            {
                                System.out.println("    stopping javafx animation timer");
                                theAnimationTimer.stop();
                            }


                            int animSleepMSvalue = animSleepMS.get();
                            try { Thread.sleep(MAX(animSleepMSvalue,0)); } catch (InterruptedException e) {}
                            theCanvas.repaint();


                            if (false) // can set this to true to make the timing graph show time between firings
                            {
                                double now = timingGraph.timeSeconds();
                                timingGraph.startTimes.set(timingGraph.startTimes.size()-1, now);
                                timingGraph.endTimes.set(timingGraph.endTimes.size()-1, now);
                            }
                            if (eventVerbose >= 1) System.out.println("out timer action");
                        }
                    };
                }
                System.out.println("    starting timer");
                theAnimationTimer.start();
            }
            System.out.println("out startTheAnimation");
        }


    //
    // App-specific variables...
    //


        public static boolean useJavaFX = true;
        public SpiralModel.Params spiralModelParams = new SpiralModel.Params(); // gui copy, flushed to model when Regenerate button pressed
        public SpiralModel theSpiralModel = new SpiralModel();
        public SpiralView theSpiralView = new SpiralView();
        public Listenable.Int animSleepMS = new Listenable.Int(0, 1000*1000, -1); // 11 seems to be empirical sweet spot when using javax.swing.Timer... still speeds up for a few frames every 5 seconds or so
        public Listenable.Boolean showTimingFlag = new Listenable.Boolean(false);
        public Listenable.Boolean showTickerFlag = new Listenable.Boolean(true);
        public Listenable.Boolean showSpiralFlag = new Listenable.Boolean(true);
        public Listenable.Boolean showStatsFlag = new Listenable.Boolean(false);
        public Listenable.Boolean showVsyncLapsesFlag = new Listenable.Boolean(false);
        public JRow focusInControlPanelRow = null;


        private java.awt.Component theCanvas = null;
        private javafx.scene.image.ImageView theImageView = null;
        //private java.awt.Component theHelpWindow = null;
        private JFrame theMainAppletWindow = null;
        private JFrame theControlPanelWindow = null;
        private JFrame theHelpWindow = null;
        private Listenable.String windowTitle = new Listenable.String("Spiral Applet");

        private Listenable.Listener repaintWhenValueChanged = null;

        private Listenable.Listener showRungsFlagListener = null;
        private Listenable.Listener focusListener = null;
        private Listenable.Listener pixelsPerPartListener = null;
        private Listenable.Listener quantaPerPartListener = null;
        private Listenable.Listener showTimingFlagListener = null;
        private Listenable.Listener showTickerFlagListener = null;
        private Listenable.Listener showSpiralFlagListener = null;
        private Listenable.Listener showStatsFlagListener = null;


    //
    // Applet-generic member variables...
    //
        private GraphicsAntiAliasingSetter graphicsAntiAliasingSetter;
        private int eventVerbose = 0; // can set with eventVerbose=1 on command line
        private static int nonEventVerbose = 0; // so static classes can refer to it
        private boolean antiAliasingFlag = false;
        private boolean implementAntiAliasingInHardware = true; // XXX should have a better name for this-- really mean let java runtime do it
        private boolean doubleBufferFlag = false; // TODO: swing does this for us... can get rid of it, as soon as I figure out how to do the magnifying glass without it
        private java.awt.Image backBufferImage = null;
        private MyGraphics3D mostRecentGraphics = null;
        private int nPaints = 0;


    public static class JTextFieldForString extends JValidatingTextField
    {
        private Listenable.Listener listener; // need to keep a strong ref to it for as long as I'm alive
        public JTextFieldForString(final Listenable.String s)
        {
            super(s.get());
            s.addListener(listener = new Listenable.Listener() {
                @Override
                public void valueChanged()
                {
                    setText(s.get());
                }
            });
            addActionListener(new java.awt.event.ActionListener() {
                @Override
                public void actionPerformed(java.awt.event.ActionEvent e)
                {
                    s.set(getText());
                }
            });
        }
    } // JTextFieldForString



    // Stolen from MC4DControlPanel.java
    public static class JTextFieldForNumber extends JValidatingTextField
    {
        private Listenable.Listener listener; // need to keep a strong ref to it for as long as I'm alive
        private Listenable.Number f;

        @Override
        public boolean validate(String text)
        {
            try {
                // attempt to parse, ignore return value
                if (f instanceof Listenable.Int)
                    Integer.parseInt(text);
                else
                    Double.parseDouble(text);
                return true;
            } catch (Exception e) {
                return false;
            }
        }

        // common code we call in a couple of places
        private void updateText(Listenable.Number f)
        {
            if (f instanceof Listenable.Int)
                setText(""+((Listenable.Int)f).get());
            else if (f instanceof Listenable.Float)
                setText(""+((Listenable.Float)f).get());
            else
                setText(""+(float)((Listenable.Double)f).get()); // XXX ARGH! we lose precision with this (float) cast, but if we don't do it, we can get, for example, 37.092999999999996 which looks lame.  should figure out another way to prevent that.
        }

        public JTextFieldForNumber(final Listenable.Number f)
        {
            super(f instanceof Listenable.Int ? ""+((Listenable.Int)f).max() // XXX not quite right, min may be longer string than max
                   : "99.99"); // give it enough space for 99.999 (on my computer, always seems to give an extra space, which we don't need)
            this.f = f;
            updateText(f);
            f.addListener(listener = new Listenable.Listener() {
                @Override
                public void valueChanged()
                {
                    updateText(f);
                }
            });
            addActionListener(new java.awt.event.ActionListener() {
                @Override
                public void actionPerformed(java.awt.event.ActionEvent e)
                {
                    try
                    {
                        f.setDouble(Double.valueOf(getText()).doubleValue());
                    }
                    catch (java.lang.NumberFormatException nfe)
                    {
                        // maybe should print an error message or something
                        updateText(f);
                    }
                }
            });
        }

        @Override
        public java.awt.Dimension getPreferredSize()
        {
            //System.out.println("in JTextFieldForNumber.getPreferredSize()");
            // default seems taller than necessary
            // on my computer... and in recent VMs it's even worse
            // (changed from 29 to 31).
            // Fudge it a bit...
            // XXX not sure this will look good on all systems... if it doesn't, we can just remove it
            // XXX hmm, actually makes things mess up when growing and shrinking, that's weird
            java.awt.Dimension preferredSize = super.getPreferredSize();
            //System.out.println("textfield.super.preferredSize() = "+preferredSize);
            if (true)
                preferredSize.height -= 2;

            // XXX another hack, wtf?
            if (true)
            {
                if (f instanceof Listenable.Int)
                    preferredSize.width = 55; // big enough to hold 1,000,000 comfortably-- bleah
                else
                {
                    //preferredSize.width = 100;
                    preferredSize.width = 50; // for this app, this is plenty, although it's bogus in general
                }
            }

            //System.out.println("out JTextFieldForNumber.getPreferredSize(), returning "+preferredSize);
            return preferredSize;
        }
        // weird, the following is called during horizontal shrinking
        // but not during horizontal expanding... if we don't do this too
        // then it looks wrong when shrinking.  what a hack...
        @Override
        public java.awt.Dimension getMinimumSize()
        {
            //System.out.println("in JTextFieldForNumber.getMinimumSize()");
            java.awt.Dimension minimumSize = super.getMinimumSize();
            //System.out.println("textfield.super.minimumSize() = "+minimumSize);
            if (true)
                minimumSize.height -= 2;

            // XXX another hack, wtf?
            if (true)
            {
                if (f instanceof Listenable.Int)
                    minimumSize.width = 55;
                else
                    minimumSize.width = 100;
            }

            //System.out.println("out JTextFieldForNumber.getMinimumSize(), returning "+minimumSize);
            return minimumSize;
        }
    } // JTextFieldForNumber


    public static class JCheckBoxForBoolean extends JCheckBox
    {
        private Listenable.Listener listener; // need to keep a strong ref to it for as long as I'm alive
        public JCheckBoxForBoolean(String name, final Listenable.Boolean b)
        {
            super(name);
            setSelected(b.get());
            addItemListener(new java.awt.event.ItemListener() {
                @Override
                public void itemStateChanged(java.awt.event.ItemEvent e)
                {
                    b.set(isSelected());
                }
            });
            b.addListener(listener = new Listenable.Listener() {
                @Override
                public void valueChanged()
                {
                    setSelected(b.get());
                }
            });
        }
    } // JCheckBoxForBoolean

    public static class JSliderForFloat extends JSlider
    {
        private Listenable.Listener listener; // need to keep a strong ref to it for as long as I'm alive

        // private helper function
        private void updateThumb(Listenable.Number f)
        {
            double value = f.getDouble();
            double defaultValue = f.defaultDouble();
            double frac = (value-f.minDouble())/(f.maxDouble()-f.minDouble());

            //setValue((int)(getMinimum() + ((getMaximum()-getVisibleAmount())-getMinimum())*frac));
            setValue((int)(getMinimum() + (getMaximum()-getMinimum())*frac));
        }

        public JSliderForFloat(final Listenable.Number f)
        {
            // 3 significant digits seems reasonable...
            /*
            super(JSlider.HORIZONTAL,
                  (int)Math.round(f.minDouble()*1000),
                  (int)Math.round(f.maxDouble()*1000),
                  (int)Math.round(f.getDouble())*1000);
            */
            super(JSlider.HORIZONTAL, 0, 1000, 500);

            if (false)
            {
                PRINT(getMinimum());
                PRINT(getMaximum());
                PRINT(getValue());
            }

            setMinorTickSpacing(1);  // .001 units
            setMajorTickSpacing(10); // .01 units
            f.addListener(listener = new Listenable.Listener() {
                @Override
                public void valueChanged()
                {
                    updateThumb(f);
                }
            });
            addChangeListener(new javax.swing.event.ChangeListener() {
                @Override
                public void stateChanged(javax.swing.event.ChangeEvent e)
                {
                    if (false)
                    {
                        System.out.println("==================");
                        System.out.println("    min = "+getMinimum());
                        System.out.println("    max = "+getMaximum());
                        System.out.println("    max-min = "+(getMaximum()-getMinimum()));
                        System.out.println("    getValue() = "+getValue());
                        System.out.println("    getMinorTickSpacing() = "+getMinorTickSpacing());
                        System.out.println("    getMajorTickSpacing() = "+getMajorTickSpacing());
                        System.out.println("    getSize() = "+getSize());
                        System.out.println("    getPreferredSize() = "+getPreferredSize());
                    }
                    // Doing the following in double precision makes a difference;
                    // if we do it in float, we get ugly values in the textfield
                    double frac = (double)(getValue()-getMinimum())
                                / (double)(getMaximum()-getMinimum());
                    f.setDouble(f.minDouble() + frac*(f.maxDouble()-f.minDouble()));
                    // will trigger valueChanged()
                    // which will call updateThumb()
                }
            });
            updateThumb(f); // because we fucked it up in the contructor?
        }
    } // JSliderForFloat

    // nice utility, maybe move to donhatchsw
    public static void drawPixmapCentered(java.awt.Graphics g,
                                          java.awt.Dimension size,
                                          java.awt.Color asciiToColor[],
                                          String[] rows)
    {
        if (false)
        {
            // hack-- pad with the color at 0,0
            g.setColor(asciiToColor[rows[0].charAt(0)]);
            PRINT(size.width);
            PRINT(size.height);
            g.fillRect(0,0, size.width,size.height);
        }

        int x0 = (size.width - rows[0].length())/2;
        int y0 = (size.height - rows.length)/2;
        java.awt.Color prevColor = null;
        FORI (iRow, rows.length)
        {
            String row = rows[iRow];
            int nCols = row.length();
            FORI (iCol, nCols)
            {
                char c = row.charAt(iCol);
                java.awt.Color color = asciiToColor[c];
                if (color != null)
                {
                    if (color != prevColor)
                    {
                        g.setColor(color);
                        prevColor = color;
                    }
                    g.fillRect(x0+iCol, y0+iRow, 1, 1);
                }
            }
        }
    } // drawPixmapCentered


    // make it like a JLabel as much as possible, but text selectable
    private static void makeTextComponentLikeLabel(JTextComponent textComponent)
    {
        textComponent.setEditable(false);
        textComponent.setDisabledTextColor(java.awt.Color.black);
        textComponent.setBackground(null); // same as JLabel
        textComponent.setBorder(null); // same as JLabel
        textComponent.setEnabled(true); // otherwise not selectable
    }

    static JRow makeIncrementableTextFieldForInt(final Listenable.Number f, final String name, final double increment)
    {
        final java.awt.Color asciiToColor[] = new java.awt.Color[128];
        asciiToColor[' '] = null;
        asciiToColor['b'] = java.awt.Color.black;
        return new JRow() {{
            add(new JRepeatingButton("") {
                @Override
                public java.awt.Dimension getPreferredSize() { return new java.awt.Dimension(11,11); }
                @Override
                public java.awt.Dimension getMinimumSize()   { return new java.awt.Dimension(11,11); }
                @Override
                public void paint(java.awt.Graphics g)
                {
                    super.paint(g);
                    drawPixmapCentered(g, getSize(), asciiToColor,
                                       new String[] {
                                          "bbb bbb",
                                       });
                }
            {
                addActionListener(new java.awt.event.ActionListener() {
                    @Override
                    public void actionPerformed(java.awt.event.ActionEvent e)
                    {
                        f.setDouble(f.getDouble()-increment);
                    }
                });
                setToolTipText("<html>decrement "+name+"</html>");
            }});
            add(new JTextFieldForNumber(f) {{
                setToolTipText("<html>"+name+"</html>");
            }} );
            add(new JRepeatingButton("") {
                @Override
                public java.awt.Dimension getPreferredSize() { return new java.awt.Dimension(11,11); }
                @Override
                public java.awt.Dimension getMinimumSize()   { return new java.awt.Dimension(11,11); }
                @Override
                public void paint(java.awt.Graphics g)
                {
                    super.paint(g);
                    drawPixmapCentered(g, getSize(), asciiToColor,
                                       new String[] {
                                          " b   b ",
                                          "bbb bbb",
                                          " b   b ",
                                       });
                }
            {
                addActionListener(new java.awt.event.ActionListener() {
                    @Override
                    public void actionPerformed(java.awt.event.ActionEvent e)
                    {
                        f.setDouble(f.getDouble()+increment);
                    }
                });
                setToolTipText("<html>increment "+name+"</html>");
            }});
        }};
    } // makeIncrementableTextFieldForNumber






    private static java.lang.reflect.Method nanoTimeMethod = null;
    {
        try {
            nanoTimeMethod = System.class.getMethod("nanoTime", new Class[]{});
        }
        catch (NoSuchMethodException e) {System.out.println("no such method exception!");}
    }
    // System.nanoTime().
    // don't call this unless you know nanoTimeMethod != null.
    private static long System_nanoTime()
    {
        try {
            // object allocation here is a bummer.
            // maybe better to compile using javac >= 1.4
            // but with flag saying create class files for earlier jvm?
            Object answer = nanoTimeMethod.invoke(null, new Object[]{});
            return ((Long)answer).longValue();
        }
        catch (IllegalAccessException e) {assert(false); return 0L;}
        catch (java.lang.reflect.InvocationTargetException e) {assert(false); return 0L;}
    }

    // Time in seconds from when we initialize the times,
    // using System.nanoTime() if it exists (jvm >= 1.4),
    // otherwise System.currentTimeMillis().
    private static double timeSeconds()
    {
        boolean useNanoTime = (nanoTimeMethod != null);
        if (useNanoTime)
            return (double)(System_nanoTime() - nanos0) / 1e9;
        else
            return (double)(System.currentTimeMillis() - millis0) / 1e3;
    }

    private static long millis0 = System.currentTimeMillis();
    private static long nanos0 = (nanoTimeMethod!=null ? System_nanoTime() : 0L);


    //
    // Main...
    //
    public static void main(final String args[])
    {
        if (true)
        {
            Rational.confidenceTest();
        }
        if (false) // turn this on to get a crude little timing test
        {
            if (nanoTimeMethod != null)
            {
                FORI (ii,100)
                {
                    {
                        long m0 = System.currentTimeMillis();
                        long n0 = System_nanoTime();
                        FORI (i, 999)
                            System.currentTimeMillis();
                        long m1 = System.currentTimeMillis();
                        long n1 = System_nanoTime();
                        System.out.println("1000 m's and 1 n: "+(m1-m0)+" m");
                        System.out.println("1000 m's and 1 n: "+(n1-n0)+" n");
                    }
                    {
                        long n0 = System_nanoTime();
                        long m0 = System.currentTimeMillis();
                        FORI (i, 999)
                            System.currentTimeMillis();
                        long n1 = System_nanoTime();
                        long m1 = System.currentTimeMillis();
                        System.out.println("1000 m's and 1 n: "+(m1-m0)+" m");
                        System.out.println("1000 m's and 1 n: "+(n1-n0)+" n");
                    }
                }
                FORI (ii,100)
                {
                    {
                        long m0 = System.currentTimeMillis();
                        long n0 = System_nanoTime();
                        FORI (i, 999)
                            System_nanoTime();
                        long m1 = System.currentTimeMillis();
                        long n1 = System_nanoTime();
                        System.out.println("1 m and 1000 n's: "+(m1-m0)+" m");
                        System.out.println("1 m and 1000 n's: "+(n1-n0)+" n");
                    }
                    {
                        long n0 = System_nanoTime();
                        long m0 = System.currentTimeMillis();
                        FORI (i, 999)
                            System_nanoTime();
                        long n1 = System_nanoTime();
                        long m1 = System.currentTimeMillis();
                        System.out.println("1 m and 1000 n's: "+(m1-m0)+" m");
                        System.out.println("1 m and 1000 n's: "+(n1-n0)+" n");
                    }
                }

                System.out.println();
                System.exit(0);
            }
        }
        if (false)
        {
            // http://stackoverflow.com/questions/12805373/java-modulo-operator
            // surprising!
            //PRINT(fmod(5.59, 2));
            PRINT(5.59 % 2); // 1.5899999999999999
            PRINT(5.59 - 2); // 3.59
            PRINT(5.59 - 4); // 1.5899999999999999
            PRINT(5.59 - 2 - 2); // 1.5899999999999999
            PRINT(5.59); // 5.59
            PRINT(3.59); // 3.59
            PRINT(1.59); // 1.59
        }

        System.out.println("in main");
        System.out.println("    java "+System.getProperty("java.version"));


        final SpiralApplet applet = new SpiralApplet();

        final JFrame frame = new JFrame(applet.windowTitle.get());

        // TODO: what was I thinking?  can't use 1.2 any more?? need to use reflection to see whether I can do this
        //frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); // supposedly exists since java 1.4, but I can see starting in 1.3, weird
        frame.getContentPane().add(applet);

        //dumpComponentHierarchy(frame, 0, 0, 1);

        // the following seems to be necessary, or getParameter() will crash, at least in 1.4.  Want to send params from command line anyway.
        applet.setStub(new java.applet.AppletStub() {
             public void appletResize(int width, int height)
                 { /* should resize frame, but a SpiralApplet never asks to be resized */ }
             public java.applet.AppletContext getAppletContext() { return null;}
             public java.net.URL getCodeBase() { return null; }
             public java.net.URL getDocumentBase() { return null; }
             public String getParameter(String name)
             {
                 // case insensitive... and unfortunately there's no
                 // startsWithIgnoreCase
                 String prefix = name.toLowerCase() + "=";
                 int i;
                 FOR (i, args.length)
                     if (args[i].toLowerCase().startsWith(prefix))
                         return args[i].substring(prefix.length());
                 return null;
             }
             public boolean isActive() { return true; }
        });

        applet.init();
        applet.start();

        frame.setLocation(10, 10);
        frame.setSize(601,600);
        frame.setSize(718,583);
        frame.setSize(648,600);
        frame.setSize(512,353);

        frame.setVisible(true);

        applet.theMainAppletWindow = frame;


        // for benefit of any debugging function that wants to loop over frames...
        applet.theControlPanelWindow.setName("control panel window");
        applet.theMainAppletWindow.setName("main applet window");
        applet.theHelpWindow.setName("help");

        if (useJavaFX)
        {
            // creating a JFXPanel implicitly starts the JavaFX runtime.
            // unless we do this, the AnimationTimer will be non-functional!
            System.out.println("initializing javafx...");
            new javafx.embed.swing.JFXPanel();
            System.out.println("done.");
        }


        // do the timing workaround suggested in http://www.javamex.com/tutorials/threads/sleep_issues.shtml
        if (true)
        {
            Thread thread = new Thread(new Runnable() {
                public void run()
                {
                    System.out.println("in thread run");
                    System.out.println("    sleeping forever (http://www.javamex.com/tutorials/threads/sleep_issues.shtml)");
                    try { Thread.sleep(Long.MAX_VALUE); } catch (InterruptedException e) {}
                    assert(false);
                    System.out.println("out thread run");
                    System.exit(1);
                }
            });
            thread.setDaemon(true); // make it so the java vm won't wait for it to finish before exiting
            thread.start();
        }

        // why can't we get here in any toolkit ever?
        System.out.println("out main");
    } // main

} // class SpiralApplet
